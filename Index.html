<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title>Cashflow Helper</title>
<style>
:root{--c1:#4a90e2;--c2:#fff;--c3:#eee}
html,body{margin:0;padding:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",sans-serif;background:#f8f8f8;height:100%;scroll-behavior:smooth;padding-top:env(safe-area-inset-top);padding-bottom:env(safe-area-inset-bottom)}
nav{display:none;background:var(--c3);box-shadow:0 1px 3px rgba(0,0,0,.2);position:fixed;top:0;left:0;right:0;z-index:1000;padding-top:env(safe-area-inset-top);
overflow-x:auto;
-webkit-overflow-scrolling:touch;
}
nav button{flex:1 0 auto;padding:13px 2px;border:none;background:transparent;font-size:14px;cursor:pointer;min-width:70px;}nav button.active{background:var(--c1);color:#fff}
section{display:none;padding:18px;overflow-y:auto;max-height:calc(100dvh - 96px);margin-top:0}section.active{display:block;animation:fade .2s ease-out}
@keyframes fade{from{opacity:.3;transform:translateY(4px)}to{opacity:1;transform:none}}
table{width:100%;border-collapse:collapse;margin-top:8px;font-size:13px}
th,td{border:1px solid #ccc;padding:6px;text-align:center}
input[type=number],input[type=text],textarea{width:100%;box-sizing:border-box;padding:8px;border:1px solid #ccc;border-radius:4px;font-size:16px;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",sans-serif}
.row{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:12px;align-items:center}
.row>div{flex:1 1 auto;min-width:0}
.partner-money{flex-direction:column !important;align-items:stretch !important;gap:8px !important;margin-bottom:12px !important}
.row>div{flex:1 1 120px;min-width:90px}
.partner-money>div{margin:0 !important}
.partner-money select,.partner-money input,.partner-money button{margin:0 !important}
.btn{background:var(--c1);color:#fff;border:none;padding:8px 16px;border-radius:4px;cursor:pointer;font-size:16px}
/* Убираем синюю обводку при фокусе на кнопках (в т.ч. кнопках %): */
button:focus,button:focus-visible,.btn:focus,.btn:focus-visible{outline:none !important;box-shadow:none !important}
.toast{position:fixed;bottom:20px;left:50%;transform:translateX(-50%);background:#333;color:#fff;padding:10px 16px;border-radius:6px;opacity:0;transition:opacity .3s;pointer-events:none;z-index:9999}.toast.show{opacity:1}
/* Полноэкранное модальное окно */
#fullscreenTurnModal {
  position: fixed !important;
  top: 0 !important;
  left: 0 !important;
  width: 100vw !important;
  height: 100vh !important;
  min-height: 100vh !important;
  max-height: 100vh !important;
  background: rgba(0,0,0,0.9) !important;
  z-index: 10000 !important;
  display: none;
  align-items: center;
  justify-content: center;
  margin: 0 !important;
  padding: 0 !important;
  overflow: hidden !important;
  box-sizing: border-box !important;
}
#fullscreenTurnModal .modal-content {
  position: relative;
  width: 100vw !important;
  height: 100vh !important;
  min-height: 100vh !important;
  max-height: 100vh !important;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 20px;
  box-sizing: border-box;
  margin: 0 !important;
}
/* Адаптивность для мобильных устройств */
/* Ограничиваем 90vh только внутри модалки, чтобы не растягивать верстку */
#fullscreenTurnModal #fullscreenStartTurnBtn {
  height: 90vh !important;
}
/* В обычном режиме — компактная плавающая кнопка */
#fullscreenStartTurnBtn {
  height: 56px !important;
  width: 56px !important;
}
/* Уменьшение размера шрифта на очень маленьких экранах */
@media (max-height: 600px) {
  #fullscreenStartTurnBtn {
    font-size: 28px !important;
  }
  #fullscreenTurnNumber {
    font-size: 22px !important;
  }
}
.actBtn{background:none;border:none;font-size:18px;cursor:pointer;color:#888}
.paid td, tr.paid td {
  text-decoration: line-through;
  color: #aaa;
}
.paidChkSell {
  width: 28px;
  height: 28px;
  accent-color: #4a90e2;
  transform: scale(1.3);
}
.sumWithSell {
  min-width: 60px;
  font-weight: bold;
  font-size: 17px;
  letter-spacing: 1px;
}
.sumNoSell {
  min-width: 60px;
  font-weight: normal;
  font-size: 17px;
  letter-spacing: 1px;
}
/* Ширина для столбца Ком $, чтобы влезало до ~6 цифр */
.sumCommission {
  min-width: 100px;
}
.sumCardCell { min-width: 60px; font-weight: normal; font-size: 15px; color: inherit; }
.sumTotalSharesLabel {
  white-space: nowrap;
}
.nowrapLabel {
  white-space: nowrap;
}
.buyPriceNowrap {
  white-space: nowrap;
}
#sellTable, #sellTable th, #sellTable td {
  font-size: 14px !important;
}
#sellTable th {
  padding-top: 6px;
  padding-bottom: 6px;
}
#sellTable td {
  padding-top: 5px;
  padding-bottom: 5px;
}
.sell-header-summary {
  font-size: 13px !important;
}

/* Стили для списка лучших ЭфКПК */
#bestEffList {
  margin: 16px 0 0 0;
  padding: 16px;
  background: #f0f8ff;
  border: 1px solid #b3d6f6;
  border-radius: 8px;
  color: #444;
}

#bestEffList h3 {
  margin-top: 0;
  color: #226;
  font-size: 18px;
}

#bestEffList table {
  margin-top: 8px;
  font-size: 12px;
  border-collapse: collapse;
  width: 100%;
}

#bestEffList th,
#bestEffList td {
  border: 1px solid #b3d6f6;
  padding: 6px;
  text-align: left;
}

#bestEffList th {
  background: #e6f3ff;
  font-weight: bold;
  color: #226;
}

#bestEffList .closed-row {
  background: #f8f8f8;
  color: #888;
}

#bestEffList .active-row {
  background: #f0fff0;
}

#bestEffList .eff-value {
  font-weight: bold;
  color: #080;
  text-align: center;
}

#bestEffList .kpd-value {
  text-align: center;
  color: #226;
}

#bestEffList .kpk-value {
  text-align: center;
  color: #666;
}

#bestEffList .amount-value {
  text-align: right;
  font-weight: bold;
  color: #444;
}

#bestEffList .monthly-value {
  text-align: right;
  font-weight: bold;
  color: #080;
}

#bestEffList .status-active {
  color: #080;
  font-weight: bold;
  text-align: center;
}

#bestEffList .status-closed {
  color: #888;
  font-style: italic;
  text-align: center;
}

/* Стили для таблицы расходов — более нейтральные тона */
#ledgerExpenseTable {
  border-collapse: collapse;
  width: 100%;
  margin-top: 8px;
  font-size: 12px;
}

#ledgerExpenseTable th,
#ledgerExpenseTable td {
  border: 1px solid #e0e0e0;
  padding: 6px;
  text-align: center;
}

/* В расходах ширина столбца "Название" определяется по заголовку */
#ledgerExpenseTable th:nth-child(6),
#ledgerExpenseTable td:nth-child(6) {
  width: 1%;
  white-space: nowrap;
}

/* Колонка "Статус" - ширина по содержимому (как слово "есть") */
#ledgerExpenseTable th:nth-child(4),
#ledgerExpenseTable td:nth-child(4) {
  width: 1%;
  white-space: nowrap;
}

/* Ограничиваем ширину поля названия расхода */
#ledgerExpenseTable input[placeholder="Название расхода"] {
  width: 16ch !important;
  min-width: 12ch !important;
  max-width: 20ch !important;
  box-sizing: border-box;
}

#ledgerExpenseTable th {
  background: #f7f7f7;
  font-weight: bold;
  color: #333;
  text-align: center;
}

#ledgerExpenseTable tr.paid {
  background: #f8f8f8;
  color: #888;
}

#ledgerExpenseTable tr:not(.paid) {
  background: #ffffff;
}
#ledgerExpenseTable tr:not(.paid):hover {
  background: #f7f7f7;
}

/* Центрирование для столбца категории */
#ledgerExpenseTable td:nth-child(6) {
  text-align: center;
}

/* Центрирование метрик (ЭфКПК, КПК, КПД) */
#ledgerExpenseTable td:nth-child(1),
#ledgerExpenseTable td:nth-child(2),
#ledgerExpenseTable td:nth-child(3) {
  text-align: center;
}

/* Стили для таблицы доходов — зелёная тема */
#ledgerIncomeTable {
  border-collapse: collapse;
  width: 100%;
  margin-top: 8px;
  font-size: 12px;
}

#ledgerIncomeTable th,
#ledgerIncomeTable td {
  border: 1px solid #cdeccd;
  padding: 6px;
  text-align: center;
}

/* Ограничиваем ширину поля названия дохода */
#ledgerIncomeTable input[placeholder="Название"] {
  width: 20ch !important;
  min-width: 16ch !important;
  max-width: 24ch !important;
  box-sizing: border-box;
}

#ledgerIncomeTable th {
  background: #f0fff0;
  font-weight: bold;
  color: #080;
  text-align: center;
}

#ledgerIncomeTable tr:hover {
  background: #f6fff6;
}

/* Центрирование для столбца категории */
#ledgerIncomeTable td:nth-child(4) {
  text-align: center;
}

/* Центрирование метрик (ЭфКПК, КПК, КПД) */
#ledgerIncomeTable td:nth-child(1),
#ledgerIncomeTable td:nth-child(2),
#ledgerIncomeTable td:nth-child(3) {
  text-align: center;
}

/* Стили для таблицы прогноза — синяя тема */
#forecastTable {
  border-collapse: collapse;
  width: 100%;
  margin-top: 8px;
  font-size: 12px;
  table-layout: auto !important;
}

#forecastTable th,
#forecastTable td {
  border: 1px solid #b3d6f6;
  padding: 4px 6px;
  text-align: center;
}

#forecastTable th {
  background: #e6f3ff;
  font-weight: bold;
  color: #226;
  text-align: center;
  white-space: nowrap;
  width: 1%;
  font-size: 11px;
}

#forecastTable td {
  white-space: normal;
  word-break: break-word;
  font-size: 11px;
}

#forecastTable tr:hover {
  background: #f0f8ff;
}

/* Центрирование метрик (ЭфКПК, КПК, КПД) */
#forecastTable td:nth-child(1),
#forecastTable td:nth-child(2),
#forecastTable td:nth-child(3) {
  text-align: center;
  white-space: nowrap;
}

/* Колонка Тип — по ширине содержимого */
#forecastTable th:nth-child(9),
#forecastTable td:nth-child(9) {
  width: 1%;
  white-space: nowrap;
}

/* Колонка КПД — по ширине содержимого */
#forecastTable th:nth-child(4),
#forecastTable td:nth-child(4) {
  width: 1%;
  white-space: nowrap;
}

/* Цветовые акценты строк */
#forecastTable tr[style*="background:#f0f8ff"] { /* прогноз */
  border-left: 3px solid #4a90e2;
}
#forecastTable tr[style*="background:#fff0f0"] { /* расходы */
  border-left: 3px solid #e57373;
}
#forecastTable tr[style*="background:#f2f2f2"] { /* дефолтные */
  border-left: 3px solid #9ca3af;
}

/* Увеличенные чекбоксы в прогнозе */
#forecastTable .forecastChk { width: 22px; height: 22px; transform: scale(1.2); accent-color: #4a90e2; }

/* Заголовки разделов: Доходы — зелёным, Расходы — красным */
.income-section h4 { color: #080 !important; }
.expense-section h4 { color: #c33 !important; }

/* Убираем большую рамку у блока прогноза для ширины на мобильном */
#forecastBlock { border: none !important; max-width: 1000px !important; }

/* Контроль ширины столбцов в таблице прогноза */
#forecastTable th:first-child,
#forecastTable td:first-child {
  width: 25px !important;
  min-width: 25px !important;
  max-width: 25px !important;
  text-align: center !important;
}

#forecastTable th:nth-child(2),
#forecastTable td:nth-child(2) {
  width: 35px !important;
  min-width: 35px !important;
}

#forecastTable th:nth-child(3),
#forecastTable td:nth-child(3) {
  width: 30px !important;
  min-width: 30px !important;
}

#forecastTable th:nth-child(4),
#forecastTable td:nth-child(4) {
  width: 30px !important;
  min-width: 30px !important;
}

#forecastTable th:nth-child(5),
#forecastTable td:nth-child(5) {
  width: 55px !important;
  min-width: 55px !important;
}

#forecastTable th:nth-child(6),
#forecastTable td:nth-child(6) {
  width: 40px !important;
  min-width: 40px !important;
}

#forecastTable th:nth-child(7),
#forecastTable td:nth-child(7) {
  width: 55px !important;
  min-width: 55px !important;
}

#forecastTable th:nth-child(8),
#forecastTable td:nth-child(8) {
  width: 50px !important;
  min-width: 50px !important;
}

#forecastTable th:nth-child(9),
#forecastTable td:nth-child(9) {
  width: 45px !important;
  min-width: 45px !important;
}

#forecastTable th:nth-child(10),
#forecastTable td:nth-child(10) {
  width: 40px !important;
  min-width: 40px !important;
}

#forecastTable th:nth-child(11),
#forecastTable td:nth-child(11) {
  width: 30px !important;
  min-width: 30px !important;
}

#forecastTable th:nth-child(12),
#forecastTable td:nth-child(12) {
  width: 55px !important;
  min-width: 55px !important;
}

#forecastTable th:nth-child(13),
#forecastTable td:nth-child(13) {
  width: 50px !important;
  min-width: 50px !important;
}

/* Fix: remove hardcoded flex-basis on income inputs on mobile/any layout */
.income-section .row > div { flex: 1 1 auto !important; min-width: 0 !important; }
#incomeInvestWrap, #incomePriceWrap, #incomeMonthlyWrap, #incomeNameWrap { flex: 1 1 auto !important; min-width: 0 !important; }

/* Fix calculators and buy forms: prevent fixed 150–220px columns */
#profitableBuyCalculator .row > div,
.partner-calc .row > div,
#buy .row > div,
#buyEasy .row > div,
#buyBlock .row > div,
#sell .row > div { flex: 1 1 auto !important; min-width: 0 !important; }

/* Force-override any inline flex-basis like "flex: 0 0 150px" used in past tweaks */
.row > div[style*="flex: 0 0"],
.row > div[style*="flex:0 0"],
#profitableBuyCalculator [style*="flex: 0 0"],
#buyEasy [style*="flex: 0 0"],
#buyBlock [style*="flex: 0 0"],
#buy [style*="flex: 0 0"],
#sell [style*="flex: 0 0"] {
  flex: 1 1 auto !important;
  min-width: 0 !important;
}

/* Match reference: two-column layout on wide screens for Easy Buy */
@media (min-width: 700px){
  #buyEasy .row { display:flex; flex-wrap:wrap; gap:16px; }
  #buyEasy .row > div { flex: 1 1 320px !important; max-width: calc(50% - 16px); }
}
@media (max-width: 699px){
  #buyEasy .row > div { flex: 1 1 100% !important; max-width: 100% !important; }
}

/* Match reference: two-column layout for KPI calculator inputs too */
@media (min-width: 700px){
  #profitableBuyCalculator .row { display:flex; flex-wrap:wrap; gap:16px; }
  #profitableBuyCalculator .row > div { flex: 1 1 320px !important; max-width: calc(50% - 16px); }
}
@media (max-width: 699px){
  #profitableBuyCalculator .row > div { flex: 1 1 100% !important; max-width: 100% !important; }
}

@media (max-width: 600px) {
  /* Сбрасываем фиксированные ширины колонок .row на мобильных */
  .row > div { flex: 1 1 auto !important; min-width: 0 !important; }
  /* Внутри основных секций тоже полностью резиновые колонки */
  .income-section .row > div,
  .expense-section .row > div,
  .forecast-section .row > div { flex: 1 1 auto !important; min-width: 0 !important; }
  /* Чуть сжимаем отступы и предотвращаем наложение Название и Тип */
  #forecastTable { font-size: 11px; }
  #forecastTable th, #forecastTable td { padding: 3px 2px; }
  #forecastBlock { padding-left: 8px !important; padding-right: 8px !important; max-width: 1000px !important; }
  #forecastTable td:nth-child(7),
  #forecastTable td:nth-child(8) {
    max-width: 48vw;
    white-space: normal;
    word-break: break-word;
    overflow-wrap: anywhere;
  }
  
  /* Дополнительное сужение столбцов на мобильных */
  #forecastTable th:first-child,
  #forecastTable td:first-child {
    width: 25px !important;
    min-width: 25px !important;
    max-width: 25px !important;
  }
  
  #forecastTable th:nth-child(2),
  #forecastTable td:nth-child(2) {
    width: 30px !important;
    min-width: 30px !important;
  }
  
  #forecastTable th:nth-child(3),
  #forecastTable td:nth-child(3) {
    width: 25px !important;
    min-width: 25px !important;
  }
  
  #forecastTable th:nth-child(4),
  #forecastTable td:nth-child(4) {
    width: 25px !important;
    min-width: 25px !important;
  }
  
  #forecastTable th:nth-child(5),
  #forecastTable td:nth-child(5) {
    width: 45px !important;
    min-width: 45px !important;
  }
  
  #forecastTable th:nth-child(6),
  #forecastTable td:nth-child(6) {
    width: 35px !important;
    min-width: 35px !important;
  }
  
  #forecastTable th:nth-child(7),
  #forecastTable td:nth-child(7) {
    width: 45px !important;
    min-width: 45px !important;
  }
  
  #forecastTable th:nth-child(8),
  #forecastTable td:nth-child(8) {
    width: 40px !important;
    min-width: 40px !important;
  }
  
  #forecastTable th:nth-child(9),
  #forecastTable td:nth-child(9) {
    width: 35px !important;
    min-width: 35px !important;
  }
  
  #forecastTable th:nth-child(10),
  #forecastTable td:nth-child(10) {
    width: 35px !important;
    min-width: 35px !important;
  }
  
  #forecastTable th:nth-child(11),
  #forecastTable td:nth-child(11) {
    width: 25px !important;
    min-width: 25px !important;
  }
  
  #forecastTable th:nth-child(12),
  #forecastTable td:nth-child(12) {
    width: 45px !important;
    min-width: 45px !important;
  }
  
  #forecastTable th:nth-child(13),
  #forecastTable td:nth-child(13) {
    width: 40px !important;
    min-width: 40px !important;
  }
}

/* Стили для калькулятора выгодной покупки */
#profitableBuyCalculator {
  margin: 24px 0 16px 0;
  padding: 18px 16px;
  background: #f0fff0;
  border: 1px solid #b3f6b3;
  border-radius: 8px;
  color: #444;
  max-width: 900px;
}

#profitableBuyCalculator h3 {
  margin-top: 0;
  color: #080;
  font-size: 18px;
}

#profitableBuyCalculator input[type="number"] {
  width: 100%;
  padding: 8px;
  border: 1px solid #b3f6b3;
  border-radius: 4px;
  font-size: 16px;
}

#profitableBuyCalculator label {
  display: block;
  margin-bottom: 4px;
  font-weight: bold;
  color: #080;
}

#profitableBuyResult {
  background: #fff;
  border: 1px solid #b3f6b3;
  border-radius: 6px;
  padding: 16px;
  margin-top: 16px;
}
#profitableBuyResult h4 {
  margin-top: 0;
  color: #080;
}
@media (max-width: 600px) {
  .partner-calc {
    font-size: 14px !important;
    padding-left: 0 !important;
    word-break: break-word;
    white-space: normal;
    margin: 8px 0 16px 0 !important;
  }
  /* В мобильной версии сузим колонки Погашение и Ежемесячно в таблице расходов */
  #ledgerExpenseTable th:nth-child(7),
  #ledgerExpenseTable td:nth-child(7),
  #ledgerExpenseTable th:nth-child(8),
  #ledgerExpenseTable td:nth-child(8) {
    width: 65px !important;
  }
  /* Делаем секции на всю ширину экрана на мобильных */
  .income-section, .expense-section {
    flex: 0 0 100% !important;
    max-width: 100% !important;
    width: 100% !important;
  }
  /* Чуть уменьшаем боковые отступы контента, чтобы таблица была шире */
  section {
    padding-left: 8px;
    padding-right: 8px;
  }
  
  /* Убираем десктопные стили на мобильных */
  .income-section, .expense-section {
    background: transparent;
    border: none;
    padding: 0;
  }
  
  /* Адаптация списка лучших ЭфКПК для мобильных */
  #bestEffList {
    margin: 12px 0 0 0;
    padding: 12px;
  }
  
  #bestEffList table {
    font-size: 11px;
  }
  
  #bestEffList th,
  #bestEffList td {
    padding: 4px;
  }
  
  /* На мобильных скрываем некоторые колонки для экономии места */
  #bestEffList th:nth-child(4),
  #bestEffList td:nth-child(4),
  #bestEffList th:nth-child(5),
  #bestEffList td:nth-child(5),
  #bestEffList th:nth-child(8),
  #bestEffList td:nth-child(8) {
    display: none;
  }
  
  /* Адаптация таблиц для мобильных */
  #ledgerExpenseTable,
  #ledgerIncomeTable {
    font-size: 11px;
  }
  
  #ledgerExpenseTable th,
  #ledgerExpenseTable td,
  #ledgerIncomeTable th,
  #ledgerIncomeTable td {
    padding: 3px 2px;
  }
  
  /* Сужение столбцов в таблице доходов на мобильных */
  #ledgerIncomeTable th:nth-child(1),
  #ledgerIncomeTable td:nth-child(1),
  #ledgerIncomeTable th:nth-child(2),
  #ledgerIncomeTable td:nth-child(2),
  #ledgerIncomeTable th:nth-child(3),
  #ledgerIncomeTable td:nth-child(3) {
    width: 35px !important;
    min-width: 35px !important;
  }
  
  /* Сужение столбцов в таблице расходов на мобильных */
  #ledgerExpenseTable th:nth-child(1),
  #ledgerExpenseTable td:nth-child(1),
  #ledgerExpenseTable th:nth-child(2),
  #ledgerExpenseTable td:nth-child(2),
  #ledgerExpenseTable th:nth-child(3),
  #ledgerExpenseTable td:nth-child(3) {
    width: 35px !important;
    min-width: 35px !important;
  }
  
  /* Колонка "Статус" на мобильных - ширина по содержимому */
  #ledgerExpenseTable th:nth-child(4),
  #ledgerExpenseTable td:nth-child(4) {
    width: 1% !important;
    min-width: auto !important;
    white-space: nowrap !important;
  }
  
  /* Адаптация таблицы участников для мобильных */
  #participantsTable {
    font-size: 11px;
  }
  
  #participantsTable th,
  #participantsTable td {
    padding: 3px 2px;
  }
  
  /* Сужение всех таблиц на мобильных (кроме покупок и продаж) */
  table:not(#buyTable):not(#sellTable) th,
  table:not(#buyTable):not(#sellTable) td {
    padding: 3px 2px !important;
    font-size: 11px !important;
  }
  

  

  
  /* Адаптация калькулятора выгодной покупки для мобильных */
  #profitableBuyCalculator {
    margin: 16px 0 12px 0;
    padding: 12px;
  }
  
  #profitableBuyCalculator .row {
    flex-direction: column;
    gap: 12px;
  }
  
  #profitableBuyCalculator .row > div {
    min-width: auto;
  }
  
  /* Адаптация заголовков разделов для мобильных */
  .income-section h4, .expense-section h4 {
    margin: 6px 0;
    font-size: 14px;
    color: inherit;
    border-bottom: none;
    padding-bottom: 0;
  }
  
  .income-section table,
  .expense-section table {
    margin-top: 8px;
  }
  
  .income-section th,
  .expense-section th {
    background: transparent;
    font-weight: inherit;
    color: inherit;
    font-size: 11px;
  }
  
  .income-section tr,
  .expense-section tr {
    border-bottom: none;
  }
  
  .income-section tr:hover,
  .expense-section tr:hover {
    background: transparent;
  }
  
  /* Адаптация заголовков для мобильных */
  h2 {
    font-size: 18px;
    margin: 16px 0 12px 0;
  }
  
  h3 {
    font-size: 16px;
    margin: 12px 0 8px 0;
  }
  
  /* Адаптация заголовков разделов для мобильных */
  .income-section h4, .expense-section h4 {
    font-size: 14px;
    margin: 8px 0 6px 0;
  }
  
  /* Адаптация заголовков таблиц для мобильных */
  .table-scroll-container {
    margin-top: 8px;
  }
  
  /* Адаптация кнопок для мобильных */
  .btn {
    font-size: 13px;
    padding: 6px 12px;
  }
}
#buyTable td.buyQty {
  min-width: 70px;
  font-size: 15px;
  font-variant-numeric: tabular-nums;
}
#kpdRows .row { display: flex; flex-direction: row !important; gap: 4px; flex-wrap: nowrap !important; align-items: center; margin-bottom: 8px; }
#kpdRows .row > div { flex: 0 0 auto !important; min-width: auto; }
#kpdRows input[type="number"] { width: 88px !important; min-width: 70px; padding: 6px 4px; font-size: 15px; }
#kpdRows .kpdCheck { width: auto; height: auto; margin-right: 2px; margin-left: 0; transform: none; }
#kpdRows .kpdResult { min-width: 70px; font-size: 13px; margin-left: 4px; }
/* Дублируем правила для .kpdRows чтобы внешний вид остался как был при переходе с id на class */
.kpdRows .row { display: flex; flex-direction: row !important; gap: 4px; flex-wrap: nowrap !important; align-items: center; margin-bottom: 8px; }
.kpdRows .row > div { flex: 0 1 auto; min-width: unset; }
.kpdRows input[type="number"] { width: 88px !important; min-width: 70px; padding: 6px 4px; font-size: 15px; }
.kpdRows .kpdCheck { width: auto; height: auto; margin-right: 2px; margin-left: 0; transform: none !important; }
.kpdRows .kpdResult { min-width: 70px; font-size: 13px; margin-left: 4px; }
  /* Компактные строки для Калькулятора Кэфа Расхода */
  #expenseCoefBlock .ecRow { padding: 6px 8px; background: #fffbea; border: 1px solid #f3e0b3; border-radius: 6px; }
  #expenseCoefBlock input[type="number"],
  #expenseCoefBlock input[type="text"] { padding: 8px; font-size: 15px; }
  #expenseCoefBlock .expCoefRatio { font-size: 16px; }
@media (max-width: 600px) {
  #kpdRows .row { flex-direction: row !important; flex-wrap: wrap; gap: 2px; }
  #kpdRows input[type="number"] { width: 60px !important; font-size: 13px; }
  #kpdRows .kpdResult { min-width: 50px; font-size: 12px; }
  .kpdRows .row { flex-direction: row !important; flex-wrap: wrap; gap: 2px; }
  .kpdRows input[type="number"] { width: 60px !important; font-size: 13px; }
  .kpdRows .kpdResult { min-width: 50px; font-size: 12px; }
}
  .burned td { text-decoration: line-through; color:#aaa; }
  /* Широкое поле суммы в доходах */
  .incomeAmountInput { min-width: 80px; max-width: 120px; font-variant-numeric: tabular-nums; text-align: right; }
  .numRight { text-align:right; font-variant-numeric: tabular-nums; }
  /* Карточка коэффициента */
  .coefCard { display:flex; align-items:center; justify-content:space-between; gap:12px; background:#fff8e1; border:1px solid #f3e0b3; border-radius:10px; padding:12px 16px; }
  .coefLabel { color:#7a5f00; font-size:14px; letter-spacing:.2px; }
  .coefValue { color:#7a5f00; font-size:28px; font-weight:700; min-width:72px; text-align:right; font-variant-numeric: tabular-nums; }
  .hidden { display: none !important; }
  /* Modal */
  .modal-backdrop { position: fixed; inset: 0; background: rgba(0,0,0,.35); display: flex; align-items: center; justify-content: center; z-index: 10000; }
  .modal { background:#fff; border-radius:10px; padding:16px; width: min(420px, 92vw); box-shadow: 0 10px 30px rgba(0,0,0,.25); }
  .modal h3 { margin: 0 0 8px 0; font-size: 18px; }
  .modal .row { margin: 8px 0; display:flex; gap:8px; align-items:center; }
  .modal .actions { display:flex; gap:8px; justify-content:flex-end; margin-top: 12px; }
  /* Quick Amount modal overrides */
  #quickAmountModal .modal { width: 100vw !important; max-width: 100vw !important; margin: 0 !important; border-radius: 0; padding: 8px; }
  #quickAmountModal .grid-buttons { display: grid; grid-template-columns: repeat(5, 1fr); gap: 8px; width: 100%; }
  #quickAmountModal .quickAmountBtn { width: 100%; }
  #quickAmountModal .actions .btn { padding: 4px 10px; font-size: 13px; }
  
  /* Красивый крестик очистки полей */
  #clearBuyFieldsIcon:hover {
    background: linear-gradient(135deg, #e9ecef, #dee2e6) !important;
    color: #495057 !important;
    border-color: #adb5bd !important;
    box-shadow: 0 4px 8px rgba(0,0,0,0.15) !important;
    transform: translateY(-1px) !important;
  }
  
  #clearBuyFieldsIcon:active {
    transform: translateY(0) !important;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1) !important;
  }
  @media print {
    nav, #toast, #footerDev, #seedTestBtn, #buyDealsWrap, #buySymbolTpls, #buyPriceTpls, #sellSymbolTpls, #sellPriceTpls { display: none !important; }
    body { background: #fff; }
    section { margin-top: 0; max-height: none; }
  }
  /* Обработка ошибок */
  .error-message {
    background: #ffe6e6;
    border: 1px solid #ffb3b3;
    border-radius: 6px;
    padding: 12px;
    margin: 12px 0;
    color: #c33;
    font-size: 14px;
  }
  .error-message button {
    background: #c33;
    color: white;
    border: none;
    padding: 4px 8px;
    border-radius: 4px;
    margin-left: 8px;
    cursor: pointer;
  }
  
  /* Нижняя панель навигации */
  .bottom-nav {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    background: #fff;
    border-top: 1px solid #ddd;
    display: flex;
    justify-content: space-around;
    padding: 0;
    z-index: 1000;
    box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }
  
  .bottom-nav button {
    background: none;
    border: none;
    padding: 13px 2px;
    font-size: 13px;
    color: #666;
    cursor: pointer;
    transition: all 0.2s;
    text-align: center;
    min-width: 60px;
    line-height: 1.2;
    flex: 1;
  }
  
  .bottom-nav button.active {
    background: #4a90e2;
    color: white;
  }
  
  .bottom-nav button:hover {
    background: #f0f0f0;
  }
  
  .bottom-nav button.active:hover {
    background: #3a80d2;
  }
  
  /* Увеличиваем отступ снизу для контента */
  section {
    padding-bottom: 80px;
  }
  
  /* Верхняя панель с разработчиком */
  .top-dev-bar {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    background: #f8f9fa;
    color: #6c757d;
    text-align: center;
    padding: 8px 0;
    font-size: 12px;
    font-weight: 400;
    z-index: 1001;
    border-bottom: 1px solid #e9ecef;
  }
  
  .top-dev-bar a {
    color: #495057;
    text-decoration: underline;
  }
  
  .top-dev-bar a:hover {
    text-decoration: underline;
    color: #212529;
  }
  
  /* Скрываем верхнее меню на мобильных */
  .desktop-nav {
    display: none !important;
  }
  
  /* Скрываем подпись CashFlow от DimaLead на мобильных */
  #footerDev .desktop-signature {
    display: none;
  }
  
  /* Отступ для контента на мобильных (учитывая верхнюю панель) */
  section {
    margin-top: 0 !important;
  }
  
  /* Стиль для кнопки "Начать ход" на мобильных - в два раза длиннее по высоте */
  #startNextTurnBtn {
    height: 56px !important;
    padding: 16px 16px !important;
    font-size: 16px !important;
    line-height: 1.2 !important;
  }
  
    /* Скрываем на десктопе */
  @media (min-width: 768px) {
    .bottom-nav {
      display: none;
    }
    .top-dev-bar {
      display: none;
    }
    
    /* Показываем подпись CashFlow от DimaLead только на десктопе */
    #footerDev {
      display: block !important;
    }
    
    #footerDev .desktop-signature {
      display: block;
    }
    
    #footerDev .mobile-signature {
      display: none;
    }
    .desktop-nav {
      display: flex !important;
    }
    section {
      padding-bottom: 18px;
      margin-top: 56px !important;
    }
    /* Расширяем область ведомости на десктопе */
    #ledgerBlock {
      max-width: 1200px !important;
      width: 100%;
      margin-left: auto !important;
      margin-right: auto !important;
    }
    
    /* Исправления для десктопа */
    .row {
      gap: 16px;
      margin-bottom: 16px;
    }
    
    .row > div {
      flex: 1 1 200px;
      min-width: 150px;
    }
    
    /* Увеличиваем отступы в таблицах */
    table {
      margin-top: 12px;
      font-size: 13px;
    }
    
    th, td {
      padding: 10px 6px;
      border: 1px solid #ddd;
    }
    
    /* Улучшаем читаемость таблиц */
    #ledgerIncomeTable th,
    #ledgerIncomeTable td,
    #ledgerExpenseTable th,
    #ledgerExpenseTable td {
      padding: 8px 6px;
      font-size: 13px;
      line-height: 1.4;
    }
    
    /* Улучшаем читаемость таблицы прогноза на десктопе */
    #forecastTable th,
    #forecastTable td {
      padding: 6px;
      font-size: 12px;
      line-height: 1.3;
    }
    
    /* Увеличиваем размеры полей ввода */
    input[type=number], input[type=text], select {
      padding: 10px 12px;
      font-size: 14px;
      border: 1px solid #ccc;
      border-radius: 6px;
    }
    
    /* Улучшаем кнопки */
    .btn {
      padding: 10px 20px;
      font-size: 14px;
      border-radius: 6px;
    }
    
    /* Стиль для кнопки "Начать ход" - в два раза длиннее по высоте */
    #startNextTurnBtn {
      height: 56px !important; /* В два раза больше стандартной высоты кнопки */
      padding: 16px 16px !important; /* Увеличиваем вертикальные отступы */
      font-size: 16px !important;
      line-height: 1.2 !important;
    }
    
    /* Увеличиваем отступы между секциями */
    section > div {
      margin-bottom: 24px;
    }
    
    /* Улучшаем отображение сводок */
    #ledgerSummary {
      margin: 16px 0 20px 0;
    }
    
    #ledgerSummaryGrid {
      gap: 16px;
    }
    
    /* Увеличиваем отступы в калькуляторе КПД */
    .kpdBlock {
      margin: 24px 0 16px 0;
      padding: 20px 18px;
    }
    
    .kpdRows .row {
      margin-bottom: 12px;
      gap: 8px;
    }
    
    .kpdRows input[type="number"] {
      width: 100px;
      padding: 8px 6px;
    }
    
    /* Улучшаем разделение секций доходов и расходов */
    .income-section, .expense-section {
      background: #fafafa;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 20px;
    }
    
    .income-section h4, .expense-section h4 {
      margin: 0 0 16px 0;
      font-size: 16px;
      color: #333;
      border-bottom: 2px solid #e0e0e0;
      padding-bottom: 8px;
    }
    
    /* Улучшаем отступы в таблицах */
    .income-section table,
    .expense-section table {
      margin-top: 16px;
      border-collapse: collapse;
      width: 100%;
    }
    
    .income-section th,
    .expense-section th {
      background: #f5f5f5;
      font-weight: 600;
      color: #333;
      font-size: 12px;
    }
    
    /* Увеличиваем отступы между строками */
    .income-section tr,
    .expense-section tr {
      border-bottom: 1px solid #e0e0e0;
    }
    
    .income-section tr:hover,
    .expense-section tr:hover {
      background: #f8f8f8;
    }
    
    /* Улучшаем читаемость таблицы прогноза на десктопе */
    #forecastTable th,
    #forecastTable td {
      padding: 6px;
      font-size: 12px;
      line-height: 1.3;
    }
  }
  
  /* Стили для прокрутки таблиц */
  .table-scroll-container {
    overflow-x: auto;
    max-width: 100%;
    border-radius: 6px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  }
  
  /* Светлая кнопка очистки в прогнозе */
  button[onclick="clearForecastForm()"]:hover {
    background: #e9ecef !important;
    color: #495057 !important;
    border-color: #adb5bd !important;
  }
  
  /* На десктопе убираем прокрутку */
  @media (min-width: 768px) {
    .table-scroll-container {
      overflow-x: visible;
      box-shadow: none;
    }
    
    .table-scroll-container table {
      width: 100%;
    }
    
    /* Убираем прокрутку у всех таблиц на десктопе */
    div[style*="overflow-x:auto"] {
      overflow-x: visible !important;
    }
    
    /* Убираем минимальную ширину у таблиц */
    table {
      min-width: auto !important;
    }
    
    /* На десктопе показываем расходы под доходами (в столбик) */
    .income-section, .expense-section {
      /* Переопределяем инлайновый flex, чтобы блоки были один под другим */
      flex: 0 0 100% !important;
      max-width: 100% !important;
      width: 100% !important;
      margin-bottom: 24px;
      overflow-x: visible;
      box-sizing: border-box;
    }
    
    /* Исправляем наложение таблиц на десктопе */
    .income-section table,
    .expense-section table {
      width: 100%;
      table-layout: fixed;
    }

    /* Запрещаем налезание текста в ячейках, переносим слова */
    .income-section th, .income-section td,
    .expense-section th, .expense-section td {
      word-break: break-word;
      white-space: normal;
    }
    
    /* Убираем горизонтальную прокрутку у контейнеров таблиц на десктопе */
    .income-section .table-scroll-container,
    .expense-section div[style*="overflow-x:auto"] {
      overflow-x: visible;
    }
    
    /* Убираем отступы у контейнеров таблиц на десктопе */
    .income-section .table-scroll-container,
    .expense-section div[style*="overflow-x:auto"] {
      padding: 0;
      margin: 0;
    }
  }
  
  .table-scroll-container::-webkit-scrollbar {
    height: 8px;
  }
  
  .table-scroll-container::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 4px;
  }
  
  .table-scroll-container::-webkit-scrollbar-thumb {
    background: #c1c1c1;
    border-radius: 4px;
  }
  
  .table-scroll-container::-webkit-scrollbar-thumb:hover {
    background: #a8a8a8;
  }
  /* Fullscreen overlay for Easy Text */
  .easy-text-overlay { position: fixed; inset: 0; background: #fff; z-index: 10000; display: none; align-items: center; justify-content: center; padding: 24px; box-sizing: border-box; }
  .easy-text-content { max-width: 90vw; text-align: center; color: #111; font-size: 22px; line-height: 1.5; }
  .easy-text-close { position: absolute; top: 12px; right: 12px; background: #eee; border: 1px solid #ccc; color: #333; border-radius: 6px; padding: 6px 10px; cursor: pointer; }
  /* КПД в покупке — сворачивание */
  .kpd-toggle { background:#f2f2f2; border:1px solid #ddd; color:#666; border-radius:6px; padding:2px 8px; cursor:pointer; font-size:12px; opacity:.7; }
  /* Светло-голубой вариант для кнопок процентов и доверия */
  .kpd-toggle.light-blue,
  .trust-btn.light-blue {
    background: #e6f0ff !important;
    border-color: #b3d6f6 !important;
    color: #225 !important;
  }
  .kpd-collapsible .kpdContent { display:block; }
  .kpd-collapsible.collapsed .kpdContent { display:none; }
  .kpd-collapsible.collapsed .kpd-toggle { opacity:.35; }
  /* Компактное отображение в скрытом состоянии */
  .kpd-collapsible.collapsed {
    padding: 8px 16px !important;
    margin: 12px 0 8px 0 !important;
  }
  .kpd-collapsible.collapsed h3 {
    margin: 0 !important;
    font-size: 16px !important;
  }
  .kpd-toggle:hover { background:#eee; color:#555; }
  /* Ненавязчивая серая кнопка */
  .subtle-btn { background:#f2f2f2; border:1px solid #ddd; color:#666; border-radius:6px; padding:6px 10px; cursor:pointer; font-size:13px; }
  .subtle-btn:hover { background:#ececec; color:#555; }
  /* Узкие поля для Легкой покупки */
  .easy-field { flex: 0 0 140px; min-width: 140px; }
  .easy-input { width: 140px !important; }
  /* Toggle switch */
  .switch { position: relative; display: inline-block; width: 48px; height: 24px; }
  .switch input { opacity: 0; width: 0; height: 0; }
  .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background: #ccc; transition: .2s; border-radius: 24px; }
  .slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 2px; top: 2px; background: #fff; transition: .2s; border-radius: 50%; }
  .switch input:checked + .slider { background: #4a90e2; }
  .switch input:checked + .slider:before { transform: translateX(24px); }
  /* Чтобы автоскролл к результату не перекрывался панелями */
  #easyResult { scroll-margin-top: 72px; scroll-margin-bottom: 92px; }
  /* И для полей ввода Легкой покупки */
  #easySum, #easyPrice { scroll-margin-top: 72px; scroll-margin-bottom: 92px; }
  /* Глобальный круговой таймер */
  .cf-timer-wrap { position: fixed; top: 127px; right: 12px; z-index: 9999; user-select: none; touch-action: none; }
  .cf-timer { position: relative; width: 68px; height: 68px; cursor: pointer; display: block; }
  .cf-timer svg { transform: rotate(-90deg) scaleY(-1); width: 68px; height: 68px; display: block; }
  .cf-timer .ring-bg { stroke: #e5e7eb; stroke-width: 6; fill: none; }
  .cf-timer .ring-fg { stroke: #4a90e2; stroke-width: 6; fill: none; stroke-linecap: round; transition: stroke-dashoffset 0.15s linear; }
  .cf-timer .center-text { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; font-weight: 700; color: #222; font-variant-numeric: tabular-nums; font-size: 16px; }
  .cf-timer.paused .center-text { color: #c33; }
  /* Кнопки таймера */
  .cf-btn { background: #fff; border: 1px solid #ddd; color: #444; width: 28px; height: 28px; border-radius: 50%; display: inline-flex; align-items: center; justify-content: center; cursor: pointer; box-shadow: 0 2px 8px rgba(0,0,0,.1); }
  .cf-btn:hover { background: #f7f7f7; }
  .cf-left-controls { position: absolute; top: 50%; right: 74px; transform: translateY(-50%); display: none; gap: 6px; }
  .cf-timer-wrap.controls-visible .cf-left-controls { display: inline-flex; }
  .cf-timer-wrap.controls-visible .cf-timer-play { display: inline-flex; }
  .cf-btn-pause { color: #225; }
  .cf-btn-reset { color: #c33; }
  .cf-timer-play { position:absolute; inset:0; margin:auto; width:48px; height:48px; display:none; font-size:16px; font-weight:700; background: transparent; border: none; box-shadow: none; outline: none; color:#4a90e2; opacity:.9; }
  .cf-timer.paused ~ .cf-timer-play { opacity:.45; }
  .cf-timer-play:hover { opacity:.95; }
  @media (max-width: 600px) {
    .cf-timer { width: 64px; height: 64px; }
    .cf-timer svg { width: 64px; height: 64px; }
    .cf-timer .center-text { font-size: 15px; }
    .cf-left-controls { right: 70px; }
  }
  /* Чеклист Ходы */
  .moves-list { max-width: 900px; background: #fff; border: 1px solid #e5e7eb; border-radius: 10px; padding: 12px 14px; }
  .move-item { padding: 10px 8px; border-bottom: 1px solid #f0f0f0; }
  .move-item:last-child { border-bottom: none; }
  .move-item.done { opacity: 1; }
  .move-item.dimmed { opacity: 1; }
  .dice-grid { display: grid; grid-template-columns: repeat(6, 1fr); gap: 6px; max-width: 340px; }
  .dice-btn, .card-btn, .yes-btn, .no-btn { padding: 8px 10px; border-radius: 6px; border: 1px solid #ddd; background: #f8f9fb; cursor: pointer; position: relative; }
  .dice-btn.active, .card-btn.active, .yes-btn.active, .no-btn.active { background: #e6f0ff; border-color: #b3d6f6; color: #225; font-weight: 600; }
  .card-btn.recommend { border-style: dashed; border-color: #b3d6f6; box-shadow: 0 0 0 2px rgba(179,214,246,0.25) inset; }
  /* Убрали галочки: класс оставлен, но без эффекта */
  .btn-checkmark::after { content: ''; }
  /* Рекомендованные кнопки (пунктирная синяя обводка) */
  .yes-btn.recommend, .no-btn.recommend, .card-btn.recommend { border-style: dashed; border-color: #b3d6f6; box-shadow: 0 0 0 2px rgba(179,214,246,0.25) inset; }
  .card-btn[disabled], .yes-btn[disabled], .no-btn[disabled] { opacity: .5; cursor: not-allowed; }
  .card-btn.recommend { border-style: dashed; border-color: #b3d6f6; box-shadow: 0 0 0 2px rgba(179,214,246,0.25) inset; }
  .card-grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 8px; }
  .card-btn { padding: 6px 8px; font-size: 13px; }
  .balance-box { margin: 10px 0; padding: 10px; background: #f6fff6; border: 1px solid #cdeccd; border-radius: 8px; color: #222; font-size: 15px; }
  /* Таймер во вкладке Ходы (крупный) */
  .moves-timer-wrap { display:flex; align-items:center; justify-content:center; margin: 8px 0 10px 0; position: relative; }
  
  /* Стили для раскрывающегося поля вступительного текста */
  #introText {
    transition: all 0.3s ease;
    overflow: hidden;
    border: 1px solid #ccc;
    border-radius: 4px;
  }
  
  #introText[data-expanded="true"] {
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    border-color: #4a90e2;
    background-color: #fff;
    height: 350px !important; /* Принудительная высота для 14 строк */
    min-height: 350px !important;
    max-height: none !important;
  }
  
  #introText:focus {
    outline: none;
    border-color: #4a90e2;
  }
  .moves-timer { position: relative; width: 140px; height: 140px; }
  .moves-timer svg { transform: rotate(-90deg) scaleY(-1); width: 140px; height: 140px; display: block; }
  .moves-timer .ring-bg { stroke: #e5e7eb; stroke-width: 10; fill: none; }
  .moves-timer .ring-fg { stroke: #4a90e2; stroke-width: 10; fill: none; stroke-linecap: round; transition: stroke-dashoffset 0.15s linear; }
  .moves-timer .center-text { position: absolute; inset: 0; display:flex; align-items:center; justify-content:center; font-weight: 800; color:#222; font-variant-numeric: tabular-nums; font-size: 28px; }
  .moves-timer-controls { position: absolute; top: 50%; left: calc(50% - 90px - 70px); transform: translateY(-50%); display:flex; gap:8px; }
  .moves-timer-play { position:absolute; inset:0; margin:auto; width:56px; height:56px; display:none; font-size:18px; font-weight:700; background: transparent; border: none; box-shadow: none; outline: none; color:#4a90e2; opacity:.45; }
  .moves-timer-play:hover { opacity:.95; }
  @media (max-width: 600px) { .moves-timer { width: 120px; height: 120px; } .moves-timer svg { width: 120px; height: 120px; } .moves-timer .center-text { font-size: 24px; } .moves-timer-controls { left: calc(50% - 80px - 70px); } }
  /* Трек клеток */
  .board-track { display:grid; grid-template-columns: repeat(12, 20px); gap:4px; padding:24px 0 6px 0; position: relative; }
  .board-cell { width: 20px; height: 20px; border-radius: 4px; background:#f2f2f2; border:1px solid #ddd; display:flex; align-items:center; justify-content:center; font-size:11px; color:#666; position:relative; }
  .board-cell.check { border-color:#f3e0b3; }
  .board-cell.active { outline:2px solid #4a90e2; color:#222; font-weight:700; }
  .board-cell.from { outline:2px dashed #9CA3AF; }
  .board-start { display:inline-flex; align-items:center; justify-content:center; font-size:11px; padding:2px 6px; border-radius:6px; background:#fff; border:1px dashed #9CA3AF; color:#555; height:20px; }
  .board-marker { position:absolute; inset:-2px; display:flex; align-items:center; justify-content:center; font-size:12px; }
  /* Метрики (ЭфКПК, КПК, КПД) — ширина по содержимому, без переноса */
  #ledgerIncomeTable th:nth-child(1),
  #ledgerIncomeTable td:nth-child(1),
  #ledgerIncomeTable th:nth-child(2),
  #ledgerIncomeTable td:nth-child(2),
  #ledgerIncomeTable th:nth-child(3),
  #ledgerIncomeTable td:nth-child(3),
  #ledgerExpenseTable th:nth-child(1),
  #ledgerExpenseTable td:nth-child(1),
  #ledgerExpenseTable th:nth-child(2),
  #ledgerExpenseTable td:nth-child(2),
  #ledgerExpenseTable th:nth-child(3),
  #ledgerExpenseTable td:nth-child(3) {
    white-space: nowrap;
    width: 1%;
  }
  
  /* Колонка "Статус" в таблице расходов — ширина по содержимому */
  #ledgerExpenseTable th:nth-child(4),
  #ledgerExpenseTable td:nth-child(4) {
    white-space: nowrap;
    width: 1%;
  }
  /* Узкие колонки по ширине заголовка для таблиц Доходы/Расходы на вкладке "Главное" */
  .income-section table,
  .expense-section table {
    table-layout: auto !important;
  }
  .income-section th,
  .expense-section th {
    white-space: nowrap !important;
    width: 1%;
  }
  .income-section td,
  .expense-section td {
    white-space: normal;
    word-break: break-word;
  }
  
  /* Модальное окно для завершения хода */
  #finishTurnModal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.7);
    z-index: 10001;
    display: none;
    align-items: center;
    justify-content: center;
  }
  
  #finishTurnModal .modal-content {
    background: white;
    border-radius: 12px;
    padding: 24px;
    max-width: 400px;
    width: 90%;
    text-align: center;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
  }
  
  #finishTurnModal .modal-title {
    font-size: 18px;
    font-weight: 600;
    color: #333;
    margin-bottom: 16px;
  }
  
  #finishTurnModal .modal-message {
    font-size: 16px;
    color: #666;
    margin-bottom: 24px;
    line-height: 1.4;
  }
  
  #finishTurnModal .modal-buttons {
    display: flex;
    gap: 12px;
    justify-content: center;
  }
  
  #finishTurnModal .modal-btn {
    padding: 10px 20px;
    border: none;
    border-radius: 6px;
    font-size: 16px;
    cursor: pointer;
    min-width: 100px;
  }
  
  #finishTurnModal .modal-btn-back {
    background: #f0f0f0;
    color: #333;
  }
  
  #finishTurnModal .modal-btn-back:hover {
    background: #e0e0e0;
  }
  
  #finishTurnModal .modal-btn-finish {
    background: #4a90e2;
    color: white;
  }
  
  #finishTurnModal .modal-btn-finish:hover {
    background: #357abd;
  }
  
  /* Стили для раздела Союз */
  .union-dialog {
    position: relative;
    max-width: 1100px;
    margin-left: auto;
    margin-right: auto;
    padding-left: 5px !important;
    padding-right: 5px !important;
  }
  
  .union-edit-btn {
    position: absolute;
    top: 10px;
    right: 10px;
    background: transparent !important;
    color: #b0b5bb;
    border: none;
    border-radius: 0;
    padding: 1px 4px;
    font-size: 12px;
    line-height: 1;
    cursor: pointer;
    transition: color 0.2s ease;
    box-shadow: none;
    outline: none;
    background-color: transparent !important;
    border-color: transparent !important;
  }
  
  .union-edit-btn:hover { color: #9aa0a6; background: transparent !important; }
  
  .union-text {
    margin: 6px 0;
    line-height: 1.45;
    color: #333;
    width: 100%;
    max-width: 80ch;
    word-wrap: break-word;
    box-sizing: border-box;
    font-size: 15px;
  }
  
  .union-text.bold {
    font-weight: bold;
  }
  
  .union-text.large-bold {
    font-weight: bold;
    font-size: 16px;
  }
  
  .union-text.blue-border {
    border: 1px solid #007bff;
    padding: 8px 5px;
    border-radius: 8px;
    background: #f0f8ff;
    margin: 10px 0;
    max-width: 100%;
    box-sizing: border-box;
  }
  
  .union-text.green-border {
    border: 1px solid #28a745;
    padding: 8px 5px;
    border-radius: 8px;
    background: #f0fff0;
    margin: 10px 0;
    max-width: 100%;
    box-sizing: border-box;
  }
  
  .union-input-group {
    margin: 6px 0;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  
  .union-input {
    padding: 8px 10px;
    border: 1px solid #ccc;
    border-radius: 6px;
    font-size: 14px;
  }
  
  .union-percent {
    color: #666;
    font-size: 14px;
  }
  
  .union-buttons {
    margin: 10px 0 0 0 !important;
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
  }
  
  .union-btn {
    padding: 8px 12px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 14px;
    transition: background-color 0.2s;
  }
  
  .union-btn.primary {
    background: #007bff;
    color: white;
  }
  
  .union-btn.primary:hover {
    background: #0056b3;
  }
  
  .union-btn.success {
    background: #28a745;
    color: white;
  }
  
  .union-btn.success:hover {
    background: #1e7e34;
  }
  
  .union-btn.danger {
    background: #dc3545;
    color: white;
  }
  
  .union-btn.danger:hover {
    background: #c82333;
  }
  
  .union-btn.secondary {
    background: #e6f0ff;
    color: #223355;
    border: 1px solid #b3d6f6;
  }
  
  .union-btn.secondary:hover {
    background: #d8e8ff;
    color: #1e2a50;
  }
  
  .union-btn.selected {
    background: #ffc107 !important;
    color: #000 !important;
    font-weight: bold;
    box-shadow: 0 0 0 2px #ffc107;
  }
  
  .union-btn.disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
  
  .union-signature-area {
    border: 1px dashed #ccc;
    border-radius: 8px;
    padding: 16px;
    text-align: center;
    background: #f8f9fa;
    margin: 0 0 10px 0 !important;
    min-height: 56px;
    cursor: pointer;
  }
  /* Убираем зазор между блоком кнопок и подписью */
  .union-buttons + .union-signature-area { margin-top: 0 !important; }
  .union-buttons + .union-text { margin-top: 0 !important; }
  .union-text + .union-signature-area { margin-top: 0 !important; }
  .union-buttons + .union-input-group { margin-top: 0 !important; }
  
  .union-signature-area:hover {
    border-color: #007bff;
    background: #f0f8ff;
  }
  
  .union-hidden {
    display: none;
  }
  /* Порядок элементов берем из DOM, без принудительного order */
  .union-content { display: flex; flex-direction: column; }
  .union-input-group { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
  .union-signature-area, .union-input-group, .union-status { order: initial; }
  
  /* Убираем подпись "Распишитесь" перед полем подписи и сам зазор */
  .union-text:has(+ .union-signature-area) { display: none !important; }
  .union-text:has(+ .union-signature-area) + .union-signature-area { margin-top: 0 !important; }
  /* Убираем пустой зазор (инлайновые спейсеры высотой 16px) внутри блока Союз */
  .union-dialog div[style*="height: 16px"],
  .union-content div[style*="height: 16px"] {
    display: none !important;
  }
  /* Статус союза рядом с именем */
  .union-status { color:#28a745; font-weight:700; display:inline; margin-left:6px; }
  /* Контейнер Союза: равные и меньшие боковые поля на десктопе */
  #unionSection {
    padding-left: 8px;
    padding-right: 12px;
  }
  
  /* Мобильные стили для полного использования ширины */
  @media (max-width: 768px) {
    section {
      padding: 8px;
      padding-bottom: 80px; /* Добавляем отступ снизу для навигации */
    }
    
    #unionSection {
      padding: 8px !important;
      margin: 8px 0 !important;
    }
    
    .row {
      flex-direction: column;
      gap: 8px;
    }
    
    .row > div {
      width: 100%;
      flex: none;
    }
    
    .union-buttons {
      flex-direction: column;
    }
    
    .union-btn {
      width: 100%;
      margin-bottom: 8px;
    }
    
    table {
      font-size: 12px;
    }
    
    th, td {
      padding: 4px;
    }
    
    /* Стили для союзов на мобильном */
    .union-dialog {
      width: 100% !important;
      max-width: 100% !important;
      margin: 0 !important;
      padding: 8px 8px !important;
    }
    
    .union-text {
      width: 100% !important;
      max-width: 100% !important;
      margin: 8px 0 !important;
      padding: 0 8px !important;
      word-wrap: break-word;
      overflow-wrap: break-word;
      line-height: 1.4 !important;
    }
    
    .union-input-group {
      width: 100% !important;
    }
    
    .union-input {
      width: 100% !important;
      max-width: 100% !important;
    }
  }
  
  .union-edit-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.5);
    z-index: 10000;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  
  .union-edit-content {
    background: white;
    padding: 20px;
    border-radius: 8px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
  }
  
  .union-edit-textarea {
    width: 100%;
    height: 200px;
    padding: 10px;
    border: 1px solid #ccc;
    border-radius: 4px;
    font-family: inherit;
    resize: vertical;
  }
</style>
</head>
<body>
<!-- Модальное окно для завершения хода -->
<div id="finishTurnModal">
  <div class="modal-content">
    <div class="modal-title">Завершение хода</div>
    <div class="modal-message" id="finishTurnMessage">нельзя завершить ход</div>
    <div class="modal-buttons">
      <button class="modal-btn modal-btn-back" id="finishTurnBackBtn">Назад</button>
      <button class="modal-btn modal-btn-finish" id="finishTurnForceBtn">Завершить</button>
    </div>
  </div>
</div>

<!-- Верхняя панель с разработчиком (только на мобильных) -->
<div class="top-dev-bar">
  CashFlow Helper от <a href="https://instagram.com/dimalead" target="_blank">DimaLead</a>
  <span id="sumCoefTop" style="position:absolute; right:10px; top:8px; font-size:12px; color:#6c757d; cursor:pointer; user-select:none;" onclick="toggleFinancialPanel()">Кэф: 0.000</span>
  <span id="balanceTop" style="position:absolute; left:10px; top:8px; font-size:14px; color:#222; font-weight:700;">0 $</span>
</div>

<!-- Всплывающая панель с финансовыми показателями -->
<div id="financialPanel" style="position:fixed; left:10px; top:60px; background:transparent; z-index:1000; display:none; cursor:move; user-select:none; padding:2px;">
  <div style="display:flex; flex-direction:column; gap:2px;">
    <div id="panelPassive" style="font-size:16px; font-weight:bold; color:#efb700; text-align:center; text-shadow:1px 1px 2px rgba(255,255,255,0.8);">0</div>
    <div id="panelIncome" style="font-size:16px; font-weight:bold; color:#19f019; text-align:center; text-shadow:1px 1px 2px rgba(255,255,255,0.8);">0</div>
    <div id="panelExpense" style="font-size:16px; font-weight:bold; color:rgb(204, 51, 51); text-align:center; text-shadow:1px 1px 2px rgba(255,255,255,0.8);">0</div>
    <div id="panelCashflow" style="font-size:16px; font-weight:bold; color:#0d6efd; text-align:center; text-shadow:1px 1px 2px rgba(255,255,255,0.8);">0</div>
  </div>
</div>

<!-- Верхнее меню (только на десктопе) -->
<nav role="tablist" aria-label="Навигация по разделам" class="desktop-nav">
  <button id="tabParticipants" role="tab" aria-controls="participants" aria-selected="true">Главное</button>
  <button id="tabBuy" role="tab" aria-controls="buy" aria-selected="false">Покупка</button>
  <button id="tabSell" role="tab" aria-controls="sell" aria-selected="false">Продажа</button>
  <button id="tabPartners" role="tab" aria-controls="partners" aria-selected="false">Партнеры</button>
  <button id="tabMoves" role="tab" aria-controls="moves" aria-selected="false">Ходы</button>
  <button id="tabHistory" role="tab" aria-controls="history" aria-selected="false">История</button>
  <!-- Баланс для десктопной версии -->
  <span id="balanceTopDesktop" style="position:absolute; right:10px; top:8px; font-size:14px; color:#222; font-weight:700;">0 $</span>
</nav>

<!-- Сообщение об ошибке -->
<div id="errorContainer" class="error-message" style="display: none;">
  <strong>Ошибка загрузки:</strong> <span id="errorText"></span>
  <button onclick="retryLoad()">Повторить</button>
  <button onclick="clearError()">Закрыть</button>
</div>

<!-- Полноэкранное модальное окно для кнопки "Начать Ход" -->
<div id="fullscreenTurnModal">
  <div class="modal-content">
    <!-- Кнопка закрытия -->
    <button id="closeFullscreenModal" style="position:absolute; top:20px; right:20px; background:#ff4444; color:#fff; border:none; border-radius:50%; width:50px; height:50px; font-size:24px; cursor:pointer; display:flex; align-items:center; justify-content:center; box-shadow:0 4px 12px rgba(0,0,0,0.3); transition:all 0.3s ease;" onmouseover="this.style.background='#ff6666'; this.style.transform='scale(1.1)'" onmouseout="this.style.background='#ff4444'; this.style.transform='scale(1)'">×</button>
    
    <!-- Основная кнопка "Начать Ход" -->
    <button id="fullscreenStartTurnBtn" style="width:103.5%; max-width:517px; height:90vh; font-size:48px; font-weight:bold; background:#4a90e2; color:#fff; border:4px solid #2c5aa0; border-radius:30px; cursor:pointer; box-shadow:0 12px 36px rgba(74,144,226,0.5); transition:all 0.3s ease; display:flex; align-items:center; justify-content:center; flex-direction:column; gap:16px;" onmouseover="this.style.background='#357abd'; this.style.transform='translateY(-6px)'; this.style.boxShadow='0 16px 48px rgba(74,144,226,0.7)'" onmouseout="this.style.background='#4a90e2'; this.style.transform='translateY(0)'; this.style.boxShadow='0 12px 36px rgba(74,144,226,0.5)'">
      <div>🎯 НАЧАТЬ ХОД</div>
      <div id="fullscreenTurnNumber" style="font-size:36px; opacity:0.9;"></div>
    </button>
    
    <!-- Дополнительная информация -->
    <div style="margin-top:40px; text-align:center; color:#fff; font-size:18px; opacity:0.8;">
      Нажмите кнопку выше или крестик для закрытия
    </div>
  </div>
</div>

<!-- Нижняя панель навигации (только на мобильных) -->
<div class="bottom-nav">
  <button onclick="setActive('tabParticipants')" data-tab="tabParticipants">Главное</button>
  <button onclick="setActive('tabMoves')" data-tab="tabMoves">Ходы</button>
  <button onclick="setActive('tabBuy')" data-tab="tabBuy">Покупка</button>
  <button onclick="setActive('tabSell')" data-tab="tabSell">Продажа</button>
  <button onclick="setActive('tabPartners')" data-tab="tabPartners">Партнеры</button>
  <button onclick="setActive('tabHistory')" data-tab="tabHistory">История</button>
</div>
<section id="participants" role="tabpanel" aria-labelledby="tabParticipants">
  <h2>Главное</h2>
  
  <!-- Ведомость -->
  <div id="ledgerBlock" style="margin:6px 0 18px 0;padding:0;max-width:980px">
    <h3 style="margin:4px 0 10px 0">Ведомость</h3>
    <div id="ledgerSummary" style="margin:8px 0 12px 0;font-size:15px;color:#224;display:block">
      <div id="sumCoefBox" class="coefCard" style="margin:0 auto 10px auto;max-width:720px;width:100%;box-sizing:border-box">
        <div class="coefLabel">Коэффициент</div>
        <div class="coefValue" id="sumCoef">0</div>
      </div>
      <div id="ledgerSummaryGrid" style="display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,max-content));justify-content:start;gap:10px;max-width:720px;margin:0 auto;">
        <div style="display:inline-flex;flex-direction:column;align-items:flex-start;gap:2px;text-align:left;background:#fefaf2;border:1px solid #f3e0b3;border-radius:6px;padding:6px 10px;font-size:14px;">
          <div>Пассивный доход: <b id="sumPassive">0</b> $</div>
          <div id="sumPassiveExprTop" style="font-size:12px;color:#666"></div>
        </div>
        <div style="display:inline-flex;flex-direction:column;align-items:flex-start;gap:2px;text-align:left;background:#f6fff6;border:1px solid #cdeccd;border-radius:6px;padding:6px 10px;font-size:14px;">
          <div>Общий доход: <b id="sumIncome">0</b> $</div>
          <div id="sumIncomeExprTop" style="font-size:12px;color:#666"></div>
        </div>
        <div style="display:inline-flex;flex-direction:column;align-items:flex-start;gap:2px;text-align:left;background:#fff6f6;border:1px solid #f0cccc;border-radius:6px;padding:6px 10px;font-size:14px;">
          <div>Общий расход: <b id="sumExpense">0</b> $</div>
          <div id="sumExpenseExprTop" style="font-size:12px;color:#666"></div>
        </div>
        <div style="display:inline-flex;align-items:center;white-space:nowrap;text-align:left;background:#f6faff;border:1px solid #d6e6ff;border-radius:6px;padding:6px 10px;font-size:14px;">Ежемес. поток:&nbsp;<b id="sumCashflow">0</b> $</div>
      </div>
      
    </div>
    <!-- Калькулятор КПД (перенесён сюда) -->
    <div id="mainKpdBlock" class="kpdBlock kpd-collapsible" style="margin:16px 0 8px 0;padding:18px 16px;background:#f6faff;border:1px solid #b3d6f6;border-radius:8px;color:#444;max-width:900px">
      <h3 style="margin-top:0;display:flex;align-items:center;justify-content:space-between">Калькулятор КПД <button class="kpd-toggle" id="mainKpdToggle" onclick="toggleMainKPD()">Скрыть</button></h3>
      <div class="kpdRows kpdContent">
        <div class="row" style="max-width:400px;margin-bottom:8px">
          <div><input type="checkbox" class="kpdCheck"></div>
          <div><input class="kpdInvest" type="number" step="0.01" placeholder="Расход"></div>
          <div><input class="kpdPassive" type="number" step="0.01" placeholder="Пассив"></div>
          <div><span class="kpdResult" style="font-size:14px;margin-left:8px;min-width:80px;display:inline-block;"></span></div>
        </div>
        <div class="row" style="max-width:400px;margin-bottom:8px">
          <div><input type="checkbox" class="kpdCheck"></div>
          <div><input class="kpdInvest" type="number" step="0.01" placeholder="Расход"></div>
          <div><input class="kpdPassive" type="number" step="0.01" placeholder="Пассив"></div>
          <div><span class="kpdResult" style="font-size:14px;margin-left:8px;min-width:80px;display:inline-block;"></span></div>
        </div>
        <div class="row" style="max-width:400px;margin-bottom:8px">
          <div><input type="checkbox" class="kpdCheck"></div>
          <div><input class="kpdInvest" type="number" step="0.01" placeholder="Расход"></div>
          <div><input class="kpdPassive" type="number" step="0.01" placeholder="Пассив"></div>
          <div><span class="kpdResult" style="font-size:14px;margin-left:8px;min-width:80px;display:inline-block;"></span></div>
        </div>
        <div class="row" style="max-width:400px;margin-bottom:8px">
          <div><input type="checkbox" class="kpdCheck"></div>
          <div><input class="kpdInvest" type="number" step="0.01" placeholder="Расход"></div>
          <div><input class="kpdPassive" type="number" step="0.01" placeholder="Пассив"></div>
          <div><span class="kpdResult" style="font-size:14px;margin-left:8px;min-width:80px;display:inline-block;"></span></div>
        </div>
        <div class="row" style="max-width:400px;margin-bottom:8px">
          <div><input type="checkbox" class="kpdCheck"></div>
          <div><input class="kpdInvest" type="number" step="0.01" placeholder="Расход"></div>
          <div><input class="kpdPassive" type="number" step="0.01" placeholder="Пассив"></div>
          <div><span class="kpdResult" style="font-size:14px;margin-left:8px;min-width:80px;display:inline-block;"></span></div>
        </div>
      </div>
      <div class="kpdTotal kpdContent" style="font-size:16px;color:#444;margin-top:12px;font-weight:bold;border-top:1px solid #b3d6f6;padding-top:8px"></div>
    </div>
    
    <!-- Калькулятор выгодной покупки -->
    <div id="profitableBuyCalculator" class="kpd-collapsible" style="margin:24px 0 16px 0;padding:18px 16px;background:#f0fff0;border:1px solid #b3f6b3;border-radius:8px;color:#444;max-width:900px">
      <h3 style="margin-top:0;color:#080;display:flex;align-items:center;justify-content:space-between">💰 Калькулятор выгодной покупки <button class="kpd-toggle" id="profBuyToggle" onclick="toggleProfitableBuy()">Скрыть</button></h3>
      <div class="kpdContent" style="font-size:14px;margin-bottom:16px;color:#666"></div>
      
      <div class="kpdContent row" style="margin-bottom:12px">
        <div style="flex:1;min-width:200px">
          <label style="display:block;margin-bottom:4px;font-weight:bold;color:#080">Сумма покупки ($)</label>
          <input id="buyAmount" type="number" step="0.01" placeholder="Например: 10000" style="width:100%" oninput="calculateProfitableBuy()">
        </div>
        <div style="flex:1;min-width:200px">
          <label style="display:block;margin-bottom:4px;font-weight:bold;color:#080">Ежемесячный доход ($)</label>
          <input id="monthlyIncome" type="number" step="0.01" placeholder="Например: 200" style="width:100%" oninput="calculateProfitableBuy()">
        </div>
        <div style="flex:1;min-width:200px">
          <label style="display:block;margin-bottom:4px;font-weight:bold;color:#080">Комиссия партнеру ($)</label>
          <input id="partnerCommission" type="number" step="0.01" placeholder="Например: 500" style="width:100%" oninput="calculateProfitableBuy()">
        </div>
      </div>
      
      <div id="profitableBuyResult" class="kpdContent" style="background:#fff;border:1px solid #b3f6b3;border-radius:6px;padding:16px;margin-top:16px">
        <h4 style="margin-top:0;color:#080">Результаты расчета:</h4>
        <div id="profitableBuyDetails" style="font-size:14px;line-height:1.6;color:#666">
          Введите данные выше для расчета
        </div>
      </div>
    </div>

    <div style="display:flex;gap:14px;flex-wrap:wrap;align-items:flex-start;">
      <div style="flex:1 1 420px;min-width:300px;max-width:50%" class="income-section">
        <h4 style="margin:6px 0">Доходы</h4>
        <div class="row" style="margin-top:8px">
          <div style="flex:0 0 220px">
            <select id="incomeCategory" style="width:100%;padding:8px;border:1px solid #ccc;border-radius:4px">
              <option value="Недвижимость" selected>Недвижимость</option>
              <option value="Бизнес">Бизнес</option>
              <option value="Дивиденды">Дивиденды</option>
              <option value="Зарплата">Зарплата</option>
              <option value="Пенсия">Пенсия</option>
              <option value="Профессия">Профессия</option>
              <option value="Другое">Другое</option>
            </select>
          </div>
          <div id="incomeNameWrap"><input id="incomeName" placeholder="Название"></div>
        </div>

        <div class="row" style="margin-top:0;flex-wrap:nowrap">
          <div id="incomeInvestWrap" style="flex:0 0 150px"><input id="incomeInvest" type="number" step="0.01" placeholder="Инвестировано $" onfocus="clearZeroOnFocus(this)"></div>
          <div style="flex:0 0 150px"><input id="incomeAmount" type="number" step="0.01" placeholder="Ежемесячно $" onfocus="clearZeroOnFocus(this)"></div>
          <div id="incomePriceWrap" style="flex:0 0 150px; display:none"><input id="incomePrice" type="number" step="0.01" placeholder="Цена за шт. $" onfocus="clearZeroOnFocus(this)"></div>
        </div>
        <div class="row" style="margin-top:0">
          <div style="flex:0 0 160px"><button class="btn" onclick="addIncomeRow()">Добавить доход</button></div>
        </div>
        <div class="table-scroll-container">
          <table id="ledgerIncomeTable"></table>
        </div>
        <div id="ledgerIncomeExpr" style="margin-top:8px;font-size:14px;color:#444;"></div>
        <div id="ledgerPassiveExpr" style="margin-top:6px;font-size:14px;color:#444;"></div>
      </div>
      <div style="flex:1 1 420px;min-width:300px;max-width:50%" class="expense-section">
        <h4 style="margin:6px 0">Расходы</h4>
        <div style="overflow-x:auto;max-width:100%;">
          <table id="ledgerExpenseTable"></table>
        </div>
        <div id="ledgerExpenseExpr" style="margin-top:8px;font-size:14px;color:#444;"></div>
        <button class="btn" style="margin-top:8px" onclick="addExpenseRow()">Добавить расход</button>
        <div id="expKpdSummary" style="margin-top:8px;font-size:14px;color:#444"></div>
      </div>
    </div>
  </div>
  
  <!-- Раздел Прогноз -->
  <div id="forecastBlock" style="margin:24px 0 16px 0;padding:18px 16px;background:#f6faff;border:1px solid #b3d6f6;border-radius:8px;color:#444;max-width:1000px">
    <h3 style="margin-top:0;color:#226;font-size:18px">📊 Прогноз Эффективности</h3>
    <div style="font-size:14px;margin-bottom:16px;color:#666"></div>
    
    <!-- Форма ввода для прогноза -->
    <div class="row" style="margin-bottom:16px">
      <div style="flex:0 0 220px">
        <select id="forecastCategory" style="width:100%;padding:8px;border:1px solid #ccc;border-radius:4px">
          <option value="Недвижимость" selected>Недвижимость</option>
          <option value="Бизнес">Бизнес</option>
          <option value="Дивиденды">Дивиденды</option>
          <option value="Другое">Другое</option>
        </select>
      </div>
      <div style="flex:1;min-width:200px">
        <input id="forecastName" placeholder="Название инвестиции" style="width:100%">
      </div>
    </div>
    
    <div class="row" style="margin-bottom:16px">
      <div style="flex:1;min-width:150px">
        <input id="forecastInvest" type="number" step="0.01" placeholder="Инвестировано $" style="width:100%">
      </div>
      <div style="flex:1;min-width:150px">
        <input id="forecastMonthly" type="number" step="0.01" placeholder="Ежемес за шт." style="width:100%">
      </div>
      <div style="flex:1;min-width:150px;display:none" id="forecastPriceWrap">
        <input id="forecastPrice" type="number" step="0.01" placeholder="Цена за шт." style="width:100%">
      </div>
      <div style="flex:0 0 auto; display:flex; align-items:center; gap:8px; margin-bottom:8px;">
        <button class="btn" onclick="addForecastRow()" style="background:#4a90e2; color:#fff; border:1px solid #4a90e2; padding:8px 16px; border-radius:4px; cursor:pointer; font-size:16px;">Добавить</button>
        <button class="btn" onclick="clearForecastForm()" style="background:#f8f9fa; color:#666; border:1px solid #dee2e6; padding:8px 16px; border-radius:4px; cursor:pointer; font-size:16px;">Очистить</button>
      </div>
      <div style="margin-top:8px; min-height:20px; border:1px solid #e0e0e0; padding:8px; background:#f9f9f9; border-radius:4px;">
        <span id="forecastTopRank" style="color:#6d28d9; font-weight:600; display:block; text-align:left; min-width:120px; font-size:14px; line-height:1.4;">Тест: нажмите "Добавить" или введите данные</span>
      </div>
    </div>
    
    <!-- Таблица прогноза -->
    <div class="table-scroll-container">
      <table id="forecastTable" style="border-collapse:collapse;width:100%;margin-top:8px;font-size:12px;table-layout:fixed">
        <thead>
          <tr>
            <th style="padding:4px 6px;text-align:center;font-size:11px;">✔</th>
            <th style="padding:4px 6px;text-align:center;font-size:11px;">ЭфКПК</th>
            <th style="padding:4px 6px;text-align:center;font-size:11px;">КПК</th>
            <th style="padding:4px 6px;text-align:center;font-size:11px;">КПД</th>
            <th style="padding:4px 6px;text-align:center;font-size:11px;">Название</th>
            <th style="padding:4px 6px;text-align:center;font-size:11px;">Сумма</th>
            <th style="padding:4px 6px;text-align:center;font-size:11px;">Ежемесячно</th>
            <th style="padding:4px 6px;text-align:center;font-size:11px;">Категория</th>
            <th style="padding:4px 6px;text-align:center;font-size:11px;">Тип</th>
            <th style="padding:4px 6px;text-align:center;font-size:11px;">Ежемес<br>за шт.</th>
            <th style="padding:4px 6px;text-align:center;font-size:11px;">Штук</th>
            <th style="padding:4px 6px;text-align:center;font-size:11px;">Цена за шт.</th>
            <th style="padding:4px 6px;text-align:center;font-size:11px;">Действия</th>
          </tr>
        </thead>
        <tbody id="forecastTableBody">
          <!-- Строки будут добавляться динамически -->
        </tbody>
      </table>
    </div>
    <div id="forecastToggleWrap" style="margin-top:8px;display:flex;align-items:center;gap:8px;">
      <span style="font-size:13px;color:#666">Скрыть примеры</span>
      <label class="switch">
        <input id="forecastHideExamples" type="checkbox">
        <span class="slider"></span>
      </label>
    </div>
    <div id="forecastSummary" style="margin-top:10px;font-size:14px;color:#444"></div>
    

    
    <!-- Оптимизатор покупки по сумме -->
    <div id="optimizerBlock" style="margin:16px 0 0 0;padding:12px 0 0 0;max-width:900px;text-align:center">
      <h4 style="margin:0 0 10px 0;color:#6d28d9;text-align:center">🧮 Оптимизатор по сумме</h4>
      <div class="row" style="margin:0 0 10px 0;justify-content:center;align-items:flex-end;gap:8px">
        <div style="flex:1;min-width:220px;max-width:360px">
          <label for="optBudget" style="display:block;margin-bottom:4px;font-weight:600;color:#080;text-align:center">Сумма для оптимизации ($)</label>
          <input id="optBudget" type="text" inputmode="text" placeholder="Например: 10000 или 10000+2400" style="width:100%">
        </div>
        <div style="flex:0 0 auto">
          <button class="btn" onclick="runOptimization()" title="Рассчитать по сумме">Посчитать</button>
        </div>
      </div>

      <div id="optResult" style="font-size:14px;color:#444;text-align:center"></div>
    </div>
  </div>
  
  <!-- Easy Text Fullscreen Overlay -->
  <div id="easyTextOverlay" class="easy-text-overlay" aria-hidden="true">
    <div class="easy-text-content" id="easyTextContent"></div>
    <button class="easy-text-close" onclick="closeEasyText()">✖</button>
  </div>
  <div id="investStats" style="max-width:720px;margin:12px auto 8px auto;display:block;">
    <div id="investStatsCombined" style="background:#f6faff;border:1px solid #d6e6ff;border-radius:6px;padding:8px 10px;font-size:14px;line-height:1.5;">
      Инвестировано всего: <b id="sumInvestTotal">0</b><br>
      (<span class="nowrapLabel">Доходы <b id="sumInvestIncome">0</b></span> + <span class="nowrapLabel">Погашение <b id="sumInvestExpense">0</b></span>)
    </div>
  </div>
  <!-- Казино -->
  <div id="casinoBlock" style="margin:16px 0;padding:16px;background:#fffef7;border:1px solid #f3e0b3;border-radius:8px;color:#444;max-width:900px">
    <h3 style="margin:0 0 8px 0">Казино</h3>
    <div style="font-size:14px;margin-bottom:8px;color:#666">Введите сумму ставки и коэффициент. Кнопки — быстрый выбор коэффициента.</div>
    <div class="row" style="margin:8px 0 6px 0;gap:8px;align-items:flex-end;flex-wrap:wrap">
      <div style="flex:1;min-width:180px">
        <label style="display:block;margin-bottom:4px;font-weight:600;color:#555">Сумма ставки ($)</label>
        <input id="casinoBet" type="number" step="0.01" inputmode="decimal" placeholder="Например: 1000" oninput="updateCasino()">
      </div>
      <div style="flex:1;min-width:180px">
        <label style="display:block;margin-bottom:4px;font-weight:600;color:#555">Коэффициент</label>
        <div style="display:flex;flex-direction:column;gap:6px">
          <div style="display:flex;gap:6px;flex-wrap:wrap">
            <button class="subtle-btn" onclick="setCasinoCoef(1)">1</button>
            <button class="subtle-btn" onclick="setCasinoCoef(2)">2</button>
            <button class="subtle-btn" onclick="setCasinoCoef(3)">3</button>
            <button class="subtle-btn" onclick="setCasinoCoef(4)">4</button>
            <button class="subtle-btn" onclick="setCasinoCoef(5)">5</button>
            <button class="subtle-btn" onclick="setCasinoCoef(6)">6</button>
            <button class="subtle-btn" onclick="setCasinoCoef(2.5)">2.5</button>
          </div>
          <input id="casinoCoef" type="number" step="0.01" inputmode="decimal" placeholder="Например: 3" oninput="updateCasino()">
        </div>
      </div>
    </div>
    <div id="casinoResult" style="font-size:16px;color:#226;margin:6px 0 8px 0"></div>
    <div class="row" style="margin-top:0;gap:8px;align-items:center;flex-wrap:wrap">
      <div style="flex:0 0 200px;min-width:180px"><input id="casinoTakeAmount" type="number" step="0.01" inputmode="decimal" placeholder="Сумму забрал $"></div>
      <div style="flex:0 0 auto"><button class="btn" onclick="casinoTake(); document.getElementById('casinoTakeAmount').value=''">Сумму забрал</button></div>
      <div style="flex:0 0 auto"><button class="btn" style="background:#eee;color:#444;border:1px solid #ccc" onclick="clearCasino()">Очистить</button></div>
    </div>
  </div>
  <!-- Калькулятор Кэфа Расхода -->
  <div id="expenseCoefBlock" class="kpdBlock" style="margin:24px 0 16px 0;padding:18px 16px;background:#fff8e1;border:1px solid #f3e0b3;border-radius:8px;color:#444;max-width:900px">
    <h3 style="margin-top:0">Калькулятор Кэфа Доходов</h3>
    <div class="kpdRows" id="expenseCoefRows"></div>
    <div class="kpdTotal" id="expenseCoefSummary" style="font-size:16px;color:#7a5f00;margin-top:12px;font-weight:bold;border-top:1px solid #f3e0b3;padding-top:8px"></div>
  </div>
  <!-- Участники -->
  <h3 style="margin:24px 0 8px 0">Участники</h3>
  <div class="row">
    <div><input id="newParticipant" placeholder="Имя участника" onfocus="clearZeroOnFocus(this)"></div>
    <div style="flex:0 0 120px"><button class="btn" onclick="addParticipant()">Добавить</button></div>
  </div>
  <div class="row" style="align-items:center">
    <div style="flex:0 0 240px">
      <label for="ownerSelect" style="font-size:14px;color:#555">Владелец</label>
      <select id="ownerSelect" style="width:100%;padding:8px;border:1px solid #ccc;border-radius:4px"></select>
    </div>
  </div>
  <table id="participantsTable"></table>
  
  <!-- Деньги партнеру -->
  <h3 style="margin:16px 0 6px 0">Деньги партнёру</h3>
  <div class="row partner-money" style="gap:8px;margin-top:4px;flex-direction:column;align-items:stretch">
    <div style="width:100%">
      <select id="partnerPayName" style="width:100%;padding:8px;border:1px solid #ccc;border-radius:4px">
        <option value="">— выбрать —</option>
      </select>
    </div>
    <div style="width:100%"><input id="partnerPaySum" type="number" step="0.01" placeholder="Сумма $" onfocus="clearZeroOnFocus(this)" style="width:100%;padding:8px;border:1px solid #ccc;border-radius:4px"></div>
    <div style="width:100%"><button class="btn" onclick="givePartnerMoney()" style="width:100%">Отдать</button></div>
  </div>
  
  <!-- Раздел Союз -->
  <div id="unionSection" style="margin:16px 0;padding:8px;max-width:100%">
    <h3 style="margin:0 0 16px 0;color:#333;display:flex;align-items:center;justify-content:space-between">
      Союз
      <div style="display:flex;gap:8px;align-items:center;">
        <button id="editUnionBtn" class="btn" onclick="editAllUnions()" title="Редактировать союзы" style="background:#007bff;padding:8px 16px;font-size:16px;border-radius:50%;width:36px;height:36px;display:flex;align-items:center;justify-content:center">✏️</button>
        <button id="viewHistoryBtn" class="btn" onclick="viewUnionHistory()" title="Просмотр истории союзов" style="background:#6c757d;padding:8px 16px;font-size:16px;border-radius:50%;width:36px;height:36px;display:flex;align-items:center;justify-content:center">📋</button>
        <button id="addUnionBtn" class="btn" onclick="addUnion()" style="background:#28a745;padding:8px 16px;font-size:18px;border-radius:50%;width:40px;height:40px;display:flex;align-items:center;justify-content:center">+</button>
      </div>
    </h3>
    
    <!-- Контейнер для союзов -->
    <div id="unionsContainer"></div>
    
    <!-- Шаблон диалога союза (скрыт) -->
    <div id="unionDialogTemplate" style="display:none;">
      <div class="union-dialog" style="margin:16px 0;padding:20px;">
        <div class="union-content">
          <!-- Содержимое диалога будет добавляться динамически -->
        </div>
      </div>
    </div>
  </div>

  

</section>
<script>
// Фикс порядка элементов в блоках Союза: [подпись] → [имя] → [статус]
(function(){
  function insertAfter(parent, node, after){
    if (!parent || !node) return;
    if (after && after.parentNode === parent) {
      if (after.nextSibling) parent.insertBefore(node, after.nextSibling); else parent.appendChild(node);
    } else {
      parent.appendChild(node);
    }
  }
  function fixUnionLayoutOnce(dialog){
    try{
      if (!dialog) return;
      const content = dialog.querySelector('.union-content') || dialog;
      const signature = dialog.querySelector('.union-signature-area');
      // Группа с именем или само поле имени (readonly)
      let inputGrp = dialog.querySelector('.union-input-group');
      if (!inputGrp) {
        inputGrp = dialog.querySelector('input.union-input[readonly]') || dialog.querySelector('input[id^="playerNameReadonly-"]');
      }
      const status = dialog.querySelector('.union-status');
      // Подпись «Подпись зафиксирована»
      const fixedNote = Array.from(dialog.querySelectorAll('.union-text'))
        .find(el => (el.textContent||'').trim().toLowerCase().includes('подпись зафиксирована')) || null;
      // Скрываем текстовую подпись "Распишитесь"
      try{
        const labels = dialog.querySelectorAll('.union-text');
        labels.forEach(el=>{ if ((el.textContent||'').trim().toLowerCase().includes('распишитесь')) el.style.display='none'; });
      }catch{}
      if (!content || !inputGrp) return;
      if (signature) {
        try{ if (signature.parentNode !== content || signature.nextSibling !== inputGrp) content.insertBefore(signature, inputGrp); }catch{}
      }
      if (status) {
        try{
          if (fixedNote) {
            if (status.previousSibling !== fixedNote) { content.removeChild(status); insertAfter(content, status, fixedNote); }
          } else if (inputGrp) {
            if (status.previousSibling !== inputGrp) { content.removeChild(status); insertAfter(content, status, inputGrp); }
          }
        }catch{}
      }
    }catch{}
  }
  function fixAll(){
    try{ document.querySelectorAll('.union-dialog').forEach(fixUnionLayoutOnce); }catch{}
  }
  // Первичный вызов
  setTimeout(fixAll, 0);
  // Наблюдатель за изменениями внутри контейнера союзов
  try{
    const host = document.getElementById('unionsContainer') || document;
    const mo = new MutationObserver(()=>{ fixAll(); });
    mo.observe(host, { childList:true, subtree:true });
  }catch{}
})();
</script>
<section id="buy" role="tabpanel" aria-labelledby="tabBuy" hidden>
  <h2>Покупка акций</h2>
  <div class="row" style="align-items:flex-end">
    <div style="flex:2"><input id="buySymbol" placeholder="Название акции"></div>
    <div style="flex:2"><input id="buyPrice" type="number" step="0.01" placeholder="Курс" onfocus="clearZeroOnFocus(this)"></div>
  </div>
  <div class="row" style="align-items:center;gap:12px;margin-top:4px">
    <label style="display:inline-flex;align-items:center;gap:10px;font-size:14px;color:#444">
      <span>Авто ×1000 для сумм</span>
      <label class="switch">
        <input id="buyAuto000" type="checkbox">
        <span class="slider"></span>
      </label>
    </label>
  </div>
  <table id="buyTable"></table>
  <div id="buySummary" class="small"></div>
  <div class="row" style="align-items:center;gap:8px;margin-top:6px">
    <div style="flex:0 0 auto">
      <input id="buyTurnInput" placeholder="Ход" style="width:90px;padding:6px 8px;font-size:14px" onfocus="clearZeroOnFocus(this)">
    </div>
    <div style="flex:0 0 auto;display:flex;align-items:center;gap:8px;">
      <button class="btn" onclick="saveBuy()">Сохранить сделку</button>
      <button class="actBtn" id="clearBuyFieldsIcon" title="Очистить все поля" onclick="clearBuyFields()" style="background:linear-gradient(135deg, #f8f9fa, #e9ecef);color:#6c757d;border:1px solid #dee2e6;padding:6px 10px;font-size:16px;border-radius:6px;box-shadow:0 2px 4px rgba(0,0,0,0.1);transition:all 0.2s ease;cursor:pointer;min-width:32px;height:32px;display:flex;align-items:center;justify-content:center;">✖</button>
    </div>
  </div>

  <div id="buyDealsWrap"></div>
  
  <div style="margin:32px 0 0 0;padding:18px 16px 18px 16px;background:#f6fff6;border:1px solid #b3f6b3;border-radius:8px;color:#444;max-width:900px">
    <h3 style="margin-top:0;display:flex;align-items:center;justify-content:space-between">Легкая покупка <button class="actBtn" id="easyClearBtn" title="Очистить поля" onclick="clearEasyBuy()">✖</button></h3>
    <div id="easySummaryTop" style="font-size:16px;color:#226;margin:6px 0 24px 0"></div>
    <div class="row" style="max-width:400px;margin-top:4px;display:grid;grid-template-columns:repeat(2,1fr);gap:12px;align-items:flex-start">
      <div class="easy-field" style="display:flex;flex-direction:column">
        <label style="display:block;font-size:13px;color:#666;margin-bottom:4px">Сумма $</label>
        <input id="easySum" type="number" step="0.01" placeholder="Сумма $" onfocus="clearZeroOnFocus(this)" class="easy-input">
      </div>
      <div class="easy-field" style="display:flex;flex-direction:column">
        <label style="display:block;font-size:13px;color:#666;margin-bottom:4px">Цена акции</label>
        <input id="easyPrice" type="number" step="0.01" placeholder="Цена акции" onfocus="clearZeroOnFocus(this)" class="easy-input">
      </div>
    </div>
    <div class="row" style="max-width:400px;margin-top:8px;display:grid;grid-template-columns:repeat(2,1fr);gap:12px;align-items:flex-start">
      <div class="easy-field" style="display:flex;flex-direction:column">
        <label style="display:block;font-size:13px;color:#666;margin-bottom:4px">Из них мои</label>
        <input id="easyMySum" type="number" step="0.01" placeholder="Из них мои" oninput="updateEasyBuyMy()" onfocus="clearZeroOnFocus(this)" class="easy-input">
      </div>
      <div class="easy-field" style="display:flex;flex-direction:column">
        <label style="display:block;font-size:13px;color:#666;margin-bottom:4px">Ком %</label>
        <input id="easyCommission" type="number" step="0.01" min="0" max="20" value="0" placeholder="0" oninput="updateEasyBuyMy()" onfocus="clearZeroOnFocus(this)" class="easy-input">
      </div>
    </div>
    <div style="margin-top:8px"><button class="subtle-btn" id="easyToggleTextBtn" onclick="toggleEasyText()">Показать текст</button></div>
    <div id="easyBottomWrap" style="display:none">
      <div id="easySummaryBottom" style="font-size:16px;color:#226;margin-top:320px;margin-bottom:320px"></div>
    </div>
  </div>
  <div id="buyKpdBlock" class="kpdBlock kpd-collapsible" style="margin:24px 0 0 0;padding:18px 16px 18px 16px;background:#f6faff;border:1px solid #b3d6f6;border-radius:8px;color:#444;max-width:900px">
    <h3 style="margin-top:0;display:flex;align-items:center;justify-content:space-between">Калькулятор КПД <button class="kpd-toggle" id="buyKpdToggle" onclick="toggleBuyKPD()">Скрыть</button></h3>
    <div class="kpdRows kpdContent">
      <div class="row" style="max-width:400px;margin-bottom:8px">
        <div><input type="checkbox" class="kpdCheck"></div>
        <div><input class="kpdInvest" type="number" step="0.01" placeholder="Расход" onfocus="clearZeroOnFocus(this)"></div>
        <div><input class="kpdPassive" type="number" step="0.01" placeholder="Пассив" onfocus="clearZeroOnFocus(this)"></div>
        <div><span class="kpdResult" style="font-size:14px;margin-left:8px;min-width:80px;display:inline-block;"></span></div>
      </div>
      <div class="row" style="max-width:400px;margin-bottom:8px">
        <div><input type="checkbox" class="kpdCheck"></div>
        <div><input class="kpdInvest" type="number" step="0.01" placeholder="Расход" onfocus="clearZeroOnFocus(this)"></div>
        <div><input class="kpdPassive" type="number" step="0.01" placeholder="Пассив" onfocus="clearZeroOnFocus(this)"></div>
        <div><span class="kpdResult" style="font-size:14px;margin-left:8px;min-width:80px;display:inline-block;"></span></div>
      </div>
      <div class="row" style="max-width:400px;margin-bottom:8px">
        <div><input type="checkbox" class="kpdCheck"></div>
        <div><input class="kpdInvest" type="number" step="0.01" placeholder="Расход" onfocus="clearZeroOnFocus(this)"></div>
        <div><input class="kpdPassive" type="number" step="0.01" placeholder="Пассив" onfocus="clearZeroOnFocus(this)"></div>
        <div><span class="kpdResult" style="font-size:14px;margin-left:8px;min-width:80px;display:inline-block;"></span></div>
      </div>
      <div class="row" style="max-width:400px;margin-bottom:8px">
        <div><input type="checkbox" class="kpdCheck"></div>
        <div><input class="kpdInvest" type="number" step="0.01" placeholder="Расход" onfocus="clearZeroOnFocus(this)"></div>
        <div><input class="kpdPassive" type="number" step="0.01" placeholder="Пассив" onfocus="clearZeroOnFocus(this)"></div>
        <div><span class="kpdResult" style="font-size:14px;margin-left:8px;min-width:80px;display:inline-block;"></span></div>
      </div>
      <div class="row" style="max-width:400px;margin-bottom:8px">
        <div><input type="checkbox" class="kpdCheck"></div>
        <div><input class="kpdInvest" type="number" step="0.01" placeholder="Расход" onfocus="clearZeroOnFocus(this)"></div>
        <div><input class="kpdPassive" type="number" step="0.01" placeholder="Пассив" onfocus="clearZeroOnFocus(this)"></div>
        <div><span class="kpdResult" style="font-size:14px;margin-left:8px;min-width:80px;display:inline-block;"></span></div>
      </div>
    </div>
    <div class="kpdTotal" style="font-size:16px;color:#444;margin-top:12px;font-weight:bold;border-top:1px solid #b3d6f6;padding-top:8px"></div>
  </div>
</section>
<section id="sell" role="tabpanel" aria-labelledby="tabSell" hidden>
  <h2>Продажа акций</h2>
  <table id="sellTable"></table>
  <div id="sellSummary" class="small"></div>
</section>
<section id="partners" role="tabpanel" aria-labelledby="tabPartners" hidden>
  <div id="partnersContent"></div>
</section>
<section id="history" role="tabpanel" aria-labelledby="tabHistory" hidden>
  <h2>История операций</h2>
  <div style="margin-bottom:16px;display:flex;gap:12px;flex-wrap:wrap;">
    <button class="btn" onclick="exportAppData()">Экспорт данных</button>
    <button class="btn" onclick="importAppData()">Импорт данных</button>
        <button class="btn" onclick="exportTurnsHistory()">Экспорт истории ходов</button>
        <button class="btn" onclick="importTurnsHistory()">Импорт истории ходов</button>
    <button class="btn" onclick="undoAction()">Отменить действие</button>
    <button class="btn" onclick="redoAction()">Вернуть действие</button>
    <button class="btn" onclick="exportErrors()" style="background:#f59e0b">Экспорт ошибок</button>
    <button class="btn" onclick="clearErrorHistory()" style="background:#f87171">Очистить ошибки</button>
    <button class="btn" onclick="seedTestBtnClick()" style="background:#4a90e2">Тест 1</button>
    <button class="btn" onclick="seedTestBtn2Click()" style="background:#6c757d">Тест 2</button>
    <button class="btn" onclick="testDoubleCashflow()" style="background:#dc2626">Тест двойного потока</button>
    <button class="btn" onclick="resetAll()" style="background:#c33">Удалить всё</button>
    <button class="btn" onclick="clearOldHistory()" style="background:#dc2626">Очистить старую историю</button>
    <input type="file" id="importFileInput" style="display:none" accept="application/json">
    <input id="historySearch" placeholder="Поиск..." style="flex:1;min-width:160px;padding:8px;border:1px solid #ccc;border-radius:4px" onfocus="clearZeroOnFocus(this)">
  </div>
  <div id="alarmButtonsRow" style="margin:8px 0;display:flex;gap:4px;flex-wrap:wrap;">
       <button class="btn" onclick="testSound1()" style="background:#f59e0b;padding:4px 8px;font-size:12px;">Тревога 1</button>
       <button class="btn" onclick="testSound2()" style="background:#f97316;padding:4px 8px;font-size:12px;">Тревога 2</button>
       <button class="btn" onclick="testBeep()" style="background:#8b5cf6;padding:4px 8px;font-size:12px;">Тревога 3</button>
       <button class="btn" onclick="testSound4()" style="background:#06b6d4;padding:4px 8px;font-size:12px;">Тревога 4</button>
       <button class="btn" onclick="testSound5()" style="background:#84cc16;padding:4px 8px;font-size:12px;">Тревога 5</button>
       <button class="btn" onclick="testSound6()" style="background:#f97316;padding:4px 8px;font-size:12px;">Тревога 6</button>
       <button class="btn" onclick="testSound7()" style="background:#ec4899;padding:4px 8px;font-size:12px;">Тревога 7</button>
       <button class="btn" onclick="testSound8()" style="background:#6366f1;padding:4px 8px;font-size:12px;">Тревога 8</button>
       <button class="btn" onclick="testSound9()" style="background:#14b8a6;padding:4px 8px;font-size:12px;">Тревога 9</button>
       <button class="btn" onclick="testSound10()" style="background:#f43f5e;padding:4px 8px;font-size:12px;">Тревога 10</button>
     </div>
    
  <!-- Постоянные кнопки настройки звука таймера -->
  <div id="timerSoundsHolder" data-static="true" data-protected="true" style="margin:10px 0 0 0;padding:10px;background:#fff;border:1px solid #e5e7eb;border-radius:8px;max-width:1000px;">
    <div style="display:flex;flex-wrap:wrap;gap:12px;align-items:flex-end">
      <div style="display:flex;align-items:center;gap:6px">
        <label style="font-size:13px;color:#666">Старт</label>
        <select id="timerStartSound" data-protected="true" style="padding:4px 6px;font-size:13px">
          <option value="playBong">Гонг</option>
          <option value="playBeep">Бип</option>
          <option value="playSound1">Тревога 1</option>
          <option value="playSound2">Тревога 2</option>
          <option value="playSound3">Тревога 3</option>
          <option value="playSound4">Тревога 4</option>
          <option value="playSound5">Тревога 5</option>
          <option value="playSound6">Тревога 6</option>
          <option value="playSound7">Тревога 7</option>
          <option value="playSound8">Тревога 8</option>
          <option value="playSound9">Тревога 9</option>
          <option value="playSound10">Тревога 10</option>
        </select>
        <button class="btn" id="testStartBtn_global" data-protected="true" style="padding:4px 8px;font-size:13px">Тест старт</button>
      </div>
      <div style="display:flex;align-items:center;gap:6px">
        <label style="font-size:13px;color:#666">15 сек</label>
        <select id="timer15Sound" data-protected="true" style="padding:4px 6px;font-size:13px">
          <option value="playBong">Гонг</option>
          <option value="playBeep">Бип</option>
          <option value="playSound1">Тревога 1</option>
          <option value="playSound2">Тревога 2</option>
          <option value="playSound3">Тревога 3</option>
          <option value="playSound4">Тревога 4</option>
          <option value="playSound5">Тревога 5</option>
          <option value="playSound6">Тревога 6</option>
          <option value="playSound7">Тревога 7</option>
          <option value="playSound8">Тревога 8</option>
          <option value="playSound9">Тревога 9</option>
          <option value="playSound10">Тревога 10</option>
        </select>
        <button class="btn" id="test15Btn_global" data-protected="true" style="padding:4px 8px;font-size:13px">Тест 15с</button>
      </div>
      <div style="display:flex;align-items:center;gap:6px">
        <label style="font-size:13px;color:#666">7 сек</label>
        <select id="timer7Sound" data-protected="true" style="padding:4px 6px;font-size:13px">
          <option value="playBong">Гонг</option>
          <option value="playBeep">Бип</option>
          <option value="playSound1">Тревога 1</option>
          <option value="playSound2">Тревога 2</option>
          <option value="playSound3">Тревога 3</option>
          <option value="playSound4">Тревога 4</option>
          <option value="playSound5">Тревога 5</option>
          <option value="playSound6">Тревога 6</option>
          <option value="playSound7">Тревога 7</option>
          <option value="playSound8">Тревога 8</option>
          <option value="playSound9">Тревога 9</option>
          <option value="playSound10">Тревога 10</option>
        </select>
        <button class="btn" id="test7Btn_global" data-protected="true" style="padding:4px 8px;font-size:13px">Тест 7с</button>
      </div>
      <div style="display:flex;align-items:center;gap:6px">
        <label style="font-size:13px;color:#666">3 сек</label>
        <select id="timer3Sound" data-protected="true" style="padding:4px 6px;font-size:13px">
          <option value="playBong">Гонг</option>
          <option value="playBeep">Бип</option>
          <option value="playSound1">Тревога 1</option>
          <option value="playSound2">Тревога 2</option>
          <option value="playSound3">Тревога 3</option>
          <option value="playSound4">Тревога 4</option>
          <option value="playSound5">Тревога 5</option>
          <option value="playSound6">Тревога 6</option>
          <option value="playSound7">Тревога 7</option>
          <option value="playSound8">Тревога 8</option>
          <option value="playSound9">Тревога 9</option>
          <option value="playSound10">Тревога 10</option>
        </select>
        <button class="btn" id="test3Btn_global" data-protected="true" style="padding:4px 8px;font-size:13px">Тест 3с</button>
      </div>
      <div>
        <button class="btn" id="timerSoundsSaveBtn_global" data-protected="true" style="padding:4px 10px;font-size:13px">Сохранить</button>
      </div>
    </div>
  </div>
  <h3 style="margin:24px 0 8px 0">График по ходам</h3>
  <canvas id="balanceChart" height="220" style="max-width:900px;width:100%;height:220px;background:#fff;border:1px solid #eee;border-radius:8px;display:block;margin:0 auto 8px auto"></canvas>
  <div id="balanceChartEmpty" style="text-align:center;color:#888;margin:6px 0 14px 0;display:none">Нет данных для графика</div>
  <h3 style="margin:24px 0 8px 0">История операций</h3>
  <div style="margin-bottom:16px;padding:12px;background:#f0f8ff;border:1px solid #b3d6f6;border-radius:6px;color:#226;font-size:14px;">
    <strong>ℹ️ Важно:</strong> Все операции теперь автоматически записываются в историю ходов. 
    Старая история операций сохранена для обратной совместимости, но может быть очищена.
  </div>
  <div id="historyList" style="max-width:700px;margin:0 auto 24px auto;padding:8px 0;"></div>
  <h3 style="margin:24px 0 8px 0">История ходов</h3>
  <div id="turnsHistoryList" style="max-width:700px;margin:0 auto 24px auto;padding:8px 0;"></div>
  <h3 style="margin:24px 0 8px 0">История ошибок</h3>
  <div id="errorHistoryList" style="max-width:700px;margin:0 auto 24px auto;padding:8px 0;"></div>
</section>
<section id="moves" role="tabpanel" aria-labelledby="tabMoves" hidden>
  <div id="movesHeader" style="margin:20px 0 12px 0;font-size:16px;color:#333;font-weight:600">Ход <span id="turnNumber">1</span></div>
  <div class="moves-timer-wrap">
    <div class="moves-timer" id="movesTimer">
      <svg viewBox="0 0 100 100" aria-hidden="true">
        <circle class="ring-bg" cx="50" cy="50" r="44"></circle>
        <circle class="ring-fg" id="movesTimerRing" cx="50" cy="50" r="44" stroke-dasharray="276.4601535" stroke-dashoffset="0"></circle>
      </svg>
      <div class="center-text" id="movesTimerText">59</div>
    </div>
    <div class="moves-timer-controls">
      <button class="cf-btn cf-btn-reset" id="movesTimerReset" title="Сброс">✖</button>
      <button class="cf-btn cf-btn-pause" id="movesTimerPause" title="Пауза">II</button>
    </div>
    <button class="cf-btn moves-timer-play" id="movesTimerPlay" title="Старт">▶</button>
  </div>
    <div class="moves-list">
    <div class="move-item" id="move1">
      <div style="margin-bottom:8px;font-weight:600;display:flex;align-items:center;justify-content:space-between;gap:8px">
        <span>1) Бросок кубика</span>
        <div style="display:flex;gap:8px;align-items:center">
          <button class="btn" id="skipTurnBtn" title="Пропустить ход" style="padding:4px 8px;font-size:13px;background:#eee;color:#444;border:1px solid #ccc">Пропуск хода</button>
          <button class="btn" id="finishTurnBtn" style="background:#4a90e2;padding:8px 16px;">Завершить ход</button>
        </div>
      </div>
      <div class="dice-grid" id="diceChoices"></div>
      <div id="diceSelected" style="margin-top:8px;color:#226"></div>
      <div id="boardWrap" style="margin-top:8px;">
        <div class="board-track" id="boardTrack"></div>
      </div>
    </div>
    <div class="move-item" id="move2">
      <div style="margin-bottom:8px;font-weight:600">2) Взять карточку</div>
      <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
        <button class="yes-btn" id="cardYes">Взял</button>
        <button class="no-btn" id="cardNo">Не взял</button>
        <span id="cardStatus" style="color:#226"></span>
      </div>
    </div>
    <div class="move-item" id="move3">
      <div style="margin-bottom:8px;font-weight:600">3) Выдача Денежного потока</div>
        <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
          <button class="yes-btn" id="cashflowYes">Получил</button>
          <button class="yes-btn" id="cashflowYes2" style="display:none">Получил 1</button>
          <button class="yes-btn" id="cashflowYes3" style="display:none">Получил 2</button>
          <button class="no-btn" id="cashflowNo">Пропуск</button>
        <span id="cashflowApplied" style="color:#226"></span>
      </div>
    </div>
    <div class="move-item" id="move4">
      <div style="margin-bottom:8px;font-weight:600">4) Кредит</div>
      <div id="creditBlock" style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
        <button class="yes-btn" id="creditYes">Получил кредит</button>
        <button class="no-btn" id="creditNo">Не получил</button>
        <span id="creditStatus" style="color:#226"></span>
      </div>
    </div>
    <!-- Комментарий к ходу как пункт после кредита (без цифры) -->
    <div class="move-item" id="turnCommentWrap" style="background:#fffef7;border:1px solid #f3e0b3;border-radius:8px;margin:8px 0 12px 0;">
      <div style="margin-bottom:6px;font-weight:600">Комментарий к ходу</div>
      <div style="max-width:100%;">
        <textarea id="turnComment" rows="5" placeholder="Комментарий по ходу" style="width:100%;box-sizing:border-box;padding:6px 8px;font-size:14px;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',sans-serif;resize:vertical"></textarea>
      </div>
    </div>
    <div class="move-item" id="move5">
      <div style="margin-bottom:8px;font-weight:600">Изменение баланса</div>
      <div style="display:flex;gap:6px;align-items:center;flex-wrap:wrap">
        <input type="number" id="balanceDelta" step="0.01" placeholder="± Сумма $" style="width:140px;padding:6px 8px;font-size:14px">
        <input type="text" id="balanceComment" placeholder="Комментарий" style="flex:1;min-width:160px;padding:6px 8px;font-size:14px;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',sans-serif">
        <button class="btn" id="applyDelta" style="padding:6px 10px;font-size:14px">Применить</button>
      </div>
      <div class="balance-box">
        Баланс: <b id="gameBalance">0</b> $<br>
        Ежемес. поток: <b id="gameCashflow">0</b> $
      </div>
    </div>
      <div style="margin-top:10px">
        <button class="btn" id="balanceAdjustBtn" title="Установить баланс вручную" style="padding:6px 10px;font-size:14px;background:#c33">Корректировка баланса</button>
      </div>
    </div>
    

  </div>
  
  <!-- Легкая покупка в разделе Ходы (перенесена под "после хода") -->
  <div id="postTurnEasyBuy" style="margin:32px 0 0 0;padding:18px 16px 18px 16px;background:#f6fff6;border:1px solid #b3f6b3;border-radius:8px;color:#444;max-width:900px">
    <h3 style="margin-top:0;display:flex;align-items:center;justify-content:space-between">Легкая покупка <button class="actBtn" id="easyClearBtnMoves" title="Очистить поля" onclick="clearEasyBuyMoves()">✖</button></h3>
    <div id="easySummaryTopMoves" style="font-size:16px;color:#226;margin:6px 0 24px 0"></div>
    <div class="row" style="max-width:400px;margin-top:4px;display:grid;grid-template-columns:repeat(2,1fr);gap:12px;align-items:flex-start">
      <div class="easy-field" style="display:flex;flex-direction:column">
        <label style="display:block;font-size:13px;color:#666;margin-bottom:4px">Сумма $</label>
        <input id="easySumMoves" type="number" step="0.01" placeholder="Сумма $" onfocus="clearZeroOnFocus(this)" oninput="updateEasyBuyMoves()" class="easy-input">
      </div>
      <div class="easy-field" style="display:flex;flex-direction:column">
        <label style="display:block;font-size:13px;color:#666;margin-bottom:4px">Цена акции</label>
        <input id="easyPriceMoves" type="number" step="0.01" placeholder="Цена акции" onfocus="clearZeroOnFocus(this)" oninput="updateEasyBuyMoves()" class="easy-input">
      </div>
    </div>
    <div class="row" style="max-width:400px;margin-top:8px;display:grid;grid-template-columns:repeat(2,1fr);gap:12px;align-items:flex-start">
      <div class="easy-field" style="display:flex;flex-direction:column">
        <label style="display:block;font-size:13px;color:#666;margin-bottom:4px">Из них мои</label>
        <input id="easyMySumMoves" type="number" step="0.01" placeholder="Из них мои" oninput="updateEasyBuyMyMoves()" onfocus="clearZeroOnFocus(this)" class="easy-input">
      </div>
      <div class="easy-field" style="display:flex;flex-direction:column">
        <label style="display:block;font-size:13px;color:#666;margin-bottom:4px">Ком %</label>
        <input id="easyCommissionMoves" type="number" step="0.01" min="0" max="20" value="0" placeholder="0" oninput="updateEasyBuyMyMoves()" onfocus="clearZeroOnFocus(this)" class="easy-input">
      </div>
    </div>
    <div style="margin-top:8px"><button class="subtle-btn" id="easyToggleTextBtnMoves" onclick="toggleEasyTextMoves()">Показать текст</button></div>
    <div id="easyBottomWrapMoves" style="display:none">
      <div id="easySummaryBottomMoves" style="font-size:16px;color:#226;margin-top:320px;margin-bottom:320px"></div>
    </div>
  </div>
  
  <!-- Кнопка для хода 26 - занимает почти весь экран -->
  <div id="turn26Button" style="margin:32px 0 0 0;padding:18px 16px 18px 16px;background:#fff8e1;border:1px solid #f3e0b3;border-radius:8px;color:#444;max-width:900px;display:none">
    <h3 style="margin-top:0;display:flex;align-items:center;justify-content:space-between">Ход 26 - Специальная кнопка</h3>
    <div style="margin:20px 0;text-align:center;">
      <button class="btn" id="turn26SpecialBtn" style="width:100%;height:120px;font-size:24px;font-weight:bold;background:#4a90e2;color:#fff;border:2px solid #2c5aa0;border-radius:12px;cursor:pointer;box-shadow:0 4px 12px rgba(74,144,226,0.3);transition:all 0.3s ease;" onmouseover="this.style.background='#357abd';this.style.transform='translateY(-2px)';this.style.boxShadow='0 6px 16px rgba(74,144,226,0.4)'" onmouseout="this.style.background='#4a90e2';this.style.transform='translateY(0)';this.style.boxShadow='0 4px 12px rgba(74,144,226,0.3)'">
        🎯 НАЖАТЬ ДЛЯ ХОДА 26 🎯
      </button>
    </div>
    <div style="text-align:center;font-size:14px;color:#666;margin-top:10px;">
      Эта кнопка появляется только на ходу 26
    </div>
  </div>
  
  <div id="postTurnAnchor" style="margin-top:14px"></div>
</section>
<script>
    (function(){
      const btn = document.getElementById('seedTestBtn');
      if (!btn) return;
      btn.addEventListener('click', ()=>{
        const currentTab = document.querySelector('nav button.active, .bottom-nav button.active');
        const currentTabId = currentTab ? currentTab.getAttribute('data-tab') || currentTab.id : null;
        pushUndo();
        // Очистим текущее состояние участников/комиссий/акций
        participants = [];
        participantCom = {};
        holdings = {};
        buyDeals = [];
        sellDealCom = {};
        sellCardCom = {};
        sellCardRecipient = {};
        sellFactors = {};
        burnedSymbols = {};
        // Ведомость
        ledgerIncomes = [];
        ledgerExpenses = [];
        localStorage.removeItem('cf_buyTemp');
        LS.save('cf_history', []);

        const names = ['Dima','Ben','Chris','Diana','Evan','Fiona'];
        names.forEach(n=>{ participants.push(n); participantCom[n]=20; });
        // Владелец — первый
        localStorage.setItem('cf_owner', participants[0]);
        saveAll();

        function addBuy(symbol, price, contributions){
          contributions.forEach(([idx, sum])=>{
            const p = participants[idx-1];
            if(!holdings[p]) holdings[p] = {};
            if(!holdings[p][symbol]) holdings[p][symbol] = {qty:0, avgCost:0};
            const h = holdings[p][symbol];
            const qty = sum / price;
            const totalCost = h.avgCost * h.qty + sum;
            h.qty += qty;
            h.avgCost = totalCost / h.qty;
            // Копим оригинальные вложения по участнику и символу
            if (!buySumByParticipant[symbol]) buySumByParticipant[symbol] = {};
            buySumByParticipant[symbol][p] = (buySumByParticipant[symbol][p]||0) + sum;
          });
          // Сохраним оригинальную сумму покупки по символу
          let total = contributions.reduce((a, c)=>a + c[1], 0);
          if (!(symbol in buySumOriginal)) buySumOriginal[symbol] = 0;
          buySumOriginal[symbol] += total;
          LS.save('cf_buySumOriginal', buySumOriginal);
          LS.save('cf_buySumByParticipant', buySumByParticipant);
        }

        // Первая покупка: Kaspi — 1-й 3000, 2-й 4000, 5-й 2000 по цене 3
        addBuy('KASPI', 3, [[1,3000],[2,4000],[5,2000]]);
        // Списываем только сумму владельца (Dima) с баланса
        applyBalanceDelta(-3000, 'Тест — покупка KASPI (Dima)');
        
        // Вторая покупка: Tesla — 2-й 2000, 3-й 3000 по цене 10
        addBuy('TESLA', 10, [[2,2000],[3,3000]]);
        // Tesla покупает Ben и Chris, владелец не участвует, поэтому не списываем
        
        saveAll();
        
        // Устанавливаем метки покупок с номерами и ходами
        try {
          const buyTurnMap = {};
          buyTurnMap['KASPI'] = '№1, Ход 3';
          buyTurnMap['TESLA'] = '№2, Ход 5';
          LS.save('cf_buyTurnBySymbol', buyTurnMap);
        } catch {}
        
        // Установим цены продажи: Kaspi -> 12, Tesla -> 20
        const prices = loadSellPrices();
        prices['KASPI'] = 12;
        prices['TESLA'] = 20;
        localStorage.setItem('cf_sellPrices', JSON.stringify(prices));

        // Партнеры: одна сделка — сумма 2000, курс покупки 3, курс продажи 6
        partnerRows = [{
          id: Date.now(),
          participant: participants[0] || '',
          symbol: 'PARTNER',
          sum: 2000,
          buy: 3,
          sell: 6,
          com: 20,
          paid: false,
          paidAmount: 0,
          _prevPaidAmount: 0,
          _prevSumBuy: 2000
        }];
        LS.save('cf_partnerRows', partnerRows);
        
        // Списываем сумму покупки с баланса (владелец Dima участвует)
        applyBalanceDelta(-2000, 'Тест — партнерская сделка PARTNER (Dima)');

        // Ведомость — тестовые данные
        ledgerIncomes = [
          {id: Date.now()+1, category:'Зарплата', name:'', amount:25000},
          {id: Date.now()+1.5, category:'Профессия', name:'Робототехника', amount:500},
          {id: Date.now()+2, category:'Пенсия', name:'', amount:3500},
          {id: Date.now()+3, category:'Недвижимость', name:'8 плекс', amount:1500, invest:75000},
          {id: Date.now()+3.6, category:'Недвижимость', name:'Дом 1/2', amount:140, invest:5000}
        ];
        ledgerExpenses = [
          {id: Date.now()+2, category:'Налоги', amount:10000, payoff:0, closable:false, closed:false, children:0},
          {id: Date.now()+3, category:'Ипотека', amount:1500, payoff:200000, closable:true, closed:false, children:0},
          {id: Date.now()+4, category:'Образование', amount:1500, payoff:80000, closable:true, closed:false, children:0},
          {id: Date.now()+5, category:'Автомобиль', amount:1000, payoff:50000, closable:true, closed:false, children:0},
          {id: Date.now()+6, category:'Кредитные карты', amount:800, payoff:40000, closable:true, closed:false, children:0},
          {id: Date.now()+7, category:'Розничные расходы', amount:600, payoff:30000, closable:true, closed:false, children:0},
          {id: Date.now()+8, category:'Другие', amount:7500, payoff:0, closable:false, closed:false, children:0},
          {id: Date.now()+9, category:'Банк. кредит', amount:1900, payoff:19000, closable:true, closed:false, children:0}
        ];
        LS.save('cf_ledgerIncomes', ledgerIncomes);
        LS.save('cf_ledgerExpenses', ledgerExpenses);
        
        // Корректируем баланс на основе доходов и расходов
        // Доходы: +25000 + 500 + 3500 = +29000
        // Расходы: -10000 - 1500 - 1500 - 1000 - 800 - 600 - 7500 - 1900 = -23800
        // Итого: +29000 - 23800 = +5200
        applyBalanceDelta(29000, 'Тест — доходы (Зарплата + Профессия + Пенсия)');
        applyBalanceDelta(-23800, 'Тест — расходы (все категории)');

        // Калькулятор Кэфа Расхода — тестовые данные (коэффициенты по ежемесячному доходу)
        try {
          const ownerName = participants[0];
          const expSeed = {};
          // Владелец — базовые значения
          expSeed[ownerName] = { monthly: 800 };
          // Примеры коэффициентов относительно владельца (для наглядности)
          expSeed['Ben'] = { monthly: 400 };   // x0.50
          expSeed['Chris'] = { monthly: 1600 };  // x2.00
          expSeed['Diana'] = { monthly: 680 }; // ~x0.85
          expSeed['Evan'] = { monthly: 960 };  // ~x1.20
          expSeed['Fiona'] = { monthly: 1200 };  // ~x1.50
          expenseCoef = expSeed;
          LS.save('cf_expenseCoef', expenseCoef);
          try { renderExpenseCoef(); } catch {}
        } catch {}
        // Посредник по первой акции (KASPI): второй участник получает 25% у всех
        // Запишем проценты карточки и получателя для каждого участника, у кого есть KASPI
        sellCardCom['KASPI'] = sellCardCom['KASPI'] || {};
        sellCardRecipient['KASPI'] = sellCardRecipient['KASPI'] || {};
        const mediator = participants[1]; // второй участник
        participants.forEach(pName => {
          const hasK = holdings[pName] && holdings[pName]['KASPI'] && holdings[pName]['KASPI'].qty>0;
          if (hasK) {
            sellCardCom['KASPI'][pName] = 25;
            sellCardRecipient['KASPI'][pName] = mediator;
          }
        });
        LS.save('cf_sellCardCom', sellCardCom);
        LS.save('cf_sellCardRecipient', sellCardRecipient);

        renderParticipants();
        renderBuy();
        renderSell();
        renderPartners();
        try{ renderLedger(); }catch{}
        
        // Заполняем калькулятор КПД
        setTimeout(() => {
          const kpdRows = document.querySelectorAll('.kpdRows .row');
          if (kpdRows.length >= 5) {
            // 75000 1500
            const row1 = kpdRows[0];
            row1.querySelector('.kpdInvest').value = '75000';
            row1.querySelector('.kpdPassive').value = '1500';
            row1.querySelector('.kpdCheck').checked = true;
            // Имитируем ввод пользователя
            row1.querySelector('.kpdInvest').dispatchEvent(new Event('input', { bubbles: true }));
            row1.querySelector('.kpdPassive').dispatchEvent(new Event('input', { bubbles: true }));
            
            // 40000 500
            const row2 = kpdRows[1];
            row2.querySelector('.kpdInvest').value = '40000';
            row2.querySelector('.kpdPassive').value = '500';
            row2.querySelector('.kpdCheck').checked = true;
            // Имитируем ввод пользователя
            row2.querySelector('.kpdInvest').dispatchEvent(new Event('input', { bubbles: true }));
            row2.querySelector('.kpdPassive').dispatchEvent(new Event('input', { bubbles: true }));
            
            // 5000 140
            const row3 = kpdRows[2];
            row3.querySelector('.kpdInvest').value = '5000';
            row3.querySelector('.kpdPassive').value = '140';
            row3.querySelector('.kpdCheck').checked = true;
            // Имитируем ввод пользователя
            row3.querySelector('.kpdInvest').dispatchEvent(new Event('input', { bubbles: true }));
            row3.querySelector('.kpdPassive').dispatchEvent(new Event('input', { bubbles: true }));
            
            // 1200 10
            const row4 = kpdRows[3];
            row4.querySelector('.kpdInvest').value = '1200';
            row4.querySelector('.kpdPassive').value = '10';
            row4.querySelector('.kpdCheck').checked = true;
            // Имитируем ввод пользователя
            row4.querySelector('.kpdInvest').dispatchEvent(new Event('input', { bubbles: true }));
            row4.querySelector('.kpdPassive').dispatchEvent(new Event('input', { bubbles: true }));
            
            // 100000 2000
            const row5 = kpdRows[4];
            row5.querySelector('.kpdInvest').value = '100000';
            row5.querySelector('.kpdPassive').value = '2000';
            row5.querySelector('.kpdCheck').checked = true;
            // Имитируем ввод пользователя
            row5.querySelector('.kpdInvest').dispatchEvent(new Event('input', { bubbles: true }));
            row5.querySelector('.kpdPassive').dispatchEvent(new Event('input', { bubbles: true }));
            
            // Обновляем калькулятор
            try { updateKPD(); } catch {}
          }
        }, 100);
        
        // Заполняем легкую покупку
        setTimeout(() => {
          const easySum = document.getElementById('easySum');
          const easyPrice = document.getElementById('easyPrice');
          const easyMySum = document.getElementById('easyMySum');
          if (easySum) {
            easySum.value = '10000';
            // Имитируем ввод пользователя для корректной записи в историю
            easySum.dispatchEvent(new Event('input', { bubbles: true }));
          }
          if (easyPrice) {
            easyPrice.value = '3';
            // Имитируем ввод пользователя для корректной записи в историю
            easyPrice.dispatchEvent(new Event('input', { bubbles: true }));
          }
          if (easyMySum) {
            easyMySum.value = '4000';
            // Имитируем ввод пользователя для корректной записи в историю
            easyMySum.dispatchEvent(new Event('input', { bubbles: true }));
          }
          try { updateEasyBuy(); } catch {}
        }, 200);
        
        // Заполняем калькулятор выгодной покупки
        setTimeout(() => {
          const buyAmount = document.getElementById('buyAmount');
          const monthlyIncome = document.getElementById('monthlyIncome');
          const partnerCommission = document.getElementById('partnerCommission');
          
          if (buyAmount) {
            buyAmount.value = '5000';
            // Имитируем ввод пользователя для корректной записи в историю
            buyAmount.dispatchEvent(new Event('input', { bubbles: true }));
          }
          if (monthlyIncome) {
            monthlyIncome.value = '140';
            // Имитируем ввод пользователя для корректной записи в историю
            monthlyIncome.dispatchEvent(new Event('input', { bubbles: true }));
          }
          if (partnerCommission) {
            partnerCommission.value = '5000';
            // Имитируем ввод пользователя для корректной записи в историю
            partnerCommission.dispatchEvent(new Event('input', { bubbles: true }));
          }
          
                  // Запускаем расчет
        try { calculateProfitableBuy(); } catch {}
      }, 300);
      
                // Имитация 10 ходов для демонстрации истории и графиков
          setTimeout(() => {
            try {
              // Очищаем существующую историю ходов
              LS.save('cf_turns', []);
              localStorage.setItem('cf_turn_number', '1');
              
              // Создаем 10 реалистичных ходов
              const turns = [];
              
              // Получаем текущий баланс из состояния
              const currentState = getMoveState();
              let currentBalance = Math.round(currentState.balance || 0);
              let currentMonthly = 29000; // Начальный ежемесячный поток (25000+500+3500)
              
              // Добавляем стартовые данные
              const startCapital = currentBalance + computeCapitalFromCurrentState().invested + computeCapitalFromCurrentState().payoff;
              // Убираем автоматическое добавление стартовых данных
          
          for (let turn = 1; turn <= 10; turn++) {
            const dice = Math.floor(Math.random() * 12) + 1;
            const cardChoice = Math.random() > 0.3; // 70% вероятность взять карточку
            const cashflowDone = Math.random() > 0.2; // 80% вероятность получить денежный поток
            const creditTaken = Math.random() > 0.8; // 20% вероятность взять кредит
            
            // Случайные изменения баланса
            let balanceChange = 0;
            const events = [];
            
            // Если взял карточку - возможна покупка
            if (cardChoice && Math.random() > 0.5) {
              const purchaseAmount = Math.floor(Math.random() * 5000) + 1000;
              balanceChange -= purchaseAmount;
              events.push({ time: Date.now() + turn, delta: -purchaseAmount, desc: 'Покупка акций' });
            }
            
            // Если получил денежный поток
            if (cashflowDone) {
              balanceChange += currentMonthly;
              events.push({ time: Date.now() + turn, delta: currentMonthly, desc: 'Денежный поток' });
            }
            
            // Если взял кредит
            if (creditTaken) {
              const creditAmount = Math.floor(Math.random() * 10000) + 5000;
              balanceChange += creditAmount;
              events.push({ time: Date.now() + turn, delta: creditAmount, desc: 'Кредит получен' });
            }
            
            // Случайные дополнительные операции
            if (Math.random() > 0.7) {
              const extraAmount = Math.floor(Math.random() * 2000) - 1000; // от -1000 до +1000
              if (extraAmount !== 0) {
                balanceChange += extraAmount;
                events.push({ 
                  time: Date.now() + turn, 
                  delta: extraAmount, 
                  desc: extraAmount > 0 ? 'Дополнительный доход' : 'Дополнительный расход' 
                });
              }
            }
            
            // Обновляем баланс
            currentBalance = currentBalance + balanceChange;
            
            // Рассчитываем капитал для этого хода
            const capital = currentBalance + computeCapitalFromCurrentState().invested + computeCapitalFromCurrentState().payoff;
            
            // Создаем запись хода
            const turnRecord = {
              num: turn,
              dice: dice,
              cardChoice: cardChoice,
              card: cardChoice ? (Math.random() > 0.5 ? 'Сделка' : 'Всячина') : null,
              cashflowDone: cashflowDone,
              monthly: currentMonthly,
              creditTaken: creditTaken,
              credit: creditTaken ? `Кредит ${Math.floor(Math.random() * 10000) + 5000}$` : null,
              balance: currentBalance,
              capital: capital,
              comment: turn % 3 === 0 ? `Комментарий к ходу ${turn}` : '',
              events: events,
              time: Date.now() + turn * 1000,
              post: false
            };
            
            turns.unshift(turnRecord); // Добавляем в начало (новые сверху)
            
            // Создаем запись "После хода" с итоговым балансом
            const postCapital = currentBalance + computeCapitalFromCurrentState().invested + computeCapitalFromCurrentState().payoff;
            const postRecord = {
              num: turn,
              balance: currentBalance,
              capital: postCapital,
              comment: turn % 4 === 0 ? `Комментарий после хода ${turn}` : '',
              events: [],
              time: Date.now() + turn * 1000 + 500,
              timeFormatted: new Date(Date.now() + turn * 1000 + 500).toLocaleString(),
              post: true,
              skip: false
            };
            
            turns.unshift(postRecord);
          }
          
          // Сохраняем историю ходов
          LS.save('cf_turns', turns);
          localStorage.setItem('cf_turn_number', '11'); // Следующий ход будет 11
          
          // Обновляем отображение
          try { renderTurnsHistory(); } catch {}
          try { renderBalanceChart(); } catch {}
          
        } catch (e) {
          console.warn('Ошибка при создании тестовых ходов:', e);
        }
      }, 400);
      
      // Не переключаем вкладку, остаемся там же, где нажали "Тест"
              document.getElementById('seedResult').textContent = 'Тест данные загружены (включая 10 ходов с номерами покупок)';
        // Возвращаемся к исходной вкладке, если внезапно переключились
        if (currentTabId) {
          try { setActive(currentTabId); } catch {}
        }
      });
    })();
  </script>
  <script>
    // Кнопки Тест/Тест2/Тест звука в Истории
    function seedTestBtnClick(){ 
      try{ 
        const currentTab = document.querySelector('nav button.active, .bottom-nav button.active');
        const currentTabId = currentTab ? currentTab.getAttribute('data-tab') || currentTab.id : null;
        pushUndo();
        // Очистим текущее состояние участников/комиссий/акций
        participants = [];
        participantCom = {};
        holdings = {};
        buyDeals = [];
        sellDealCom = {};
        sellCardCom = {};
        sellCardRecipient = {};
        sellFactors = {};
        burnedSymbols = {};
        // Ведомость
        ledgerIncomes = [];
        ledgerExpenses = [];
        localStorage.removeItem('cf_buyTemp');
        LS.save('cf_history', []);

        const names = ['Dima','Ben','Chris','Diana','Evan','Fiona'];
        names.forEach(n=>{ participants.push(n); participantCom[n]=20; });
        // Владелец — первый
        localStorage.setItem('cf_owner', participants[0]);
        saveAll();

        function addBuy(symbol, price, contributions){
          contributions.forEach(([idx, sum])=>{
            const p = participants[idx-1];
            if(!holdings[p]) holdings[p] = {};
            if(!holdings[p][symbol]) holdings[p][symbol] = {qty:0, avgCost:0};
            const h = holdings[p][symbol];
            const qty = sum / price;
            const totalCost = h.avgCost * h.qty + sum;
            h.qty += qty;
            h.avgCost = totalCost / h.qty;
            // Копим оригинальные вложения по участнику и символу
            if (!buySumByParticipant[symbol]) buySumByParticipant[symbol] = {};
            buySumByParticipant[symbol][p] = (buySumByParticipant[symbol][p]||0) + sum;
          });
          // Сохраним оригинальную сумму покупки по символу
          let total = contributions.reduce((a, c)=>a + c[1], 0);
          if (!(symbol in buySumOriginal)) buySumOriginal[symbol] = 0;
          buySumOriginal[symbol] += total;
          LS.save('cf_buySumOriginal', buySumOriginal);
          LS.save('cf_buySumByParticipant', buySumByParticipant);
        }

        // Первая покупка: Kaspi — 1-й 3000, 2-й 4000, 5-й 2000 по цене 3
        addBuy('KASPI', 3, [[1,3000],[2,4000],[5,2000]]);
        // Списываем только сумму владельца (Dima) с баланса
        applyBalanceDelta(-3000, 'Тест — покупка KASPI (Dima)');
        
        // Вторая покупка: Tesla — 2-й 2000, 3-й 3000 по цене 10
        addBuy('TESLA', 10, [[2,2000],[3,3000]]);
        // Tesla покупают Ben и Chris, владелец не участвует, поэтому не списываем
        
        saveAll();
        
        // Устанавливаем метки покупок с номерами и ходами
        try {
          const buyTurnMap = {};
          buyTurnMap['KASPI'] = '№1, Ход 3';
          buyTurnMap['TESLA'] = '№2, Ход 5';
          LS.save('cf_buyTurnBySymbol', buyTurnMap);
        } catch {}
        
        // Установим цены продажи: Kaspi -> 12, Tesla -> 20
        const prices = loadSellPrices();
        prices['KASPI'] = 12;
        prices['TESLA'] = 20;
        localStorage.setItem('cf_sellPrices', JSON.stringify(prices));

        // Партнеры: одна сделка — сумма 2000, курс покупки 3, курс продажи 6
        partnerRows = [{
          id: Date.now(),
          participant: participants[0] || '',
          symbol: 'PARTNER',
          sum: 2000,
          buy: 3,
          sell: 6,
          com: 20,
          paid: false,
          paidAmount: 0,
          _prevPaidAmount: 0,
          _prevSumBuy: 2000
        }];
        LS.save('cf_partnerRows', partnerRows);
        
        // Списываем сумму покупки с баланса (владелец Dima участвует)
        applyBalanceDelta(-2000, 'Тест — партнерская сделка PARTNER (Dima)');

        // Ведомость — тестовые данные
        ledgerIncomes = [
          {id: Date.now()+1, category:'Зарплата', name:'', amount:25000},
          {id: Date.now()+1.5, category:'Профессия', name:'Робототехника', amount:500},
          {id: Date.now()+2, category:'Пенсия', name:'', amount:3500},
          {id: Date.now()+3, category:'Недвижимость', name:'8 плекс', amount:1500, invest:75000},
          {id: Date.now()+3.6, category:'Недвижимость', name:'Дом 1/2', amount:140, invest:5000}
        ];
        ledgerExpenses = [
          {id: Date.now()+2, category:'Налоги', amount:10000, payoff:0, closable:false, closed:false, children:0},
          {id: Date.now()+3, category:'Ипотека', amount:1500, payoff:200000, closable:true, closed:false, children:0},
          {id: Date.now()+4, category:'Образование', amount:1500, payoff:80000, closable:true, closed:false, children:0},
          {id: Date.now()+5, category:'Автомобиль', amount:1000, payoff:50000, closable:true, closed:false, children:0},
          {id: Date.now()+6, category:'Кредитные карты', amount:800, payoff:40000, closable:true, closed:false, children:0},
          {id: Date.now()+7, category:'Розничные расходы', amount:600, payoff:30000, closable:true, closed:false, children:0},
          {id: Date.now()+8, category:'Другие', amount:7500, payoff:0, closable:false, closed:false, children:0},
          {id: Date.now()+9, category:'Банк. кредит', amount:1900, payoff:19000, closable:true, closed:false, children:0}
        ];
        LS.save('cf_ledgerIncomes', ledgerIncomes);
        LS.save('cf_ledgerExpenses', ledgerExpenses);
        
        // Корректируем баланс на основе доходов и расходов
        // Доходы: +25000 + 500 + 3500 = +29000
        // Расходы: -10000 - 1500 - 1500 - 1000 - 800 - 600 - 7500 - 1900 = -23800
        // Итого: +29000 - 23800 = +5200
        applyBalanceDelta(29000, 'Тест — доходы (Зарплата + Профессия + Пенсия)');
        applyBalanceDelta(-23800, 'Тест — расходы (все категории)');

        // Калькулятор Кэфа Расхода — тестовые данные (коэффициенты по ежемесячному доходу)
        try {
          const ownerName = participants[0];
          const expSeed = {};
          // Владелец — базовые значения
          expSeed[ownerName] = { monthly: 800 };
          // Примеры коэффициентов относительно владельца (для наглядности)
          expSeed['Ben'] = { monthly: 400 };   // x0.50
          expSeed['Chris'] = { monthly: 1600 };  // x2.00
          expSeed['Diana'] = { monthly: 680 }; // ~x0.85
          expSeed['Evan'] = { monthly: 960 };  // ~x1.20
          expSeed['Fiona'] = { monthly: 1200 };  // ~x1.50
          expenseCoef = expSeed;
          LS.save('cf_expenseCoef', expenseCoef);
          try { renderExpenseCoef(); } catch {}
        } catch {}
        // Посредник по первой акции (KASPI): второй участник получает 25% у всех
        // Запишем проценты карточки и получателя для каждого участника, у кого есть KASPI
        sellCardCom['KASPI'] = sellCardCom['KASPI'] || {};
        sellCardRecipient['KASPI'] = sellCardRecipient['KASPI'] || {};
        const mediator = participants[1]; // второй участник
        participants.forEach(pName => {
          const hasK = holdings[pName] && holdings[pName]['KASPI'] && holdings[pName]['KASPI'].qty>0;
          if (hasK) {
            sellCardCom['KASPI'][pName] = 25;
            sellCardRecipient['KASPI'][pName] = mediator;
          }
        });
        LS.save('cf_sellCardCom', sellCardCom);
        LS.save('cf_sellCardRecipient', sellCardRecipient);

        renderParticipants();
        renderBuy();
        renderSell();
        renderPartners();
        try{ renderLedger(); }catch{}
        
        // Заполняем калькулятор КПД
        setTimeout(() => {
          const kpdRows = document.querySelectorAll('.kpdRows .row');
          if (kpdRows.length >= 5) {
            // 75000 1500
            const row1 = kpdRows[0];
            row1.querySelector('.kpdInvest').value = '75000';
            row1.querySelector('.kpdPassive').value = '1500';
            row1.querySelector('.kpdCheck').checked = true;
            // Имитируем ввод пользователя
            row1.querySelector('.kpdInvest').dispatchEvent(new Event('input', { bubbles: true }));
            row1.querySelector('.kpdPassive').dispatchEvent(new Event('input', { bubbles: true }));
            
            // 40000 500
            const row2 = kpdRows[1];
            row2.querySelector('.kpdInvest').value = '40000';
            row2.querySelector('.kpdPassive').value = '500';
            row2.querySelector('.kpdCheck').checked = true;
            // Имитируем ввод пользователя
            row2.querySelector('.kpdInvest').dispatchEvent(new Event('input', { bubbles: true }));
            row2.querySelector('.kpdPassive').dispatchEvent(new Event('input', { bubbles: true }));
            
            // 5000 140
            const row3 = kpdRows[2];
            row3.querySelector('.kpdInvest').value = '5000';
            row3.querySelector('.kpdPassive').value = '140';
            row3.querySelector('.kpdCheck').checked = true;
            // Имитируем ввод пользователя
            row3.querySelector('.kpdInvest').dispatchEvent(new Event('input', { bubbles: true }));
            row3.querySelector('.kpdPassive').dispatchEvent(new Event('input', { bubbles: true }));
            
            // 1200 10
            const row4 = kpdRows[3];
            row4.querySelector('.kpdInvest').value = '1200';
            row4.querySelector('.kpdPassive').value = '10';
            row4.querySelector('.kpdCheck').checked = true;
            // Имитируем ввод пользователя
            row4.querySelector('.kpdInvest').dispatchEvent(new Event('input', { bubbles: true }));
            row4.querySelector('.kpdPassive').dispatchEvent(new Event('input', { bubbles: true }));
            
            // 100000 2000
            const row5 = kpdRows[4];
            row5.querySelector('.kpdInvest').value = '100000';
            row5.querySelector('.kpdPassive').value = '2000';
            row5.querySelector('.kpdCheck').checked = true;
            // Имитируем ввод пользователя
            row5.querySelector('.kpdInvest').dispatchEvent(new Event('input', { bubbles: true }));
            row5.querySelector('.kpdPassive').dispatchEvent(new Event('input', { bubbles: true }));
            
            // Обновляем калькулятор
            try { updateKPD(); } catch {}
          }
        }, 100);
        
        // Заполняем легкую покупку
        setTimeout(() => {
          const easySum = document.getElementById('easySum');
          const easyPrice = document.getElementById('easyPrice');
          const easyMySum = document.getElementById('easyMySum');
          if (easySum) {
            easySum.value = '10000';
            // Имитируем ввод пользователя для корректной записи в историю
            easySum.dispatchEvent(new Event('input', { bubbles: true }));
          }
          if (easyPrice) {
            easyPrice.value = '3';
            // Имитируем ввод пользователя для корректной записи в историю
            easyPrice.dispatchEvent(new Event('input', { bubbles: true }));
          }
          if (easyMySum) {
            easyMySum.value = '4000';
            // Имитируем ввод пользователя для корректной записи в историю
            easyMySum.dispatchEvent(new Event('input', { bubbles: true }));
          }
          try { updateEasyBuy(); } catch {}
        }, 200);
        
        // Заполняем калькулятор выгодной покупки
        setTimeout(() => {
          const buyAmount = document.getElementById('buyAmount');
          const monthlyIncome = document.getElementById('monthlyIncome');
          const partnerCommission = document.getElementById('partnerCommission');
          
          if (buyAmount) {
            buyAmount.value = '5000';
            // Имитируем ввод пользователя для корректной записи в историю
            buyAmount.dispatchEvent(new Event('input', { bubbles: true }));
          }
          if (monthlyIncome) {
            monthlyIncome.value = '140';
            // Имитируем ввод пользователя для корректной записи в историю
            monthlyIncome.dispatchEvent(new Event('input', { bubbles: true }));
          }
          if (partnerCommission) {
            partnerCommission.value = '5000';
            // Имитируем ввод пользователя для корректной записи в историю
            partnerCommission.dispatchEvent(new Event('input', { bubbles: true }));
          }
          
                  // Запускаем расчет
        try { calculateProfitableBuy(); } catch {}
      }, 300);
      
                // Имитация 10 ходов для демонстрации истории и графиков
          setTimeout(() => {
            try {
              // Очищаем существующую историю ходов
              LS.save('cf_turns', []);
              localStorage.setItem('cf_turn_number', '1');
              
              // Создаем 10 реалистичных ходов с операциями
              const turns = [];
              
              // Получаем текущий баланс из состояния
              const currentState = getMoveState();
              let currentBalance = Math.round(currentState.balance || 0);
              let currentMonthly = 29000; // Начальный ежемесячный поток (25000+500+3500)
              
              // Массив типов операций для разнообразия
              const operationTypes = [
                'Покупка акций KASPI', 'Продажа акций TESLA', 'Инвестиция в недвижимость',
                'Партнерская сделка', 'Корректировка баланса', 'Дополнительный доход',
                'Комиссия партнеру', 'Возврат инвестиций', 'Погашение кредита'
              ];
          
          for (let turn = 1; turn <= 10; turn++) {
            const dice = Math.floor(Math.random() * 12) + 1;
            const cardChoice = Math.random() > 0.3; // 70% вероятность взять карточку
            const cashflowDone = Math.random() > 0.2; // 80% вероятность получить денежный поток
            const creditTaken = Math.random() > 0.8; // 20% вероятность взять кредит
            
            // Случайные изменения баланса
            let balanceChange = 0;
            const events = [];
            const operations = []; // Массив операций для хода
            
            // Если взял карточку - возможна покупка
            if (cardChoice && Math.random() > 0.5) {
              const purchaseAmount = Math.floor(Math.random() * 5000) + 1000;
              balanceChange -= purchaseAmount;
              events.push({ time: Date.now() + turn, delta: -purchaseAmount, desc: 'Покупка акций' });
              
              // Добавляем операцию
              operations.push({
                time: Date.now() + turn,
                timeFormatted: new Date(Date.now() + turn * 1000).toLocaleString(),
                type: 'Покупка',
                desc: `Покупка акций на сумму ${purchaseAmount}$`,
                delta: -purchaseAmount
              });
            }
            
            // Если получил денежный поток
            if (cashflowDone) {
              balanceChange += currentMonthly;
              events.push({ time: Date.now() + turn, delta: currentMonthly, desc: 'Денежный поток' });
            }
            
            // Если взял кредит
            if (creditTaken) {
              const creditAmount = Math.floor(Math.random() * 10000) + 5000;
              balanceChange += creditAmount;
              events.push({ time: Date.now() + turn, delta: creditAmount, desc: 'Кредит получен' });
              
              // Добавляем операцию
              operations.push({
                time: Date.now() + turn,
                timeFormatted: new Date(Date.now() + turn * 1000).toLocaleString(),
                type: 'Кредит',
                desc: `Получен кредит ${creditAmount}$`,
                delta: creditAmount
              });
            }
            
            // Случайные дополнительные операции (2-4 операции на ход)
            const numOperations = Math.floor(Math.random() * 3) + 2;
            for (let op = 0; op < numOperations; op++) {
              const operationType = operationTypes[Math.floor(Math.random() * operationTypes.length)];
              let opDelta = 0;
              let opDesc = '';
              
              switch(operationType) {
                case 'Покупка акций KASPI':
                  opDelta = -(Math.floor(Math.random() * 3000) + 1000);
                  opDesc = `Покупка KASPI ${Math.abs(opDelta)}$`;
                  break;
                case 'Продажа акций TESLA':
                  opDelta = Math.floor(Math.random() * 2000) + 500;
                  opDesc = `Продажа TESLA +${opDelta}$`;
                  break;
                case 'Инвестиция в недвижимость':
                  opDelta = -(Math.floor(Math.random() * 15000) + 5000);
                  opDesc = `Инвестиция в недвижимость ${Math.abs(opDelta)}$`;
                  break;
                case 'Партнерская сделка':
                  opDelta = -(Math.floor(Math.random() * 2000) + 500);
                  opDesc = `Партнерская сделка ${Math.abs(opDelta)}$`;
                  break;
                case 'Корректировка баланса':
                  opDelta = Math.floor(Math.random() * 1000) - 500;
                  opDesc = `Корректировка ${opDelta >= 0 ? '+' : ''}${opDelta}$`;
                  break;
                case 'Дополнительный доход':
                  opDelta = Math.floor(Math.random() * 800) + 200;
                  opDesc = `Доп. доход +${opDelta}$`;
                  break;
                case 'Комиссия партнеру':
                  opDelta = Math.floor(Math.random() * 300) + 100;
                  opDesc = `Комиссия партнеру +${opDelta}$`;
                  break;
                case 'Возврат инвестиций':
                  opDelta = Math.floor(Math.random() * 1000) + 500;
                  opDesc = `Возврат инвестиций +${opDelta}$`;
                  break;
                case 'Погашение кредита':
                  opDelta = -(Math.floor(Math.random() * 500) + 200);
                  opDesc = `Погашение кредита ${Math.abs(opDelta)}$`;
                  break;
              }
              
              balanceChange += opDelta;
              
              // Добавляем операцию
              operations.push({
                time: Date.now() + turn + op * 100,
                timeFormatted: new Date(Date.now() + turn * 1000 + op * 100).toLocaleString(),
                type: operationType.split(' ')[0], // Берем первое слово как тип
                desc: opDesc,
                delta: opDelta
              });
            }
            
            // Обновляем баланс
            currentBalance = currentBalance + balanceChange;
            
            // Рассчитываем капитал для этого хода (без учета погашений)
            const capital = currentBalance + computeCapitalWithoutPayoff().invested;
            
            // Создаем запись хода
            const turnRecord = {
              num: turn,
              dice: dice,
              cardChoice: cardChoice,
              card: cardChoice ? (Math.random() > 0.5 ? 'Сделка' : 'Всячина') : null,
              cashflowDone: cashflowDone,
              monthly: currentMonthly,
              creditTaken: creditTaken,
              credit: creditTaken ? `оформлен` : null,
              balance: currentBalance,
              capital: capital,
              balanceChange: balanceChange,
              comment: turn % 3 === 0 ? `Комментарий к ходу ${turn}` : '',
              events: events,
              operations: operations, // Добавляем операции
              time: Date.now() + turn * 1000,
              timeFormatted: new Date(Date.now() + turn * 1000).toLocaleString(),
              post: false
            };
            
            turns.unshift(turnRecord); // Добавляем в начало (новые сверху)
            
            // Создаем запись "После хода" с итоговым балансом
            const postCapital = currentBalance + computeCapitalWithoutPayoff().invested;
            const postRecord = {
              num: turn,
              balance: currentBalance,
              capital: postCapital,
              comment: turn % 4 === 0 ? `Комментарий после хода ${turn}` : '',
              events: [],
              operations: [], // Пустые операции для "После хода"
              time: Date.now() + turn * 1000 + 500,
              timeFormatted: new Date(Date.now() + turn * 1000 + 500).toLocaleString(),
              post: true,
              skip: false
            };
            
            turns.unshift(postRecord);
          }
          
          // Сохраняем историю ходов
          LS.save('cf_turns', turns);
          localStorage.setItem('cf_turn_number', '11'); // Следующий ход будет 11
          
          // Обновляем отображение
          try { renderTurnsHistory(); } catch {}
          try { renderBalanceChart(); } catch {}
          
        } catch (e) {
          console.warn('Ошибка при создании тестовых ходов:', e);
        }
      }, 400);
      
      // Не переключаем вкладку, остаемся там же, где нажали "Тест"
      showToast('Тест данные загружены (включая 10 ходов с номерами покупок)');
      // Возвращаемся к исходной вкладке, если внезапно переключились
      if (currentTabId) {
        try { setActive(currentTabId); } catch {}
      }
      }catch(e){ 
        console.error('Ошибка в Тест 1:', e);
        alert('Ошибка при загрузке тестовых данных: ' + e.message); 
      } 
    }
    function seedTestBtn2Click(){ 
      try{ 
        const currentTab = document.querySelector('nav button.active, .bottom-nav button.active');
        const currentTabId = currentTab ? currentTab.getAttribute('data-tab') || currentTab.id : null;
        pushUndo();
        // Очистка текущего состояния
        participants = [];
        participantCom = {};
        holdings = {};
        buyDeals = [];
        sellDealCom = {};
        sellCardCom = {};
        sellCardRecipient = {};
        sellFactors = {};
        burnedSymbols = {};
        // Ведомость
        ledgerIncomes = [];
        ledgerExpenses = [];
        localStorage.removeItem('cf_buyTemp');
        LS.save('cf_history', []);

        // Участники
        const names = ['Alex','Bora','Chen','Dana','Ivan'];
        names.forEach(n=>{ participants.push(n); participantCom[n]=20; });
        // Разные проценты участия
        participantCom['Alex'] = 18;
        participantCom['Bora'] = 20; // владелец — всё равно 0 при расчёте комиссии в UI
        participantCom['Chen'] = 22;
        participantCom['Dana'] = 15;
        participantCom['Ivan'] = 25;

        // Владелец — второй
        localStorage.setItem('cf_owner', participants[1]);
        saveAll();

        // Хелпер добавления покупок с фиксированием оригинальных сумм и по участникам
        function addBuy(sym, price, contributions){
          contributions.forEach(([idx, sum])=>{
            const p = participants[idx-1];
            if(!holdings[p]) holdings[p] = {};
            if(!holdings[p][sym]) holdings[p][sym] = {qty:0, avgCost:0};
            const h = holdings[p][sym];
            const qty = sum / price;
            const totalCost = h.avgCost * h.qty + sum;
            h.qty += qty;
            h.avgCost = totalCost / h.qty;
            if (!buySumByParticipant[sym]) buySumByParticipant[sym] = {};
            buySumByParticipant[sym][p] = (buySumByParticipant[sym][p]||0) + sum;
          });
          let total = contributions.reduce((a, c)=>a + c[1], 0);
          if (!(sym in buySumOriginal)) buySumOriginal[sym] = 0;
          buySumOriginal[sym] += total;
          LS.save('cf_buySumOriginal', buySumOriginal);
          LS.save('cf_buySumByParticipant', buySumByParticipant);
        }

        // Покупки: другие тикеры и суммы
        addBuy('ALFA', 5, [[1,4000],[2,3000]]);
        // Списываем только сумму владельца (Bora) с баланса
        applyBalanceDelta(-3000, 'Тест 2 — покупка ALFA (Bora)');
        
        addBuy('BETA', 8, [[3,5000],[4,2000]]);
        // BETA покупают Dana и Ivan, владелец не участвует, поэтому не списываем
        
        saveAll();
        
        // Устанавливаем метки покупок с номерами и ходами
        try {
          const buyTurnMap = {};
          buyTurnMap['ALFA'] = '№1, Ход 4';
          buyTurnMap['BETA'] = '№2, Ход 7';
          LS.save('cf_buyTurnBySymbol', buyTurnMap);
        } catch {}

        // Цены продажи
        const prices = loadSellPrices();
        prices['ALFA'] = 7;   // прибыльная
        prices['BETA'] = 6;   // убыточная относительно средней
        localStorage.setItem('cf_sellPrices', JSON.stringify(prices));

        // Посредник по ALFA: Dana получает 15% у всех, по BETA: Ivan 10%
        sellCardCom['ALFA'] = sellCardCom['ALFA'] || {};
        sellCardRecipient['ALFA'] = sellCardRecipient['ALFA'] || {};
        sellCardCom['BETA'] = sellCardCom['BETA'] || {};
        sellCardRecipient['BETA'] = sellCardRecipient['BETA'] || {};
        const mediatorA = 'Dana';
        const mediatorB = 'Ivan';
        participants.forEach(pName => {
          if (holdings[pName]?.['ALFA']?.qty>0) {
            sellCardCom['ALFA'][pName] = 15;
            sellCardRecipient['ALFA'][pName] = mediatorA;
          }
          if (holdings[pName]?.['BETA']?.qty>0) {
            sellCardCom['BETA'][pName] = 10;
            sellCardRecipient['BETA'][pName] = mediatorB;
          }
        });
        LS.save('cf_sellCardCom', sellCardCom);
        LS.save('cf_sellCardRecipient', sellCardRecipient);

        // Партнеры — 2 сделки с разными параметрами
        partnerRows = [
          { id: Date.now()+1, participant: participants[1], symbol: 'PRTN-A', sum: 1500, buy: 4, sell: 9, com: 15, paid: false, paidAmount: 0, _prevPaidAmount: 0, _prevSumBuy: 1500 },
          { id: Date.now()+2, participant: participants[3], symbol: 'PRTN-B', sum: 3000, buy: 6, sell: 5, com: 25, paid: false, paidAmount: 0, _prevPaidAmount: 0, _prevSumBuy: 3000 }
        ];
        LS.save('cf_partnerRows', partnerRows);
        
        // Списываем только сумму владельца (Bora) с баланса
        applyBalanceDelta(-1500, 'Тест 2 — партнерская сделка PRTN-A (Bora)');
        // PRTN-B покупает Ivan, владелец не участвует, поэтому не списываем

        // Ведомость — доходы (по требованию: оставить только ЗП, но добавить Дом 2/1 140 / 5000 и Sqw 10 / 1200)
        ledgerIncomes = [
          { id: Date.now()+10, category:'Зарплата', name:'', amount:3800 },
          { id: Date.now()+11, category:'Недвижимость', name:'Дом 2/1', amount:140, invest:5000 },
          { id: Date.now()+12, category:'Дивиденды', name:'Sqw', amount:10, invest:1200, price:1200 }
        ];
        LS.save('cf_ledgerIncomes', ledgerIncomes);

        // Ведомость — расходы (по вашему списку)
        ledgerExpenses = [
          { id: Date.now()+20, category:'Налоги', amount:750, payoff:0, closable:false, closed:false, children:0 },
          { id: Date.now()+21, category:'Ипотека', amount:600, payoff:43000, closable:true, closed:false, children:0 },
          { id: Date.now()+22, category:'Образование', amount:0, payoff:0, closable:true, closed:false, children:0 },
          { id: Date.now()+23, category:'Автомобиль', amount:200, payoff:5500, closable:true, closed:false, children:0 },
          { id: Date.now()+24, category:'Кредитные карты', amount:100, payoff:3500, closable:true, closed:false, children:0 },
          { id: Date.now()+25, category:'Розничные расходы', amount:50, payoff:2000, closable:true, closed:false, children:0 },
          { id: Date.now()+26, category:'Другие', amount:700, payoff:0, closable:false, closed:false, children:0 },
          { id: Date.now()+27, category:'Ребенок', amount:250, payoff:0, closable:true, closed:false, children:0 },
          { id: Date.now()+28, category:'Банк. кредит', amount:0, payoff:0, closable:true, closed:false, children:0 }
        ];
        LS.save('cf_ledgerExpenses', ledgerExpenses);
        
        // Корректируем баланс на основе доходов и расходов
        // Доходы: +3800
        // Расходы: -750 - 600 - 200 - 100 - 50 - 700 - 250 = -2650
        // Итого: +3800 - 2650 = +1150
        applyBalanceDelta(3800, 'Тест 2 — доходы (Зарплата)');
        applyBalanceDelta(-2650, 'Тест 2 — расходы (все категории)');

        // Калькулятор Кэфа Расхода — другие коэффициенты (по ежемесячному доходу)
        try {
          const ownerName = participants[1];
          const expSeed = {};
          expSeed[ownerName] = { monthly: 900 };
          expSeed['Alex'] = { monthly: 450 };  // x0.50
          expSeed['Chen'] = { monthly: 1350 }; // x1.50
          expSeed['Dana'] = { monthly: 700 }; // ~x0.78
          expSeed['Ivan'] = { monthly: 1100 }; // ~x1.22
          expenseCoef = expSeed;
          LS.save('cf_expenseCoef', expenseCoef);
          try { renderExpenseCoef(); } catch {}
        } catch {}

        renderParticipants();
        renderBuy();
        renderSell();
        renderPartners();
        try { renderLedger(); } catch {}

        // Инициализируем калькулятор выгодной покупки тестовыми значениями
        setTimeout(() => {
          const buyAmount = document.getElementById('buyAmount');
          const monthlyIncome = document.getElementById('monthlyIncome');
          const partnerCommission = document.getElementById('partnerCommission');
          if (buyAmount) {
            buyAmount.value = '12000';
            buyAmount.dispatchEvent(new Event('input', { bubbles: true }));
          }
          if (monthlyIncome) {
            monthlyIncome.value = '480';
            monthlyIncome.dispatchEvent(new Event('input', { bubbles: true }));
          }
          if (partnerCommission) {
            partnerCommission.value = '600';
            partnerCommission.dispatchEvent(new Event('input', { bubbles: true }));
          }
          try { calculateProfitableBuy(); } catch {}
        }, 200);
        
        // Добавляем стартовые данные в историю ходов для теста 2
        setTimeout(() => {
          try {
            const turns = getTurns();
            const startRecord = turns.find(tr => tr.num === 0 && tr.post === true);
            if (!startRecord) {
              const st = getMoveState();
              const capital = Math.round(st.balance||0) + computeCapitalFromCurrentState().invested + computeCapitalFromCurrentState().payoff;
              // Убираем автоматическое добавление стартовых данных
            }
          } catch {}
        }, 400);

        // Заполняем калькулятор КПД данными как в Тест
        setTimeout(() => {
          try {
            const kpdRows = document.querySelectorAll('.kpdRows .row');
            if (kpdRows.length >= 5) {
              // 75000 1500
              kpdRows[0].querySelector('.kpdInvest').value = '75000';
              kpdRows[0].querySelector('.kpdPassive').value = '1500';
              kpdRows[0].querySelector('.kpdCheck').checked = true;
              kpdRows[0].querySelector('.kpdInvest').dispatchEvent(new Event('input', { bubbles: true }));
              kpdRows[0].querySelector('.kpdPassive').dispatchEvent(new Event('input', { bubbles: true }));

              // 40000 500
              kpdRows[1].querySelector('.kpdInvest').value = '40000';
              kpdRows[1].querySelector('.kpdPassive').value = '500';
              kpdRows[1].querySelector('.kpdCheck').checked = true;
              kpdRows[1].querySelector('.kpdInvest').dispatchEvent(new Event('input', { bubbles: true }));
              kpdRows[1].querySelector('.kpdPassive').dispatchEvent(new Event('input', { bubbles: true }));

              // 5000 140
              kpdRows[2].querySelector('.kpdInvest').value = '5000';
              kpdRows[2].querySelector('.kpdPassive').value = '140';
              kpdRows[2].querySelector('.kpdCheck').checked = true;
              kpdRows[2].querySelector('.kpdInvest').dispatchEvent(new Event('input', { bubbles: true }));
              kpdRows[2].querySelector('.kpdPassive').dispatchEvent(new Event('input', { bubbles: true }));

              // 1200 10
              kpdRows[3].querySelector('.kpdInvest').value = '1200';
              kpdRows[3].querySelector('.kpdPassive').value = '10';
              kpdRows[3].querySelector('.kpdCheck').checked = true;
              kpdRows[3].querySelector('.kpdInvest').dispatchEvent(new Event('input', { bubbles: true }));
              row3.querySelector('.kpdPassive').dispatchEvent(new Event('input', { bubbles: true }));

              // 100000 2000
              kpdRows[4].querySelector('.kpdInvest').value = '100000';
              kpdRows[4].querySelector('.kpdPassive').value = '2000';
              kpdRows[4].querySelector('.kpdCheck').checked = true;
              kpdRows[4].querySelector('.kpdInvest').dispatchEvent(new Event('input', { bubbles: true }));
              kpdRows[4].querySelector('.kpdPassive').dispatchEvent(new Event('input', { bubbles: true }));

              try { updateKPD(); } catch {}
            }
          } catch {}
        }, 350);

        // Создаем тестовые ходы с операциями для Тест 2
        setTimeout(() => {
          try {
            // Очищаем существующую историю ходов
            LS.save('cf_turns', []);
            localStorage.setItem('cf_turn_number', '1');
            
            // Создаем 10 реалистичных ходов с операциями
            const turns = [];
            
            // Получаем текущий баланс из состояния
            const currentState = getMoveState();
            let currentBalance = Math.round(currentState.balance || 0);
            let currentMonthly = 3940; // Начальный ежемесячный поток (3800+140)
            
            // Массив типов операций для разнообразия
            const operationTypes = [
              'Покупка ALFA', 'Продажа BETA', 'Инвестиция в недвижимость',
              'Партнерская сделка', 'Корректировка баланса', 'Дополнительный доход',
              'Комиссия партнеру', 'Возврат инвестиций', 'Погашение кредита'
            ];
        
        for (let turn = 1; turn <= 10; turn++) {
          const dice = Math.floor(Math.random() * 12) + 1;
          const cardChoice = Math.random() > 0.3; // 70% вероятность взять карточку
          const cashflowDone = Math.random() > 0.2; // 80% вероятность получить денежный поток
          const creditTaken = Math.random() > 0.8; // 20% вероятность взять кредит
          
          // Случайные изменения баланса
          let balanceChange = 0;
          const events = [];
          const operations = []; // Массив операций для хода
          
          // Если взял карточку - возможна покупка
          if (cardChoice && Math.random() > 0.5) {
            const purchaseAmount = Math.floor(Math.random() * 3000) + 1000;
            balanceChange -= purchaseAmount;
            events.push({ time: Date.now() + turn, delta: -purchaseAmount, desc: 'Покупка акций' });
            
            // Добавляем операцию
            operations.push({
              time: Date.now() + turn,
              timeFormatted: new Date(Date.now() + turn * 1000).toLocaleString(),
              type: 'Покупка',
              desc: `Покупка акций на сумму ${purchaseAmount}$`,
              delta: -purchaseAmount
            });
          }
          
          // Если получил денежный поток
          if (cashflowDone) {
            balanceChange += currentMonthly;
            events.push({ time: Date.now() + turn, delta: currentMonthly, desc: 'Денежный поток' });
          }
          
          // Если взял кредит
          if (creditTaken) {
            const creditAmount = Math.floor(Math.random() * 8000) + 3000;
            balanceChange += creditAmount;
            events.push({ time: Date.now() + turn, delta: creditAmount, desc: 'Кредит получен' });
            
            // Добавляем операцию
            operations.push({
              time: Date.now() + turn,
              timeFormatted: new Date(Date.now() + turn * 1000).toLocaleString(),
              type: 'Кредит',
              desc: `Получен кредит ${creditAmount}$`,
              delta: creditAmount
            });
          }
          
          // Случайные дополнительные операции (2-4 операции на ход)
          const numOperations = Math.floor(Math.random() * 3) + 2;
          for (let op = 0; op < numOperations; op++) {
            const operationType = operationTypes[Math.floor(Math.random() * operationTypes.length)];
            let opDelta = 0;
            let opDesc = '';
            
            switch(operationType) {
              case 'Покупка ALFA':
                opDelta = -(Math.floor(Math.random() * 2000) + 500);
                opDesc = `Покупка ALFA ${Math.abs(opDelta)}$`;
                break;
              case 'Продажа BETA':
                opDelta = Math.floor(Math.random() * 1500) + 300;
                opDesc = `Продажа BETA +${opDelta}$`;
                break;
              case 'Инвестиция в недвижимость':
                opDelta = -(Math.floor(Math.random() * 10000) + 3000);
                opDesc = `Инвестиция в недвижимость ${Math.abs(opDelta)}$`;
                break;
              case 'Партнерская сделка':
                opDelta = -(Math.floor(Math.random() * 1500) + 500);
                opDesc = `Партнерская сделка ${Math.abs(opDelta)}$`;
                break;
              case 'Корректировка баланса':
                opDelta = Math.floor(Math.random() * 800) - 400;
                opDesc = `Корректировка ${opDelta >= 0 ? '+' : ''}${opDelta}$`;
                break;
              case 'Дополнительный доход':
                opDelta = Math.floor(Math.random() * 600) + 150;
                opDesc = `Доп. доход +${opDelta}$`;
                break;
              case 'Комиссия партнеру':
                opDelta = Math.floor(Math.random() * 200) + 50;
                opDesc = `Комиссия партнеру +${opDelta}$`;
                break;
              case 'Возврат инвестиций':
                opDelta = Math.floor(Math.random() * 800) + 300;
                opDesc = `Возврат инвестиций +${opDelta}$`;
                break;
              case 'Погашение кредита':
                opDelta = -(Math.floor(Math.random() * 400) + 100);
                opDesc = `Погашение кредита ${Math.abs(opDelta)}$`;
                break;
            }
            
            balanceChange += opDelta;
            
            // Добавляем операцию
            operations.push({
              time: Date.now() + turn + op * 100,
              timeFormatted: new Date(Date.now() + turn * 1000 + op * 100).toLocaleString(),
              type: operationType.split(' ')[0], // Берем первое слово как тип
              desc: opDesc,
              delta: opDelta
            });
          }
          
          // Обновляем баланс
          currentBalance = currentBalance + balanceChange;
          
          // Рассчитываем капитал для этого хода (без учета погашений)
          const capital = currentBalance + computeCapitalWithoutPayoff().invested;
          
          // Создаем запись хода
          const turnRecord = {
            num: turn,
            dice: dice,
            cardChoice: cardChoice,
            card: cardChoice ? (Math.random() > 0.5 ? 'Сделка' : 'Всячина') : null,
            cashflowDone: cashflowDone,
            monthly: currentMonthly,
            creditTaken: creditTaken,
            credit: creditTaken ? `оформлен` : null,
            balance: currentBalance,
            capital: capital,
            balanceChange: balanceChange,
            comment: turn % 3 === 0 ? `Комментарий к ходу ${turn}` : '',
            events: events,
            operations: operations, // Добавляем операции
            time: Date.now() + turn * 1000,
            timeFormatted: new Date(Date.now() + turn * 1000).toLocaleString(),
            post: false
          };
          
          turns.unshift(turnRecord); // Добавляем в начало (новые сверху)
          
          // Создаем запись "После хода" с итоговым балансом
          const postCapital = currentBalance + computeCapitalWithoutPayoff().invested;
          const postRecord = {
            num: turn,
            balance: currentBalance,
            capital: postCapital,
            comment: turn % 4 === 0 ? `Комментарий после хода ${turn}` : '',
            events: [],
            operations: [], // Пустые операции для "После хода"
            time: Date.now() + turn * 1000 + 500,
            timeFormatted: new Date(Date.now() + turn * 1000 + 500).toLocaleString(),
            post: true,
            skip: false
          };
          
          turns.unshift(postRecord);
        }
        
        // Сохраняем историю ходов
        LS.save('cf_turns', turns);
        localStorage.setItem('cf_turn_number', '11'); // Следующий ход будет 11
        
        // Обновляем отображение
        try { renderTurnsHistory(); } catch {}
        try { renderBalanceChart(); } catch {}
        
      } catch (e) {
        console.warn('Ошибка при создании тестовых ходов:', e);
      }
    }, 400);

        showToast('Тест 2 данные загружены (включая 10 ходов с операциями)');
        if (currentTabId) {
          try { setActive(currentTabId); } catch {}
        }
        
        // Принудительно восстанавливаем кнопки звука после загрузки тестовых данных
        setTimeout(() => {
          try {
            const holder = document.getElementById('timerSoundsHolder');
            if (!holder || !document.contains(holder)) {
              console.log('Восстанавливаем кнопки звука...');
              // Создаем кнопки заново, если они были удалены
              const alarmButtons = document.getElementById('alarmButtonsRow');
              if (alarmButtons) {
                const newHolder = document.createElement('div');
                newHolder.id = 'timerSoundsHolder';
                newHolder.setAttribute('data-static', 'true');
                newHolder.setAttribute('data-protected', 'true');
                newHolder.style.cssText = 'margin:10px 0 0 0;padding:10px;background:#fff;border:1px solid #e5e7eb;border-radius:8px;max-width:1000px;';
                newHolder.innerHTML = `
                  <div style="display:flex;flex-wrap:wrap;gap:12px;align-items:flex-end">
                    <div style="display:flex;align-items:center;gap:6px">
                      <label style="font-size:13px;color:#666">Старт</label>
                      <select id="timerStartSound" data-protected="true" style="padding:4px 6px;font-size:13px">
                        <option value="playBong">Гонг</option>
                        <option value="playBeep">Бип</option>
                        <option value="playSound1">Тревога 1</option>
                        <option value="playSound2">Тревога 2</option>
                        <option value="playSound3">Тревога 3</option>
                        <option value="playSound4">Тревога 4</option>
                        <option value="playSound5">Тревога 5</option>
                        <option value="playSound6">Тревога 6</option>
                        <option value="playSound7">Тревога 7</option>
                        <option value="playSound8">Тревога 8</option>
                        <option value="playSound9">Тревога 9</option>
                        <option value="playSound10">Тревога 10</option>
                      </select>
                      <button class="btn" id="testStartBtn_global" data-protected="true" style="padding:4px 8px;font-size:13px">Тест старт</button>
                    </div>
                    <div style="display:flex;align-items:center;gap:6px">
                      <label style="font-size:13px;color:#666">15 сек</label>
                      <select id="timer15Sound" data-protected="true" style="padding:4px 6px;font-size:13px">
                        <option value="playBong">Гонг</option>
                        <option value="playBeep">Бип</option>
                        <option value="playSound1">Тревога 1</option>
                        <option value="playSound2">Тревога 2</option>
                        <option value="playSound3">Тревога 3</option>
                        <option value="playSound4">Тревога 4</option>
                        <option value="playSound5">Тревога 5</option>
                        <option value="playSound6">Тревога 6</option>
                        <option value="playSound7">Тревога 7</option>
                        <option value="playSound8">Тревога 8</option>
                        <option value="playSound9">Тревога 9</option>
                        <option value="playSound10">Тревога 10</option>
                      </select>
                      <button class="btn" id="test15Btn_global" data-protected="true" style="padding:4px 8px;font-size:13px">Тест 15с</button>
                    </div>
                    <div style="display:flex;align-items:center;gap:6px">
                      <label style="font-size:13px;color:#666">7 сек</label>
                      <select id="timer7Sound" data-protected="true" style="padding:4px 6px;font-size:13px">
                        <option value="playBong">Гонг</option>
                        <option value="playBeep">Бип</option>
                        <option value="playSound1">Тревога 1</option>
                        <option value="playSound2">Тревога 2</option>
                        <option value="playSound3">Тревога 3</option>
                        <option value="playSound4">Тревога 4</option>
                        <option value="playSound5">Тревога 5</option>
                        <option value="playSound6">Тревога 6</option>
                        <option value="playSound7">Тревога 7</option>
                        <option value="playSound8">Тревога 8</option>
                        <option value="playSound9">Тревога 9</option>
                        <option value="playSound10">Тревога 10</option>
                      </select>
                      <button class="btn" id="test7Btn_global" data-protected="true" style="padding:4px 8px;font-size:13px">Тест 7с</button>
                    </div>
                    <div style="display:flex;align-items:center;gap:6px">
                      <label style="font-size:13px;color:#666">3 сек</label>
                      <select id="timer3Sound" data-protected="true" style="padding:4px 6px;font-size:13px">
                        <option value="playBong">Гонг</option>
                        <option value="playBeep">Бип</option>
                        <option value="playSound1">Тревога 1</option>
                        <option value="playSound2">Тревога 2</option>
                        <option value="playSound3">Тревога 3</option>
                        <option value="playSound4">Тревога 4</option>
                        <option value="playSound5">Тревога 5</option>
                        <option value="playSound6">Тревога 6</option>
                        <option value="playSound7">Тревога 7</option>
                        <option value="playSound8">Тревога 8</option>
                        <option value="playSound9">Тревога 9</option>
                        <option value="playSound10">Тревога 10</option>
                      </select>
                      <button class="btn" id="test3Btn_global" data-protected="true" style="padding:4px 8px;font-size:13px">Тест 3с</button>
                    </div>
                    <div>
                      <button class="btn" id="timerSoundsSaveBtn_global" data-protected="true" style="padding:4px 10px;font-size:13px">Сохранить</button>
                    </div>
                  </div>
                `;
                alarmButtons.parentNode.insertBefore(newHolder, alarmButtons.nextSibling);
                // Инициализируем обработчики событий
                initTimerSoundControls();
              }
            }
          } catch (e) {
            console.error('Ошибка при восстановлении кнопок звука:', e);
          }
        }, 500);
      }catch(e){ 
        console.error('Ошибка в Тест 2:', e);
        alert('Ошибка при загрузке тестовых данных: ' + e.message); 
      } 
    }
    function testGong(){ try{ const fn = (typeof playBong==='function') ? playBong : null; if (fn) fn(); else alert('Звук недоступен'); }catch(e){ alert('Звук недоступен'); } }
    function testBeep(){ try{ const fn = (typeof playBeep==='function') ? playBeep : null; if (fn) fn(); else alert('Звук 2 недоступен'); }catch(e){ alert('Звук 2 недоступен'); } }
    function testSound1(){ try{ const fn = (typeof playSound1==='function') ? playSound1 : null; if (fn) fn(); else alert('Звук 1 недоступен'); }catch(e){ alert('Звук 1 недоступен'); } }
    function testSound2(){ try{ const fn = (typeof playSound2==='function') ? playSound2 : null; if (fn) fn(); else alert('Звук 2 недоступен'); }catch(e){ alert('Звук 2 недоступен'); } }
    function testSound3(){ try{ const fn = (typeof playSound3==='function') ? playSound3 : null; if (fn) fn(); else alert('Звук 3 недоступен'); }catch(e){ alert('Звук 3 недоступен'); } }
    function testSound4(){ try{ const fn = (typeof playSound4==='function') ? playSound4 : null; if (fn) fn(); else alert('Звук 4 недоступен'); }catch(e){ alert('Звук 4 недоступен'); } }
    function testSound5(){ try{ const fn = (typeof playSound5==='function') ? playSound5 : null; if (fn) fn(); else alert('Звук 5 недоступен'); }catch(e){ alert('Звук 5 недоступен'); } }
    function testSound6(){ try{ const fn = (typeof playSound6==='function') ? playSound6 : null; if (fn) fn(); else alert('Звук 6 недоступен'); }catch(e){ alert('Звук 6 недоступен'); } }
    function testSound7(){ try{ const fn = (typeof playSound7==='function') ? playSound7 : null; if (fn) fn(); else alert('Звук 7 недоступен'); }catch(e){ alert('Звук 7 недоступен'); } }
    function testSound8(){ try{ const fn = (typeof playSound8==='function') ? playSound8 : null; if (fn) fn(); else alert('Звук 8 недоступен'); }catch(e){ alert('Звук 8 недоступен'); } }
    function testSound9(){ try{ const fn = (typeof playSound9==='function') ? playSound9 : null; if (fn) fn(); else alert('Звук 9 недоступен'); }catch(e){ alert('Звук 9 недоступен'); } }
    function testSound10(){ try{ const fn = (typeof playSound10==='function') ? playSound10 : null; if (fn) fn(); else alert('Звук 10 недоступен'); }catch(e){ alert('Звук 10 недоступен'); } }
    function testDoubleCashflow(){ 
      try{ 
        // Переключаемся на вкладку "Ходы"
        setActive('tabMoves');
        
        // Устанавливаем состояние для тестирования двойного денежного потока
        const moveState = getMoveState();
        moveState.checksPassed = 2; // Устанавливаем 2 пройденных чека
        moveState.dice = 6; // Устанавливаем бросок кубика
        moveState.cardChoice = true; // Устанавливаем выбор карточки
        setMoveState(moveState);
        
        // Обновляем отображение
        renderMoves();
        
        showToast('Двойной денежный поток активирован! Перейдите в раздел "Ходы"');
      }catch(e){ 
        alert('Ошибка при тестировании двойного денежного потока: ' + e.message); 
      } 
    }
    (function(){
      const btn2 = document.getElementById('seedTestBtn2');
      if (!btn2) return;
      btn2.addEventListener('click', ()=>{
        const currentTab = document.querySelector('nav button.active, .bottom-nav button.active');
        const currentTabId = currentTab ? currentTab.getAttribute('data-tab') || currentTab.id : null;
        pushUndo();
        // Очистка текущего состояния
        participants = [];
        participantCom = {};
        holdings = {};
        buyDeals = [];
        sellDealCom = {};
        sellCardCom = {};
        sellCardRecipient = {};
        sellFactors = {};
        burnedSymbols = {};
        // Ведомость
        ledgerIncomes = [];
        ledgerExpenses = [];
        localStorage.removeItem('cf_buyTemp');
        LS.save('cf_history', []);

        // Участники
        const names = ['Alex','Bora','Chen','Dana','Ivan'];
        names.forEach(n=>{ participants.push(n); participantCom[n]=20; });
        // Разные проценты участия
        participantCom['Alex'] = 18;
        participantCom['Bora'] = 20; // владелец — всё равно 0 при расчёте комиссии в UI
        participantCom['Chen'] = 22;
        participantCom['Dana'] = 15;
        participantCom['Ivan'] = 25;

        // Владелец — второй
        localStorage.setItem('cf_owner', participants[1]);
        saveAll();

        // Хелпер добавления покупок с фиксированием оригинальных сумм и по участникам
        function addBuy(sym, price, contributions){
          contributions.forEach(([idx, sum])=>{
            const p = participants[idx-1];
            if(!holdings[p]) holdings[p] = {};
            if(!holdings[p][sym]) holdings[p][sym] = {qty:0, avgCost:0};
            const h = holdings[p][sym];
            const qty = sum / price;
            const totalCost = h.avgCost * h.qty + sum;
            h.qty += qty;
            h.avgCost = totalCost / h.qty;
            if (!buySumByParticipant[sym]) buySumByParticipant[sym] = {};
            buySumByParticipant[sym][p] = (buySumByParticipant[sym][p]||0) + sum;
          });
          let total = contributions.reduce((a, c)=>a + c[1], 0);
          if (!(sym in buySumOriginal)) buySumOriginal[sym] = 0;
          buySumOriginal[sym] += total;
          LS.save('cf_buySumOriginal', buySumOriginal);
          LS.save('cf_buySumByParticipant', buySumByParticipant);
        }

        // Покупки: другие тикеры и суммы
        addBuy('ALFA', 5, [[1,4000],[2,3000]]);
        // Списываем только сумму владельца (Bora) с баланса
        applyBalanceDelta(-3000, 'Тест 2 — покупка ALFA (Bora)');
        
        addBuy('BETA', 8, [[3,5000],[4,2000]]);
        // BETA покупают Dana и Ivan, владелец не участвует, поэтому не списываем
        
        saveAll();
        
        // Устанавливаем метки покупок с номерами и ходами
        try {
          const buyTurnMap = {};
          buyTurnMap['ALFA'] = '№1, Ход 4';
          buyTurnMap['BETA'] = '№2, Ход 7';
          LS.save('cf_buyTurnBySymbol', buyTurnMap);
        } catch {}

        // Цены продажи
        const prices = loadSellPrices();
        prices['ALFA'] = 7;   // прибыльная
        prices['BETA'] = 6;   // убыточная относительно средней
        localStorage.setItem('cf_sellPrices', JSON.stringify(prices));

        // Посредник по ALFA: Dana получает 15% у всех, по BETA: Ivan 10%
        sellCardCom['ALFA'] = sellCardCom['ALFA'] || {};
        sellCardRecipient['ALFA'] = sellCardRecipient['ALFA'] || {};
        sellCardCom['BETA'] = sellCardCom['BETA'] || {};
        sellCardRecipient['BETA'] = sellCardRecipient['BETA'] || {};
        const mediatorA = 'Dana';
        const mediatorB = 'Ivan';
        participants.forEach(pName => {
          if (holdings[pName]?.['ALFA']?.qty>0) {
            sellCardCom['ALFA'][pName] = 15;
            sellCardRecipient['ALFA'][pName] = mediatorA;
          }
          if (holdings[pName]?.['BETA']?.qty>0) {
            sellCardCom['BETA'][pName] = 10;
            sellCardRecipient['BETA'][pName] = mediatorB;
          }
        });
        LS.save('cf_sellCardCom', sellCardCom);
        LS.save('cf_sellCardRecipient', sellCardRecipient);

        // Партнеры — 2 сделки с разными параметрами
        partnerRows = [
          { id: Date.now()+1, participant: participants[1], symbol: 'PRTN-A', sum: 1500, buy: 4, sell: 9, com: 15, paid: false, paidAmount: 0, _prevPaidAmount: 0, _prevSumBuy: 1500 },
          { id: Date.now()+2, participant: participants[3], symbol: 'PRTN-B', sum: 3000, buy: 6, sell: 5, com: 25, paid: false, paidAmount: 0, _prevPaidAmount: 0, _prevSumBuy: 3000 }
        ];
        LS.save('cf_partnerRows', partnerRows);
        
        // Списываем только сумму владельца (Bora) с баланса
        applyBalanceDelta(-1500, 'Тест 2 — партнерская сделка PRTN-A (Bora)');
        // PRTN-B покупает Ivan, владелец не участвует, поэтому не списываем

        // Ведомость — доходы (по требованию: оставить только ЗП, но добавить Дом 2/1 140 / 5000)
        ledgerIncomes = [
          { id: Date.now()+10, category:'Зарплата', name:'', amount:3800 },
          { id: Date.now()+11, category:'Недвижимость', name:'Дом 2/1', amount:140, invest:5000 }
        ];
        LS.save('cf_ledgerIncomes', ledgerIncomes);

        // Ведомость — расходы (по вашему списку)
        ledgerExpenses = [
          { id: Date.now()+20, category:'Налоги', amount:750, payoff:0, closable:false, closed:false, children:0 },
          { id: Date.now()+21, category:'Ипотека', amount:600, payoff:43000, closable:true, closed:false, children:0 },
          { id: Date.now()+22, category:'Образование', amount:0, payoff:0, closable:true, closed:false, children:0 },
          { id: Date.now()+23, category:'Автомобиль', amount:200, payoff:5500, closable:true, closed:false, children:0 },
          { id: Date.now()+24, category:'Кредитные карты', amount:100, payoff:3500, closable:true, closed:false, children:0 },
          { id: Date.now()+25, category:'Розничные расходы', amount:50, payoff:2000, closable:true, closed:false, children:0 },
          { id: Date.now()+26, category:'Другие', amount:700, payoff:0, closable:false, closed:false, children:0 },
          { id: Date.now()+27, category:'Ребенок', amount:250, payoff:0, closable:true, closed:false, children:0 },
          { id: Date.now()+28, category:'Банк. кредит', amount:0, payoff:0, closable:true, closed:false, children:0 }
        ];
        LS.save('cf_ledgerExpenses', ledgerExpenses);
        
        // Корректируем баланс на основе доходов и расходов
        // Доходы: +3800
        // Расходы: -750 - 600 - 200 - 100 - 50 - 700 - 250 = -2650
        // Итого: +3800 - 2650 = +1150
        applyBalanceDelta(3800, 'Тест 2 — доходы (Зарплата)');
        applyBalanceDelta(-2650, 'Тест 2 — расходы (все категории)');

        // Калькулятор Кэфа Расхода — другие коэффициенты (по ежемесячному доходу)
        try {
          const ownerName = participants[1];
          const expSeed = {};
          expSeed[ownerName] = { monthly: 900 };
          expSeed['Alex'] = { monthly: 450 };  // x0.50
          expSeed['Chen'] = { monthly: 1350 }; // x1.50
          expSeed['Dana'] = { monthly: 700 }; // ~x0.78
          expSeed['Ivan'] = { monthly: 1100 }; // ~x1.22
          expenseCoef = expSeed;
          LS.save('cf_expenseCoef', expenseCoef);
          try { renderExpenseCoef(); } catch {}
        } catch {}

        renderParticipants();
        renderBuy();
        renderSell();
        renderPartners();
        try { renderLedger(); } catch {}

        // Инициализируем калькулятор выгодной покупки тестовыми значениями
        setTimeout(() => {
          const buyAmount = document.getElementById('buyAmount');
          const monthlyIncome = document.getElementById('monthlyIncome');
          const partnerCommission = document.getElementById('partnerCommission');
          if (buyAmount) {
            buyAmount.value = '12000';
            buyAmount.dispatchEvent(new Event('input', { bubbles: true }));
          }
          if (monthlyIncome) {
            monthlyIncome.value = '480';
            monthlyIncome.dispatchEvent(new Event('input', { bubbles: true }));
          }
          if (partnerCommission) {
            partnerCommission.value = '600';
            partnerCommission.dispatchEvent(new Event('input', { bubbles: true }));
          }
          try { calculateProfitableBuy(); } catch {}
        }, 200);
        
        // Добавляем стартовые данные в историю ходов для теста 2
        setTimeout(() => {
          try {
            const turns = getTurns();
            const startRecord = turns.find(tr => tr.num === 0 && tr.post === true);
            if (!startRecord) {
              const st = getMoveState();
              const capital = Math.round(st.balance||0) + computeCapitalFromCurrentState().invested + computeCapitalFromCurrentState().payoff;
              // Убираем автоматическое добавление стартовых данных
            }
          } catch {}
        }, 400);

        // Заполняем калькулятор КПД данными как в Тест
        setTimeout(() => {
          try {
            const kpdRows = document.querySelectorAll('.kpdRows .row');
            if (kpdRows.length >= 5) {
              // 75000 1500
              kpdRows[0].querySelector('.kpdInvest').value = '75000';
              kpdRows[0].querySelector('.kpdPassive').value = '1500';
              kpdRows[0].querySelector('.kpdCheck').checked = true;
              kpdRows[0].querySelector('.kpdInvest').dispatchEvent(new Event('input', { bubbles: true }));
              kpdRows[0].querySelector('.kpdPassive').dispatchEvent(new Event('input', { bubbles: true }));

              // 40000 500
              kpdRows[1].querySelector('.kpdInvest').value = '40000';
              kpdRows[1].querySelector('.kpdPassive').value = '500';
              kpdRows[1].querySelector('.kpdCheck').checked = true;
              kpdRows[1].querySelector('.kpdInvest').dispatchEvent(new Event('input', { bubbles: true }));
              kpdRows[1].querySelector('.kpdPassive').dispatchEvent(new Event('input', { bubbles: true }));

              // 5000 140
              kpdRows[2].querySelector('.kpdInvest').value = '5000';
              kpdRows[2].querySelector('.kpdPassive').value = '140';
              kpdRows[2].querySelector('.kpdCheck').checked = true;
              kpdRows[2].querySelector('.kpdInvest').dispatchEvent(new Event('input', { bubbles: true }));
              kpdRows[2].querySelector('.kpdPassive').dispatchEvent(new Event('input', { bubbles: true }));

              // 1200 10
              kpdRows[3].querySelector('.kpdInvest').value = '1200';
              kpdRows[3].querySelector('.kpdPassive').value = '10';
              kpdRows[3].querySelector('.kpdCheck').checked = true;
              kpdRows[3].querySelector('.kpdInvest').dispatchEvent(new Event('input', { bubbles: true }));
              kpdRows[3].querySelector('.kpdPassive').dispatchEvent(new Event('input', { bubbles: true }));

              // 100000 2000
              kpdRows[4].querySelector('.kpdInvest').value = '100000';
              kpdRows[4].querySelector('.kpdPassive').value = '2000';
              kpdRows[4].querySelector('.kpdCheck').checked = true;
              kpdRows[4].querySelector('.kpdInvest').dispatchEvent(new Event('input', { bubbles: true }));
              kpdRows[4].querySelector('.kpdPassive').dispatchEvent(new Event('input', { bubbles: true }));

              try { updateKPD(); } catch {}
            }
          } catch {}
        }, 350);



        document.getElementById('seedResult').textContent = 'Тест 2 данные загружены';
        if (currentTabId) {
          try { setActive(currentTabId); } catch {}
        }
      });
    })();
  </script>
<div id="toast" class="toast"></div>
<div id="footerDev" style="position:fixed;right:12px;bottom:8px;text-align:right;color:#aaa;font-size:16px;z-index:10">
  <div class="desktop-signature" style="margin-bottom:8px;font-size:14px;color:#666;">
    CashFlow Helper от <a href="https://instagram.com/dimalead" target="_blank" style="color:#4a90e2;text-decoration:underline;">DimaLead</a>
  </div>
  <div style="margin-top:4px;font-size:12px;color:#888;">
    <span onclick="showHotkeys()" style="cursor:pointer;text-decoration:underline;">Горячие клавиши</span>
  </div>
</div>

<!-- Модальное окно с горячими клавишами -->
<div id="hotkeysModal" class="modal-backdrop" style="display:none;">
  <div class="modal">
    <h3>Горячие клавиши</h3>
    <div style="font-size:14px;line-height:1.6;">
      <div><strong>Цифры:</strong> 1-5 - переключение вкладок</div>
      <div><strong>Буквы:</strong> G, B, S, P, H - быстрый доступ</div>
      <div><strong>Стрелки:</strong> ← → - переключение вкладок</div>
      <div><strong>F5/Ctrl+R:</strong> заблокировано</div>
    </div>
    <div class="actions">
      <button class="btn" onclick="hideHotkeys()">Закрыть</button>
    </div>
  </div>
</div>
<script>
// Улучшенная обработка ошибок localStorage
const LS = {
  load: (k, d) => {
    try {
      const item = localStorage.getItem(k);
      if (item === null || item === undefined) return d;
      return JSON.parse(item) ?? d;
    } catch (error) {
      console.warn('Ошибка загрузки из localStorage:', k, error);
      return d;
    }
  },
  save: (k, v) => {
    try {
      localStorage.setItem(k, JSON.stringify(v));
    } catch (error) {
      console.error('Ошибка сохранения в localStorage:', k, error);
      showError('Ошибка сохранения данных: ' + error.message);
    }
  }
};

// Функции для обработки ошибок
function showError(message) {
  const container = document.getElementById('errorContainer');
  const text = document.getElementById('errorText');
  if (container && text) {
    text.textContent = message;
    container.style.display = 'block';
  }
  console.error('CashFlow Error:', message);
}

function clearError() {
  const container = document.getElementById('errorContainer');
  if (container) {
    container.style.display = 'none';
  }
}

function retryLoad() {
  clearError();
  try {
    location.reload();
  } catch (error) {
    showError('Не удалось перезагрузить страницу: ' + error.message);
  }
}

// Функции для показа горячих клавиш
function showHotkeys() {
  const modal = document.getElementById('hotkeysModal');
  if (modal) modal.style.display = 'flex';
}

function hideHotkeys() {
  const modal = document.getElementById('hotkeysModal');
  if (modal) modal.style.display = 'none';
}

// Закрытие модального окна по клику вне его
document.addEventListener('click', function(e) {
  const modal = document.getElementById('hotkeysModal');
  if (modal && e.target === modal) {
    hideHotkeys();
  }
});
// Проверка доступности localStorage
function checkLocalStorage() {
  try {
    const test = '__test__';
    localStorage.setItem(test, test);
    localStorage.removeItem(test);
    return true;
  } catch (error) {
    showError('localStorage недоступен. Возможно, включен режим инкогнито или отключены cookies.');
    return false;
  }
}
const STATE_VERSION = 1;
// Масштаб для ЭфКПК: на сколько условных единиц инвестиций нормируем (для удобной шкалы процентов)
const EFKPK_SCALE = 1000; // можно менять на 10000 при желании

// Инициализация с проверкой ошибок
(function() {
  try {
    // Проверяем доступность localStorage
    if (!checkLocalStorage()) {
      return;
    }
    
    // Устанавливаем версию состояния
    try { 
      localStorage.setItem('cf_stateVersion', String(STATE_VERSION)); 
    } catch (error) {
      console.warn('Не удалось установить версию состояния:', error);
    }
    
    // Инициализируем данные с обработкой ошибок
    let participants = LS.load('cf_participants', []);
    if (!Array.isArray(participants)) {
      console.warn('Некорректные данные участников, сбрасываем');
      participants = [];
    }
    
    let participantCom = LS.load('cf_participantCom', {});
    if (typeof participantCom !== 'object' || participantCom === null) {
      console.warn('Некорректные данные комиссий, сбрасываем');
      participantCom = {};
    }
    
    let holdings = LS.load('cf_holdings', {});
    if (typeof holdings !== 'object' || holdings === null) {
      console.warn('Некорректные данные акций, сбрасываем');
      holdings = {};
    }
    
    // Остальные переменные с проверкой
    let lastBuy = {symbol:'', price:'', by:{}};
    let sellDealCom = LS.load('cf_sellDealCom', {});
    if (typeof sellDealCom !== 'object' || sellDealCom === null) sellDealCom = {};
    
    let sellCardCom = LS.load('cf_sellCardCom', {});
    if (typeof sellCardCom !== 'object' || sellCardCom === null) sellCardCom = {};
    
    let sellCardRecipient = LS.load('cf_sellCardRecipient', {});
    if (typeof sellCardRecipient !== 'object' || sellCardRecipient === null) sellCardRecipient = {};
    
    let sellCardDefaultCom = LS.load('cf_sellCardDefaultCom', {});
    if (typeof sellCardDefaultCom !== 'object' || sellCardDefaultCom === null) sellCardDefaultCom = {};
    
    let sellCardDefaultRecipient = LS.load('cf_sellCardDefaultRecipient', {});
    if (typeof sellCardDefaultRecipient !== 'object' || sellCardDefaultRecipient === null) sellCardDefaultRecipient = {};
    
    let sellFactors = LS.load('cf_sellFactors', {});
    if (typeof sellFactors !== 'object' || sellFactors === null) sellFactors = {};
    
    let burnedSymbols = LS.load('cf_burnedSymbols', {});
    if (typeof burnedSymbols !== 'object' || burnedSymbols === null) burnedSymbols = {};
    
    let buySumOriginal = LS.load('cf_buySumOriginal', {});
    if (typeof buySumOriginal !== 'object' || buySumOriginal === null) buySumOriginal = {};
    
    let buySumByParticipant = LS.load('cf_buySumByParticipant', {});
    if (typeof buySumByParticipant !== 'object' || buySumByParticipant === null) buySumByParticipant = {};
    
    // Ведомость
    let ledgerIncomes = LS.load('cf_ledgerIncomes', []);
    if (!Array.isArray(ledgerIncomes)) ledgerIncomes = [];
    
    let ledgerExpenses = LS.load('cf_ledgerExpenses', []);
    if (!Array.isArray(ledgerExpenses)) ledgerExpenses = [];
    
    // Партнеры
    let partnerRows = LS.load('cf_partnerRows', []);
    if (!Array.isArray(partnerRows)) partnerRows = [];
    
    // Шаблоны
    let buySymbolTpls = LS.load('cf_buySymbolTpls', []);
    if (!Array.isArray(buySymbolTpls)) buySymbolTpls = [];
    
    let buyPriceTpls = LS.load('cf_buyPriceTpls', []);
    if (!Array.isArray(buyPriceTpls)) buyPriceTpls = [];
    
    let sellSymbolTpls = LS.load('cf_sellSymbolTpls', []);
    if (!Array.isArray(sellSymbolTpls)) sellSymbolTpls = [];
    
    let sellPriceTpls = LS.load('cf_sellPriceTpls', []);
    if (!Array.isArray(sellPriceTpls)) sellPriceTpls = [];
    
    // Сделки покупки
    let buyDeals = LS.load('cf_buyDeals', []);
    if (!Array.isArray(buyDeals)) buyDeals = [];
    
    // Владелец
    if (participants.length && !localStorage.getItem('cf_owner')) {
      try {
        localStorage.setItem('cf_owner', participants[0]);
      } catch (error) {
        console.warn('Не удалось установить владельца:', error);
      }
    }
    
    console.log('CashFlow успешно инициализирован');
    
  } catch (error) {
    showError('Критическая ошибка инициализации: ' + error.message);
    console.error('Ошибка инициализации CashFlow:', error);
  }
})();

// Глобальные переменные (для совместимости)
let participants = LS.load('cf_participants', []);
let participantCom=LS.load('cf_participantCom',{});
let holdings=LS.load('cf_holdings',{}); // {participant:{symbol:{qty,avgCost}}}
let lastBuy={symbol:'',price:'',by:{}};
let sellDealCom = LS.load('cf_sellDealCom', {}); // {symbol:{participant: percent}}
// Доп. процент для игрока, вытянувшего карточку продажи (per symbol + participant)
let sellCardCom = LS.load('cf_sellCardCom', {});
// Получатель процента карточки
let sellCardRecipient = LS.load('cf_sellCardRecipient', {}); // {symbol:{participant: recipientName}}
// Значения посредника по умолчанию на акцию (применяются по кнопке)
let sellCardDefaultCom = LS.load('cf_sellCardDefaultCom', {}); // {symbol:number}
let sellCardDefaultRecipient = LS.load('cf_sellCardDefaultRecipient', {}); // {symbol:string}
// Коэффициенты (виртуальные) изменения количества по символу (не меняют сумму покупки)
let sellFactors = LS.load('cf_sellFactors', {}); // {symbol:number[]}
// Флаг сгорания акций по символу
let burnedSymbols = LS.load('cf_burnedSymbols', {}); // {symbol:true}
// Оригинальная сумма покупки по символу (не меняется при коэффициентах)
let buySumOriginal = LS.load('cf_buySumOriginal', {}); // {symbol:number}
// Оригинальные вложения по участнику и акции
let buySumByParticipant = LS.load('cf_buySumByParticipant', {}); // {symbol:{participant:number}}
const tabs=['tabParticipants','tabBuy','tabSell','tabPartners','tabMoves','tabHistory'];
// Ведомость: доходы и расходы
let ledgerIncomes = LS.load('cf_ledgerIncomes', []); // [{id,category,name,amount,invest}]
let ledgerExpenses = LS.load('cf_ledgerExpenses', []); // [{id,category,amount,payoff,closable,closed,children}]
const expenseNonClosable = new Set(['Налоги','Другие']);
const expenseClosable = new Set(['Ипотека','Автомобиль','Образование','Кредитные карты','Розничные расходы','Ребенок','Банк. кредит']);
// Владелец по умолчанию — первый участник, если не выбран явно
if (participants.length && !localStorage.getItem('cf_owner')) {
  localStorage.setItem('cf_owner', participants[0]);
}
    // Партнеры: динамические строки, профит на новой строке, чекбокс выплачено
    let partnerRows = (() => {
      let d = LS.load('cf_partnerRows', [{id:Date.now(),symbol:'',qty:'',buy:'',sell:'',com:20,paid:false,paidAmount:0,_prevPaidAmount:0}]);
      if (!Array.isArray(d)) d = [{id:Date.now(),symbol:'',qty:'',buy:'',sell:'',com:20,paid:false,paidAmount:0,_prevPaidAmount:0}];
      
      // Инициализируем _prevPaidAmount для существующих строк
      d.forEach(row => {
        if (row.paidAmount !== undefined && row._prevPaidAmount === undefined) {
          row._prevPaidAmount = parseFloat(row.paidAmount) || 0;
        }
      });
      
      return d;
    })();
function $(s){return document.querySelector(s)}
// Перемещаем блок Легкой покупки внизу раздела Ходы, сразу под "после хода"
function placeEasyBuyAtBottom(){
  try{
    const easy = document.getElementById('postTurnEasyBuy');
    const anchor = document.getElementById('postTurnAnchor');
    if (easy && anchor && anchor.parentNode){
      if (anchor.nextSibling !== easy){
        anchor.parentNode.insertBefore(easy, anchor.nextSibling);
      }
    }
  }catch{}
}
function showToast(msg, ms){const t=$('#toast');const d=(typeof ms==='number'&&ms>=0)?ms:1800;t.textContent=msg;t.classList.add('show');setTimeout(()=>t.classList.remove('show'),d);}
function fmt(n){return (!n&&n!==0)?'':(Number.isInteger(n)?n.toFixed(0):n.toFixed(2));}
// Форматирование чисел (ru-RU) с управлением дробной частью
function fmtPretty(n, digits = 2) {
  if (n === '' || n === undefined || n === null || isNaN(n)) return '';
  try {
    const nf = new Intl.NumberFormat('ru-RU', { minimumFractionDigits: digits, maximumFractionDigits: digits });
    return nf.format(Number(n));
  } catch {
    let parts = Number(n).toFixed(digits).split('.');
    parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ' ');
    if (digits === 0) return parts[0];
    return parts.join('.');
  }
}
function escapeHtml(str){
  return String(str)
    .replace(/&/g,'&amp;')
    .replace(/</g,'&lt;')
    .replace(/>/g,'&gt;')
    .replace(/"/g,'&quot;')
    .replace(/'/g,'&#39;');
}
// Подсчет текущих итогов для коэффициента
function computeTotals(){
  try{
    const incomeMonthly = (r)=>{
      if (!r || typeof r !== 'object') return 0; // Защита от некорректных данных
      // Исключаем заложенные доходы из пассива и общего дохода
      if (r && r.pledged) return 0;
      
      if ((r.category||'')==='Дивиденды'){
        const price = parseFloat(r.price)||0;
        const invest = parseFloat(r.invest)||0;
        const perUnit = parseFloat(r.amount)||0; // amount хранит доход за шт.
        
        // Проверяем корректность данных
        if (!isFinite(price) || !isFinite(invest) || !isFinite(perUnit)) return 0;
        
        if (price>0 && invest>0){
          const qtyFloat = invest/price;
          const isInt = Math.abs(qtyFloat - Math.round(qtyFloat)) < 1e-9;
          if (!isInt) return 0; // если не кратно цене, не засчитываем
          const qty = Math.round(qtyFloat);
          const result = perUnit * qty;
          return isFinite(result) ? result : 0;
        }
        return 0;
      }
      const result = parseFloat(r.amount)||0;
      return isFinite(result) ? result : 0;
    };
    const totalIncome = ledgerIncomes.reduce((a,r)=>a + incomeMonthly(r), 0);
    const passiveIncome = ledgerIncomes
      .filter(r=>r.category!=='Зарплата')
      .reduce((a,r)=>a + incomeMonthly(r), 0);
    const totalExpense = ledgerExpenses
      .filter(r=>!r.closed)
      .reduce((a,r)=>{
        if (!r || typeof r !== 'object') return a; // Защита от некорректных данных
        
        if(r.category==='Ребенок'){
          const perChild = parseFloat(r.amount)||0;
          const n = Math.max(0, parseInt(r.children||'0',10)||0);
          const result = perChild * n;
          return a + (isFinite(result) ? result : 0);
        }
        const result = parseFloat(r.amount)||0;
        return a + (isFinite(result) ? result : 0);
      }, 0);
    
    // Проверяем корректность итоговых значений
    const safeTotalIncome = isFinite(totalIncome) ? totalIncome : 0;
    const safePassiveIncome = isFinite(passiveIncome) ? passiveIncome : 0;
    const safeTotalExpense = isFinite(totalExpense) ? totalExpense : 0;
    const coef = safeTotalExpense>0 ? (safePassiveIncome/safeTotalExpense) : 0;
    const safeCoef = isFinite(coef) ? coef : 0;
    
    return {totalIncome: safeTotalIncome, passiveIncome: safePassiveIncome, totalExpense: safeTotalExpense, coef: safeCoef};
  } catch(e){
    return {totalIncome:0, passiveIncome:0, totalExpense:0, coef:0};
  }
}
function setActive(tabId){
  localStorage.setItem('cf_activeTab', tabId);
  const targetSectionId = tabId.replace('tab','').toLowerCase();
  
  // Обновляем верхнюю навигацию
  document.querySelectorAll('nav button[role="tab"]').forEach(b=>{
    const selected = b.id===tabId;
    b.classList.toggle('active', selected);
    b.setAttribute('aria-selected', String(selected));
    b.tabIndex = selected ? 0 : -1;
  });
  
  // Обновляем нижнюю навигацию
  document.querySelectorAll('.bottom-nav button').forEach(b=>{
    const selected = b.dataset.tab === tabId;
    b.classList.toggle('active', selected);
  });
  

  
  // Обновляем секции
  document.querySelectorAll('section[role="tabpanel"]').forEach(s=>{
    const isTarget = s.id===targetSectionId;
    s.classList.toggle('active', isTarget);
    if (isTarget) s.removeAttribute('hidden'); else s.setAttribute('hidden','');
  });
  
  // Записываем в историю ходов переключение вкладки
  const tabNames = {
    'tabParticipants': 'Главное',
    'tabBuy': 'Покупка',
    'tabSell': 'Продажа',
    'tabPartners': 'Партнеры',
    'tabMoves': 'Ходы',
    'tabHistory': 'История'
  };
  const tabName = tabNames[tabId] || tabId;
  try{ addTurnEventForCurrentTurn(0, `Переход в раздел: ${tabName}`); }catch{}
  try{ renderTurnsHistory(); }catch{}
  
  // Рендерим контент
  switch(tabId){
    case 'tabParticipants':try{renderParticipants();}catch{}break;
    case 'tabBuy':try{renderBuy();}catch{}break;
    case 'tabSell':try{renderSell();}catch{}break;
    case 'tabPartners':try{renderPartners();renderSellTemplates();updatePartnerResult();}catch{}break;
    case 'tabMoves':try{ typeof renderMoves==='function' && renderMoves(); placeEasyBuyAtBottom(); }catch{}break;
    case 'tabHistory':try{renderHistory(); renderTurnsHistory();}catch{}break;
  }
}
// Навешиваем обработчики только после определения setActive
document.querySelectorAll('nav button').forEach(b=>b.onclick=()=>setActive(b.id));

// Добавляем обработчик долгого нажатия для перемещения в начало вкладки
document.querySelectorAll('nav button, .bottom-nav button').forEach(btn => {
  let pressTimer;
  let isLongPress = false;
  
  btn.addEventListener('mousedown', () => {
    pressTimer = setTimeout(() => {
      isLongPress = true;
      // Перемещаем экран в начало вкладки
      const targetSection = btn.getAttribute('onclick')?.match(/setActive\('([^']+)'\)/)?.[1];
      if (targetSection) {
        const sectionId = targetSection.replace('tab', '').toLowerCase();
        const section = document.getElementById(sectionId);
        if (section) {
          section.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
      }
    }, 500); // 500ms для долгого нажатия
  });
  
  btn.addEventListener('mouseup', () => {
    clearTimeout(pressTimer);
    isLongPress = false;
  });
  
  btn.addEventListener('mouseleave', () => {
    clearTimeout(pressTimer);
    isLongPress = false;
  });
  
  // Для мобильных устройств
  btn.addEventListener('touchstart', () => {
    pressTimer = setTimeout(() => {
      isLongPress = true;
      const targetSection = btn.getAttribute('onclick')?.match(/setActive\('([^']+)'\)/)?.[1];
      if (targetSection) {
        const sectionId = targetSection.replace('tab', '').toLowerCase();
        const section = document.getElementById(sectionId);
        if (section) {
          section.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
      }
    }, 500);
  });
  
  btn.addEventListener('touchend', () => {
    clearTimeout(pressTimer);
    isLongPress = false;
  });
});
// Восстанавливаем вкладку только один раз при загрузке (перенесено ниже после инициализаций)

// Свайп полностью отключен
// Обработчик ошибок для предотвращения блокировки
window.addEventListener('error', function(e) {
  console.error('JavaScript ошибка:', e.error);
  showError('Произошла ошибка JavaScript: ' + (e.error ? e.error.message : 'Неизвестная ошибка'));
});

window.addEventListener('unhandledrejection', function(e) {
  console.error('Необработанная ошибка Promise:', e.reason);
  showError('Необработанная ошибка: ' + (e.reason ? e.reason.message : 'Неизвестная ошибка'));
});

window.addEventListener('beforeunload', function (e) {
  e.preventDefault();
  e.returnValue = 'Обновлять нельзя, иначе сломается';
  return 'Обновлять нельзя, иначе сломается';
});
// Блокировка F5, Ctrl+R, Cmd+R и показ toast
window.addEventListener('keydown', function(e) {
  // F5
  if (e.key === 'F5') {
    e.preventDefault();
    showToast('Обновлять нельзя, иначе сломается');
  }
  // Ctrl+R или Cmd+R
  if ((e.ctrlKey || e.metaKey) && (e.key === 'r' || e.key === 'R')) {
    e.preventDefault();
    showToast('Обновлять нельзя, иначе сломается');
  }
  // Быстрые клавиши для табов (1-5), если фокус не в поле ввода
  const tag = (e.target && e.target.tagName) || '';
  const isEditable = !!(e.target && (e.target.isContentEditable === true));
  if (!e.ctrlKey && !e.metaKey && !e.altKey && !e.shiftKey && ['INPUT','TEXTAREA','SELECT'].indexOf(tag)===-1 && !isEditable) {
    if (e.key === '1') setActive('tabParticipants');
    if (e.key === '2') setActive('tabBuy');
    if (e.key === '3') setActive('tabSell');
    if (e.key === '4') setActive('tabPartners');
    if (e.key === '5') setActive('tabHistory');
  }
  
  // Дополнительные горячие клавиши
  if (!e.ctrlKey && !e.metaKey && !e.altKey && !e.shiftKey && ['INPUT','TEXTAREA','SELECT'].indexOf(tag)===-1 && !isEditable) {
    // Стрелки влево/вправо для переключения табов
    if (e.key === 'ArrowLeft') {
      e.preventDefault();
      const current = tabs.findIndex(id => $('#'+id).classList.contains('active'));
      const prev = current > 0 ? current - 1 : tabs.length - 1;
      setActive(tabs[prev]);
    }
    if (e.key === 'ArrowRight') {
      e.preventDefault();
      const current = tabs.findIndex(id => $('#'+id).classList.contains('active'));
      const next = current < tabs.length - 1 ? current + 1 : 0;
      setActive(tabs[next]);
    }
    
    // Буквенные клавиши для быстрого доступа
    if (e.key === 'g' || e.key === 'G') setActive('tabParticipants'); // Главное
    if (e.key === 'b' || e.key === 'B') setActive('tabBuy'); // Buy
    if (e.key === 's' || e.key === 'S') setActive('tabSell'); // Sell
    if (e.key === 'p' || e.key === 'P') setActive('tabPartners'); // Partners
    if (e.key === 'h' || e.key === 'H') setActive('tabHistory'); // History
  }
});
// Участники
function renderLedger(){
  // Таблица доходов (редактируемая)
  const incTbl = document.getElementById('ledgerIncomeTable');
  if(incTbl){
    if(ledgerIncomes.length===0){
      // Первая строка — Зарплата (не пассивный доход)
      ledgerIncomes.push({id:Date.now(),category:'Зарплата',name:'Зарплата',amount:0, invest: 0});
      LS.save('cf_ledgerIncomes', ledgerIncomes);
    }
    
    // Инициализируем поле invest для категорий, которые его требуют
    ledgerIncomes.forEach(row => {
      if (row.category === 'Недвижимость' || row.category === 'Бизнес' || row.category === 'Другое' || row.category === 'Дивиденды') {
        if (typeof row.invest === 'undefined' || row.invest === null) {
          row.invest = 0;
        }
      }
    });
    incTbl.innerHTML = '<tr>'+ 
      '<th>ЭфКПК</th>'+
      '<th>КПК</th>'+
      '<th>КПД</th>'+
      '<th style="width:84px">Инвестировано <br>$</th>'+
      '<th style="width:84px">Ежемесячно <br>$</th>'+
      '<th style="width:160px">Название</th>'+
      '<th style="width:96px">Категория</th>'+
      '<th style="width:84px">Ежемес<br>за шт.</th>'+ 
      '<th style="width:84px">Штук</th>'+
      '<th style="width:84px">Цена за шт.</th>'+
      '<th style="width:84px">Заложить</th>'+ 
      '<th style="width:42px"></th>'+
    '</tr>';
    ledgerIncomes.forEach((row, i)=>{
      const tr = document.createElement('tr');
      const catSel = `<select onchange=\"editIncome(${i},'category',this.value)\" style=\"width:100%;min-width:0;max-width:12ch\">`+
        ['Зарплата','Профессия','Дивиденды','Недвижимость','Бизнес','Пенсия','Другое'].map(c=>`<option value=\"${c}\" ${((row.category||'Зарплата')===c)?'selected':''}>${c}</option>`).join('')+
        `</select>`;
      const showInvest = (row.category==='Недвижимость' || row.category==='Бизнес' || row.category==='Другое' || row.category==='Дивиденды');
      if (row.category==='Дивиденды' && (typeof row.price === 'undefined' || row.price === null)) { row.price = 0; }
      // Для 'Другое' и 'Дивиденды' показываем оба поля, аналогично Недвижимости/Бизнесу
      const investInput = `<input type=\"number\" step=\"0.01\" value=\"${row.invest??''}\" class=\"numRight\" style=\"width:9ch;min-width:8ch\" onfocus=\"if(this.value==='0'){this.value='';}\" oninput=\"editIncome(${i},'invest',this.value)\">`;
      const priceNum = (parseFloat(row.price)||0);
      const investNum = (parseFloat(row.invest)||0);
      const qtyDiv = (row.category==='Дивиденды' && priceNum>0 && investNum>0 && Math.abs(investNum/priceNum - Math.round(investNum/priceNum))<1e-9) ? Math.floor(investNum/priceNum) : 0;
      const amountInput = (row.category==='Дивиденды')
        ? `<span class=\"numRight\">${qtyDiv>0 ? fmtPretty(((parseFloat(row.amount)||0) * qtyDiv),0) : ''}</span>`
        : `<input type=\"number\" step=\"0.01\" value=\"${row.amount?row.amount:''}\" onfocus=\"if(this.value==='0'){this.value='';}\" oninput=\"editIncome(${i},'amount',this.value)\" class=\"incomeAmountInput numRight\" style=\"width:9ch;min-width:8ch\">`;
      const priceInput = (row.category==='Дивиденды') ? `<input type=\"number\" step=\"0.01\" value=\"${row.price??''}\" class=\"numRight\" style=\"width:9ch;min-width:8ch\" onfocus=\"if(this.value==='0'){this.value='';}\" oninput=\"editIncome(${i},'price',this.value)\">` : '—';
      const qtyCell = (row.category==='Дивиденды') ? (qtyDiv || '') : '';
      const perUnitCell = (row.category==='Дивиденды') ? `<input type=\"number\" step=\"0.01\" value=\"${row.amount?row.amount:''}\" class=\"numRight\" style=\"width:9ch;min-width:8ch\" onfocus=\"if(this.value==='0'){this.value='';}\" oninput=\"editIncome(${i},'amount',this.value)\">` : '—';
      const showKpd = (row.category==='Недвижимость' || row.category==='Бизнес' || row.category==='Другое' || row.category==='Дивиденды');
      const showName = !(row.category==='Зарплата' || row.category==='Пенсия');
      const nameCell = showName ? `<input value="${row.name||''}" placeholder="Название" oninput=\"editIncome(${i},'name',this.value)\" style=\"width:20ch;min-width:16ch\">` : '—';
      const isPledged = !!row.pledged;
      if (isPledged) tr.classList.add('paid');
      const disableStyleInc = isPledged ? 'background:#eee;color:#888' : '';
      const investCellFinal = showInvest ? (isPledged ? `<input disabled value=\"${row.invest??''}\" class=\"numRight\" style=\"${disableStyleInc}; width:9ch; min-width:8ch\">` : investInput) : '—';
      const amountCellFinal = (row.category==='Дивиденды') ? amountInput : (isPledged ? `<input disabled value=\"${row.amount?row.amount:''}\" class=\"numRight\" style=\"${disableStyleInc}; width:9ch; min-width:8ch\">` : amountInput);
      const nameCellFinal = showName ? (isPledged ? `<input disabled value="${row.name||''}" placeholder="Название" style="${disableStyleInc}; width:20ch; min-width:16ch">` : nameCell) : '—';
      const perUnitCellFinal = (row.category==='Дивиденды') ? (isPledged ? `<input disabled value=\"${row.amount?row.amount:''}\" class=\"numRight\" style=\"${disableStyleInc}; width:9ch; min-width:8ch\">` : perUnitCell) : '—';
      const priceCellFinal = (row.category==='Дивиденды') ? (isPledged ? `<input disabled value=\"${row.price??''}\" class=\"numRight\" style=\"${disableStyleInc}; width:9ch; min-width:8ch\">` : priceInput) : '—';
      const pledgeBtn = `<button class='btn' style='padding:2px 8px;font-size:13px;white-space:nowrap;${isPledged?"background:#e6e6e6;color:#333;border:1px solid #ccc":"background:#e6ffe6;color:#080;border:1px solid #9fd09f"}' onclick='toggleIncomePledge(${i})'>${isPledged ? fmtPretty(parseFloat(row.pledgeAmount)||0,0) : 'Заложить'}</button>`;
      const kpdNum = (showKpd && row.invest>0 && row.amount>0) ? ((row.amount/row.invest)*100) : 0;
      // Прирост коэффициента при добавлении этого дохода: deltaCoef = amount / totalExpense (только там, где есть КПД)
      // КПК и ЭФКПК рассчитываются только если:
      // 1. showKpd = true (для Недвижимости, Бизнеса, Другое, Дивиденды)
      // 2. есть расходы (totalExpense > 0)
      // 3. есть ежемесячный доход (row.amount > 0)
      // 4. для ЭФКПК также нужно поле "Инвестировано" (row.invest > 0)
      let kpkVal = '';
      let kpkEffVal = '';
      try{
        const t = computeTotals();
        if (showKpd && t.totalExpense>0 && row.amount>0) {
          const delta = row.amount / t.totalExpense;
          kpkVal = `+${delta.toFixed(3)}`;
          if ((row.invest||0) > 0) {
            const eff = (delta / (parseFloat(row.invest)||1)) * EFKPK_SCALE * 100;
            kpkEffVal = `+${(eff*10).toFixed(2)}%`;
          } else {
            kpkEffVal = '';
          }
        }
      }catch{}
      const kpdVal = (showKpd && kpdNum ? kpdNum.toFixed(2)+'%': '');
      tr.innerHTML = `<td><span id=\"incKpkEff_${i}\" class=\"kpkEffBadge\">${kpkEffVal}</span></td>`+
        `<td><span id=\"incKpk_${i}\" class=\"kpkBadge\">${kpkVal}</span></td>`+
        `<td><span id=\"incKpd_${i}\" class=\"kpdBadge\" style=\"color:${(kpdNum>=2&&kpdNum<=3)?'#080':(kpdNum>0&&kpdNum<1?'#c33':'#444')}\">${kpdVal}</span></td>`+
        `<td>${investCellFinal}</td>`+
        `<td>${amountCellFinal}</td>`+
        `<td>${nameCellFinal}</td>`+
        `<td>${catSel}</td>`+
        `<td>${perUnitCellFinal}</td>`+
        `<td>${qtyCell}</td>`+
        `<td>${priceCellFinal}</td>`+
        `<td>${pledgeBtn}</td>`+
        `<td><button class=\"actBtn\" onclick=\"delIncomeRow(${i})\">✖</button></td>`;
      incTbl.appendChild(tr);
    });
  }
  // Таблица расходов (категории, Погашение, Ежемесячно, КПД)
  const expTbl = document.getElementById('ledgerExpenseTable');
  if(expTbl){
     expTbl.innerHTML = '<tr><th>ЭфКПК</th><th>КПК</th><th>КПД</th><th style="width:96px">&nbsp;Статус&nbsp;</th><th style="width:36px">✔</th><th>Название</th><th style="width:92px">Погашение $</th><th style="width:92px">Ежемесячно $</th></tr>';
    if(ledgerExpenses.length===0){
      const base=['Налоги','Образование','Ипотека','Автомобиль','Кредитные карты','Розничные расходы','Другие','Ребенок','Банк. кредит'];
      base.forEach(cat=>{
        ledgerExpenses.push({id:Date.now()+Math.random(),category:cat,amount:0,payoff:0,closable:expenseClosable.has(cat),closed:false,children:0});
      });
      LS.save('cf_ledgerExpenses', ledgerExpenses);
    }
    // Гарантируем порядок: Налоги, Ипотека, Образование, Автомобиль — всегда в таком порядке; остальные после
    const expRows = ledgerExpenses.map((row, i) => ({ row, i }));
    const prio = (cat) => {
      if (cat === 'Налоги') return 1;
      if (cat === 'Ипотека') return 2;
      if (cat === 'Образование') return 3;
      if (cat === 'Автомобиль') return 4;
      return 10;
    };
    expRows.sort((a, b) => {
      const pa = prio(a.row.category || '');
      const pb = prio(b.row.category || '');
      if (pa !== pb) return pa - pb;
      return a.i - b.i;
    });
    expRows.forEach(({ row, i }) => {
      const canClose = row.closable;
      // Название для кредита
      if (row.category === 'Банк. кредит' && !row.name) {
        row.name = 'Кредит';
      }
    const tr = document.createElement('tr');
      if(row.closed) tr.classList.add('paid');
      const kpd = (row.payoff>0 && row.amount>0) ? ((row.amount/row.payoff)*100).toFixed(2)+'%' : '';
      // Прирост коэффициента при закрытии этого расхода: deltaCoef = (passiveIncome)/(totalExpense-amount) - current
      let kpdExtra = '';
      let kpkEff = '';
      try{
        const t = computeTotals();
        const perUnit = parseFloat(row.amount)||0;
        const childrenCnt = Math.max(0, parseInt(row.children||'0',10)||0);
        const aMonthly = (row.category==='Ребенок') ? (perUnit * childrenCnt) : perUnit;
        const isTaxes = (row.category==='Налоги');
        const isMisc = (row.category==='Прочие расходы' || row.category==='Другие');
        const isChildZero = (row.category==='Ребенок' && childrenCnt===0);
        const skipKpk = isTaxes || isMisc || isChildZero;
        if (!skipKpk && t.totalExpense>0 && aMonthly>0){
          const nextCoef = (t.totalExpense - aMonthly)>0 ? (t.passiveIncome / (t.totalExpense - aMonthly)) : 0;
          const delta = nextCoef - t.coef;
          const deltaPos = delta>0 ? delta : 0;
          const deltaStr = deltaPos.toFixed(3);
          kpdExtra = (deltaStr==='0.000') ? '' : `+${deltaStr}`;
          const invest = parseFloat(row.payoff)||0;
          if (invest>0 && deltaPos>0) {
            const eff = (deltaPos / invest) * EFKPK_SCALE * 100;
            kpkEff = `+${(eff*10).toFixed(2)}%`;
          } else {
            kpkEff = '';
          }
        } else {
          kpdExtra = '';
          kpkEff = '';
        }
      }catch{}
      const isChild = row.category==='Ребенок';
      // Переименуем отображение "Другие" -> "Прочие расходы"
      if (row.category === 'Другие') row.category = 'Прочие расходы';
      const isNonClosable = (row.category==='Налоги' || row.category==='Прочие расходы');
      const payoffCell = isChild || (isNonClosable && !row.isCustom) ? '' : `<input type=\"number\" step=\"0.01\" value=\"${row.payoff||''}\" class=\"numRight\" style=\"width:9ch;min-width:8ch\" onfocus=\"if(this.value==='0'){this.value='';}\" oninput=\"editExpense(${i},'payoff',this.value)\">`;
      const amountVal = (row.amount||row.amount===0) ? row.amount : '';
      const amountCell = `<input type=\"number\" step=\"0.01\" value=\"${amountVal===0?'':amountVal}\" class=\"numRight\" style=\"width:9ch;min-width:8ch\" onfocus=\"if(this.value==='0'){this.value='';}\" oninput=\"editExpense(${i},'amount',this.value)\">`;
      const categoryBase = isChild
        ? `<span id=\"childLabel_${i}\">Детей</span> <input type=\"number\" step=\"1\" min=\"0\" value=\"${row.children||0}\" onfocus=\"this.select()\" oninput=\"editExpense(${i},'children',this.value)\" style=\"width:70px\">`
        : (row.isCustom ? `<input value="${row.category||''}" placeholder="Название расхода" oninput=\"editExpense(${i},'category',this.value)\" style=\"width:16ch;min-width:12ch;max-width:20ch\">` : row.category);
      const categoryCell = row.isCustom
        ? `${categoryBase} <button class='actBtn' onclick='delExpenseRow(${i})' title='Удалить'>✖</button>`
        : categoryBase;
    const statusBtn = canClose ? `<button class='btn' style='padding:2px 8px;font-size:13px;background:${row.closed?'#e6e6e6':'#ffe6e6'};color:#333;border:1px solid #ccc' onclick='toggleExpenseClosed(${i})'>${row.closed?'Нету':'Есть'}</button>` : '';
    const checkCell = (row.category==='Налоги' || row.category==='Прочие расходы')
      ? ''
      : `<input type=\"checkbox\" class=\"kpdCheck expChk\" data-i=\"${i}\" onchange=\"recalcLedgerTotals()\">`;
      const disableStyle = row.closed ? 'background:#eee;color:#888' : '';
      const payoffCellFinal = row.closed ? (payoffCell?`<input disabled value=\"${row.payoff||''}\" class=\"numRight\" style=\"${disableStyle}; width:9ch; min-width:8ch\">`:'') : payoffCell;
      const amountCellFinal = row.closed ? `<input disabled value=\"${amountVal===0?'':amountVal}\" class=\"numRight\" style=\"${disableStyle}; width:9ch; min-width:8ch\">` : amountCell;
      tr.innerHTML =
      `<td><span id=\"expKpkEff_${i}\" class=\"kpkEffBadge\">${kpkEff}</span></td>`+
      `<td><span id=\"expKpk_${i}\" class=\"kpkBadge\">${kpdExtra}</span></td>`+
      `<td><span id=\"expKpd_${i}\" class=\"kpdBadge\" data-val=\"${kpd}\">${kpd}</span></td>`+
      `<td>${statusBtn}</td>`+
      `<td>${checkCell}</td>`+
      `<td>${categoryCell}</td>`+
      `<td>${payoffCellFinal}</td>`+
      `<td>${amountCellFinal}</td>`;
      expTbl.appendChild(tr);
    });
    // Навигация по Enter: переход к следующему числовому полю (вправо, затем в следующую строку)
    expTbl.onkeydown = function(e){
      const target = e.target;
      if (!target || target.tagName !== 'INPUT') return;
      if (e.key === 'Enter'){
        e.preventDefault();
        const inputs = Array.from(expTbl.querySelectorAll('input[type="number"]:not([disabled])'));
        const idx = inputs.indexOf(target);
        if (idx >= 0){
          const next = inputs[idx+1];
          if (next) {
            next.focus();
            next.select && next.select();
          }
        }
      }
    };
  }
  // Подсветим лучшие ЭфКПК в таблицах доходов и расходов
  try { highlightBestEffTables(); } catch {}
  recalcLedgerTotals();
}
function editIncome(i,key,val){
  if(!ledgerIncomes[i]) return;
  if(key==='amount' || key==='invest' || key==='price') val = val===''?0:(parseFloat(val)||0);
  
  // Захватываем предыдущие значения для расчета изменений баланса
  const prevInvest = parseFloat(ledgerIncomes[i].invest)||0;
  const newInvest = key==='invest' ? (parseFloat(val)||0) : prevInvest;
  
  ledgerIncomes[i][key]=val;
  // Проверка кратности для дивидендов
  try {
    const row = ledgerIncomes[i];
    if (row.category === 'Дивиденды') {
      const priceNum = parseFloat(row.price)||0;
      const investNum = parseFloat(row.invest)||0;
      if (priceNum>0 && investNum>0) {
        const q = investNum/priceNum;
        const ok = Math.abs(q - Math.round(q)) < 1e-9;
        row._invalidDividend = !ok;
        if (!ok) { showToast('Инвестировано должно быть кратно цене за шт', 2000); }
      } else {
        row._invalidDividend = false;
      }
    }
  } catch {}
  LS.save('cf_ledgerIncomes', ledgerIncomes);
  
  // Если изменилась сумма инвестиций, корректируем баланс и записываем в историю ходов
  if (key === 'invest' && prevInvest !== newInvest) {
    try {
      const delta = prevInvest - newInvest; // положительное = возврат денег, отрицательное = списание
      if (delta !== 0) {
        const st = getMoveState();
        st.balance = Math.round((st.balance||0) + delta);
        setMoveState(st);
        updateTopBalance();
        
        const row = ledgerIncomes[i];
        const cat = row.category || '';
        const name = row.name || '';
        const label = `${cat}${name ? ` — ${name}` : ''}`;
        
        if (delta > 0) {
          addHistory('Баланс', `Возврат инвестиций: +${fmtPretty(delta,0)}$ (${label})`);
          try{ addTurnEventForCurrentTurn(delta, `Возврат инвестиций (${label})`); }catch{}
        } else {
          addHistory('Баланс', `Инвестировано: -${fmtPretty(Math.abs(delta),0)}$ (${label})`);
          try{ addTurnEventForCurrentTurn(delta, `Инвестировано (${label})`); }catch{}
        }
        try{ renderTurnsHistory(); }catch{}
      }
    } catch(e) {
      console.warn('Ошибка при изменении баланса в editIncome:', e);
    }
  }
  
  // Убираем ранний возврат при изменении категории, чтобы КПК и ЭфКПК обновлялись
  
  // Обновляем ежемесячный поток в состоянии хода при изменении доходов
  try {
    const updatedMonthly = ensureMonthlyFromLedger();
    const ns = getMoveState();
    ns.monthly = updatedMonthly;
    setMoveState(ns);
    // Обновляем отображение
    const gameCashflowEl = document.getElementById('gameCashflow');
    if (gameCashflowEl) gameCashflowEl.textContent = String(Math.round(updatedMonthly));
    const balanceTopEl = document.getElementById('balanceTop');
    if (balanceTopEl) {
      const monthly = Math.round(updatedMonthly);
      const sign = monthly < 0 ? '-' : '';
      const absMonthly = Math.abs(monthly);
      balanceTopEl.textContent = `${sign}${absMonthly} $`;
      // Устанавливаем цвет: красный для отрицательных значений
      balanceTopEl.style.color = monthly < 0 ? '#c33' : '#222';
    }
  } catch {}
  
  // обновим КПД в строке для Недвижимость/Бизнес/Другое/Дивиденды
  const row = ledgerIncomes[i];
  const showKpd = (row.category==='Недвижимость' || row.category==='Бизнес' || row.category==='Другое' || row.category==='Дивиденды');
  
  // Обновляем DOM элементы только если они существуют (не при изменении категории)
  const el = document.getElementById('incKpd_'+i);
  const elkpk = document.getElementById('incKpk_'+i);
  const elkpkEff = document.getElementById('incKpkEff_'+i);
  
  if(el && elkpk && elkpkEff){
    // Для дивидендов amount — доход за шт.; приводим к общему ежемесячному
    let monthlyForKpd = parseFloat(row.amount)||0;
    if (row.category==='Дивиденды') {
      const priceNum = parseFloat(row.price)||0;
      const investNum = parseFloat(row.invest)||0;
      if (priceNum>0 && investNum>0 && !row._invalidDividend) {
        const qty = Math.floor(investNum/priceNum);
        monthlyForKpd = monthlyForKpd * qty;
      } else if (priceNum>0 && investNum>0 && row._invalidDividend) {
        monthlyForKpd = 0;
      }
    }
    const valNum = (showKpd && row.invest>0 && monthlyForKpd>0) ? (monthlyForKpd/row.invest*100) : 0;
    let extraTxt = '';
    let effTxt = '';
    try{
      const t = computeTotals();
      if (showKpd && t.totalExpense>0 && monthlyForKpd>0) {
        const delta = monthlyForKpd / t.totalExpense;
        extraTxt = `+${delta.toFixed(3)}`;
         if ((row.invest||0) > 0) {
           const eff = (delta / (parseFloat(row.invest)||1)) * EFKPK_SCALE * 100;
           effTxt = `+${(eff*10).toFixed(2)}%`;
        } else {
          effTxt = '';
        }
      } else {
        extraTxt = '';
      }
    }catch{}
    el.textContent = (showKpd && valNum ? valNum.toFixed(2) + '%' : '');
    elkpk.textContent = extraTxt;
    elkpkEff.textContent = effTxt;
    el.style.color = (valNum>=2 && valNum<=3) ? '#080' : (valNum>0 && valNum<1 ? '#c33' : '#444');
  }
  // Полный пересчёт итогов и ЭфКПК/КПК везде
  recalcLedgerTotals();
  try { highlightBestEffTables(); } catch {}
  
  // Обновляем денежный поток в разделе "Ходы" при изменении ведомости
  try {
    const movesSection = document.getElementById('moves');
    if (movesSection && movesSection.classList.contains('active')) {
      renderMoves();
    }
  } catch {}
  
  // Перерисовываем таблицу при изменении категории для корректного отображения КПК и ЭфКПК
  if (key === 'category') {
    renderLedger();
  }
}
// Залог дохода: добавление/возврат
function toggleIncomePledge(i){
  try{
    const row = ledgerIncomes[i];
    if(!row) return;
    const isPledged = !!row.pledged;
    if(!isPledged){
      let input = prompt('Сумма залога');
      if (input===null) return; // отмена
      let amount = parseFloat(String(input).replace(/\s/g,''));
      if(!isFinite(amount) || amount<=0){ showToast('Некорректная сумма залога', 1800); return; }
      row.pledged = true;
      row.pledgeAmount = amount;
      LS.save('cf_ledgerIncomes', ledgerIncomes);
      // Зачисляем сумму на баланс
      try{
        const st = getMoveState();
        st.balance = Math.round((st.balance||0) + amount);
        setMoveState(st);
        updateTopBalance();
        const cat = row.category || '';
        const name = row.name || '';
        const label = `${cat}${name ? ` — ${name}` : ''}`;
        addHistory('Баланс', `Залог: +${fmtPretty(amount,0)}$ (${label})`);
        try{ addTurnEventForCurrentTurn(amount, `Залог (${label})`); }catch{}
        try{ renderTurnsHistory(); }catch{}
      }catch{}
      // Перерисовать таблицу
      renderLedger();
    } else {
      // Возврат залога
      const amount = parseFloat(row.pledgeAmount)||0;
      if (amount>0){
        try{
          const st = getMoveState();
          st.balance = Math.round((st.balance||0) - amount);
          setMoveState(st);
          updateTopBalance();
          const cat = row.category || '';
          const name = row.name || '';
          const label = `${cat}${name ? ` — ${name}` : ''}`;
          addHistory('Баланс', `Возврат залога: -${fmtPretty(amount,0)}$ (${label})`);
          try{ addTurnEventForCurrentTurn(-amount, `Возврат залога (${label})`); }catch{}
          try{ renderTurnsHistory(); }catch{}
        }catch{}
      }
      delete row.pledged;
      delete row.pledgeAmount;
      LS.save('cf_ledgerIncomes', ledgerIncomes);
      renderLedger();
    }
  }catch(e){ console.warn('Ошибка toggleIncomePledge', e); }
}
function editExpense(i,key,val){
  if(!ledgerExpenses[i]) return;
  if(key==='amount' || key==='payoff') val = val===''?0:(parseFloat(val)||0);
  if(key==='children') val = Math.max(0, parseInt(val||'0',10)||0);
  
  // Захватываем предыдущие значения для расчета изменений баланса
  const prevPayoff = parseFloat(ledgerExpenses[i].payoff)||0;
  const newPayoff = parseFloat(val)||0;
  const prevAmount = parseFloat(ledgerExpenses[i].amount)||0;
  const newAmount = parseFloat(val)||0;
  
  ledgerExpenses[i][key]=val;
  LS.save('cf_ledgerExpenses', ledgerExpenses);
  
  // Обновляем ежемесячный поток в состоянии хода при изменении расходов
  try {
    const updatedMonthly = ensureMonthlyFromLedger();
    const ns = getMoveState();
    ns.monthly = updatedMonthly;
    setMoveState(ns);
    // Обновляем отображение ежемесячного потока
    const gameCashflowEl = document.getElementById('gameCashflow');
    if (gameCashflowEl) gameCashflowEl.textContent = String(Math.round(updatedMonthly));
  } catch {}
  
  // Не изменяем баланс при вводе суммы погашения; списание/возврат происходит только при нажатии "Закрыть"
  
  // Если изменилось количество детей, корректируем баланс для закрытых расходов
  if (key === 'children' && ledgerExpenses[i].closed) {
    try {
      const prevChildren = parseInt(ledgerExpenses[i].children||'0',10)||0;
      const newChildren = parseInt(val||'0',10)||0;
      const amountPerChild = parseFloat(ledgerExpenses[i].amount)||0;
      
      if (prevChildren !== newChildren && amountPerChild > 0) {
        const delta = (prevChildren - newChildren) * amountPerChild;
        if (delta !== 0) {
          const st = getMoveState();
          st.balance = Math.round((st.balance||0) + delta);
          setMoveState(st);
          updateTopBalance();
          
          const row = ledgerExpenses[i];
          const cat = row.category || '';
          const label = `${cat} (${newChildren} детей)`;
          
          if (delta > 0) {
            addHistory('Баланс', `Возврат по детям: +${fmtPretty(delta,0)}$ (${label})`);
            try{ addTurnEventForCurrentTurn(delta, `Возврат по детям (${label})`); }catch{}
          } else {
            addHistory('Баланс', `Списание по детям: -${fmtPretty(Math.abs(delta),0)}$ (${label})`);
            try{ addTurnEventForCurrentTurn(delta, `Списание по детям (${label})`); }catch{}
          }
          try{ renderTurnsHistory(); }catch{}
        }
      }
    } catch(e) {
      console.warn('Ошибка при изменении баланса по детям в editExpense:', e);
    }
  }
    const k = document.getElementById('expKpd_'+i);
    if(k){
    const p = ledgerExpenses[i].payoff||0;
    const a = ledgerExpenses[i].amount||0;
    const base = (p>0 && a>0) ? ((a/p*100).toFixed(2)+'%') : '';
    // Пересчёт КПК
    let extra = '';
      let effTxt = '';
    try{
      const t = computeTotals();
      let aEff = a;
      const cat = ledgerExpenses[i].category;
      const isTaxes = (cat==='Налоги');
      const isMisc = (cat==='Прочие расходы' || cat==='Другие');
      const isChild = (cat==='Ребенок');
      if (isChild) {
        const n = Math.max(0, parseInt(ledgerExpenses[i].children||'0',10)||0);
        aEff = (parseFloat(a)||0) * n; // реальный ежемесячный расход по детям
        if (n===0) {
          aEff = 0; // при нуле детей не считаем КПК
        }
      }
      const skipKpk = isTaxes || isMisc || (isChild && aEff===0);
      if (!skipKpk && t.totalExpense>0 && aEff>0){
        const nextCoef = (t.totalExpense - aEff)>0 ? (t.passiveIncome / (t.totalExpense - aEff)) : 0;
        const delta = nextCoef - t.coef;
        const deltaPos = delta>0 ? delta : 0;
        const deltaStr = deltaPos.toFixed(3);
        extra = (deltaStr==='0.000') ? '' : `+${deltaStr}`;
        const invest = parseFloat(p)||0;
        if (invest>0 && deltaPos>0) {
          const eff = (deltaPos / invest) * EFKPK_SCALE * 100;
          effTxt = `+${(eff*10).toFixed(2)}%`;
        } else {
          effTxt = '';
        }
      } else {
        extra = '';
        effTxt = '';
      }
    }catch{}
    k.setAttribute('data-val', base);
    k.textContent = base;
    const kpk = document.getElementById('expKpk_'+i);
    if (kpk) kpk.textContent = extra;
      const kpkEffEl = document.getElementById('expKpkEff_'+i);
      if (kpkEffEl) kpkEffEl.textContent = effTxt;
  }
  recalcLedgerTotals();
  try { highlightBestEffTables(); } catch {}
  
  // Обновляем денежный поток в разделе "Ходы" при изменении ведомости
  try {
    const movesSection = document.getElementById('moves');
    if (movesSection && movesSection.classList.contains('active')) {
      renderMoves();
    }
  } catch {}
}

// Подсветка лучших значений ЭфКПК в таблицах доходов и расходов
function highlightBestEffTables(){
  try{
    // Подсветка лучших значений ЭфКПК (без формирования списков)
    const highlight = (selector)=>{
      const nodes = Array.from(document.querySelectorAll(selector));
      let bestActive = -Infinity;
      nodes.forEach(n=>{
        const txt = (n.textContent||'').replace(/[^0-9.,+-]/g,'').replace(',', '.');
        const v = parseFloat(txt);
        const row = n.closest('tr');
        const isClosed = row && row.classList.contains('paid');
        if(!isNaN(v) && !isClosed){
          bestActive = Math.max(bestActive, v);
        }
      });
      nodes.forEach(n=>{
        const txt = (n.textContent||'').replace(/[^0-9.,+-]/g,'').replace(',', '.');
        const v = parseFloat(txt);
        n.style.color = '#444';
        n.style.fontWeight = 'normal';
        const row = n.closest('tr');
        const isClosed = row && row.classList.contains('paid');
        if(!isNaN(v) && v === bestActive && bestActive > -Infinity && !isClosed){
          n.style.color = '#080';
          n.style.fontWeight = '700';
        }
      });
    };
    highlight('#ledgerIncomeTable .kpkEffBadge');
    highlight('#ledgerExpenseTable .kpkEffBadge');
  }catch{}
}

// Функция для создания списка лучших ЭфКПК
// Функция для расчета выгодной покупки
function calculateProfitableBuy() {
  try {
    const buyAmount = parseFloat(document.getElementById('buyAmount').value) || 0;
    const monthlyIncome = parseFloat(document.getElementById('monthlyIncome').value) || 0;
    const partnerCommission = parseFloat(document.getElementById('partnerCommission').value) || 0;
    
    const detailsDiv = document.getElementById('profitableBuyDetails');
    
    if (buyAmount <= 0 || monthlyIncome <= 0) {
      detailsDiv.innerHTML = `
        <div style="color:#888;font-style:italic">Введите данные выше для расчета</div>
      `;
      return;
    }
    
    // Инвестиция (как в доходах): сумма покупки + комиссия партнеру
    const investTotal = buyAmount + partnerCommission;

    // Текущие итоги (как в таблице доходов): КПК = прирост общего коэффициента = monthly / totalExpense
    let totalExpense = 0;
    try {
      const totals = computeTotals();
      totalExpense = totals.totalExpense || 0;
    } catch {}

    // КПД (как в доходах): ежемесячный доход / инвестиции * 100
    const kpd = investTotal > 0 ? (monthlyIncome / investTotal) * 100 : 0;

    // КПК (как в доходах): delta = monthly / totalExpense
    const kpk = (totalExpense > 0 && monthlyIncome > 0) ? (monthlyIncome / totalExpense) : 0;

    // ЭфКПК (как в доходах): (delta / инвестиции) * EFKPK_SCALE * 100
    const effKpk = (investTotal > 0 && kpk > 0) ? ((kpk / investTotal) * EFKPK_SCALE * 100) : 0;
    
    // Подсветка КПД по порогам: <1% — красный; 1-2% — нейтральный; 2-3% — зелёный; >3% — нейтральный
    let kpdColor = '#444';
    if (kpd < 1) kpdColor = '#c33';
    else if (kpd >= 2 && kpd <= 3) kpdColor = '#080';
    
    // Показываем результат
    detailsDiv.innerHTML = `
      <div style="margin-bottom:8px"><strong>Инвестиции (покупка + комиссия):</strong> $${investTotal.toLocaleString()}</div>
      <div style="margin-bottom:8px"><strong>КПД:</strong> <span style="color:${kpdColor};font-weight:bold">${kpd.toFixed(2)}%</span> <span style="color:#666;font-size:12px">(ежемесячный доход / инвестиции)</span></div>
      <div style="margin-bottom:8px"><strong>КПК:</strong> <span style="color:#226;font-weight:bold">+${kpk.toFixed(3)}</span> <span style="color:#666;font-size:12px">(ежемесячный доход / общий расход сейчас)</span></div>
      <div style="margin-bottom:8px"><strong>ЭфКПК:</strong> <span style="color:#080;font-weight:bold">+${(effKpk*10).toFixed(2)}%</span> <span style="color:#666;font-size:12px">((КПК / инвестиции) × ${EFKPK_SCALE} × 100 × 10)</span></div>
    `;
    
    // Записываем в историю ходов расчет выгодной покупки
    try{ addTurnEventForCurrentTurn(0, `Расчет покупки: ${buyAmount}$ → ${monthlyIncome}$/мес (КПД: ${kpd.toFixed(2)}%)`); }catch{}
    try{ renderTurnsHistory(); }catch{}
    
  } catch (e) {
    console.warn('Error calculating profitable buy:', e);
    const detailsDiv = document.getElementById('profitableBuyDetails');
    detailsDiv.innerHTML = `
      <div style="color:#c33;font-style:italic">Ошибка при расчете. Проверьте введенные данные.</div>
    `;
  }
}

function createBestEffList(allEffValues) { /* Раздел отключён по требованию */ }
function childrenGrew(i){
  if(!ledgerExpenses[i]) return;
  pushUndo();
  ledgerExpenses[i].children = 0;
  // Ноль детей — расход на ребёнка перестаёт учитываться
  ledgerExpenses[i].amount = 0;
  LS.save('cf_ledgerExpenses', ledgerExpenses);
  renderLedger();
}
function recalcLedgerTotals(){
  // Доходы считаем с учетом особенностей дивидендов (доход за шт. × количество)
  const totals2 = computeTotals();
  const totalIncome = totals2.totalIncome;
  const passiveIncome = totals2.passiveIncome;
  let checkedInvest = 0; // сумма погашений по отмеченным
  let checkedMonthly = 0; // сумма ежемесячных по отмеченным
  const totalExpense = ledgerExpenses
    .filter(r=>!r.closed)
    .reduce((a,r)=>{
      if(r.category==='Ребенок'){
        const perChild = parseFloat(r.amount)||0;
        const n = Math.max(0, parseInt(r.children||'0',10)||0);
        const rowSum = perChild * n;
        // копим отмеченные для калькулятора
        const rowIndex = ledgerExpenses.indexOf(r);
        const chk = document.querySelector(`.expChk[data-i='${rowIndex}']`);
        if(chk && chk.checked){
          checkedMonthly += rowSum;
          if ((r.payoff||0)>0) checkedInvest += parseFloat(r.payoff)||0;
        }
        return a + rowSum;
      }
      // копим отмеченные для калькулятора
      const rowIndex = ledgerExpenses.indexOf(r);
      const chk = document.querySelector(`.expChk[data-i='${rowIndex}']`);
      const amountNum = parseFloat(r.amount)||0;
      if(chk && chk.checked){
        checkedMonthly += amountNum;
        if ((r.payoff||0)>0){ checkedInvest += parseFloat(r.payoff)||0; }
      }
      return a + amountNum;
    }, 0);
  const cashflow = totalIncome - totalExpense;
  const coef = totalExpense>0 ? (passiveIncome/totalExpense) : 0;
  const set = (id, val, digits=0)=>{ const el=document.getElementById(id); if(el) el.textContent = fmtPretty(Math.round(val), digits); };
  try{ updateTopBalance(); }catch{}
  set('sumIncome', totalIncome);
  set('sumPassive', passiveIncome);
  set('sumExpense', totalExpense);
  set('sumCashflow', cashflow);
  // Верхние выражения под суммами: формируем динамически из текущих данных
  try {
    const incomeParts = [];
    let salary = 0;
    ledgerIncomes.forEach(r => {
      const amt = parseFloat(r.amount)||0;
      if ((r.category||'')==='Зарплата') salary += amt; else if (amt>0) incomeParts.push(Math.round(amt));
    });
    const incExprTop = document.getElementById('sumIncomeExprTop');
    if (incExprTop) {
      const parts = [];
      if (salary>0) parts.push(Math.round(salary));
      incomeParts.forEach(v=>parts.push(Math.round(v)));
      incExprTop.innerHTML = parts.length ? parts.map(v=>fmtPretty(v,0)).join(' + ') : '';
    }
    const passExprTop = document.getElementById('sumPassiveExprTop');
    if (passExprTop) {
      const passiveItems = ledgerIncomes.filter(r=>r.category!=='Зарплата').map(r=>Math.round(parseFloat(r.amount)||0)).filter(v=>v>0);
      passExprTop.innerHTML = passiveItems.length ? passiveItems.map(v=>fmtPretty(v,0)).join(' + ') : '';
    }
    const expExprTop = document.getElementById('sumExpenseExprTop');
    if (expExprTop) {
      const normalParts = [];
      let childStr = '';
      let creditStr = '';
      ledgerExpenses.filter(r=>!r.closed).forEach(r=>{
        const cat = (r.category||'');
        if (cat==='Ребенок'){
          const n = Math.max(0, parseInt(r.children||'0',10)||0);
          const per = parseFloat(r.amount)||0;
          const val = Math.round(per * n);
          if (val>0) childStr = '-' + fmtPretty(val,0) + ` (Дети х${n})`;
        } else if (cat==='Банк. кредит') {
          const per = Math.round(parseFloat(r.amount)||0);
          const payoff = Math.round(parseFloat(r.payoff)||0);
          const payoffStr = payoff>0 ? ` (Кредит на ${fmtPretty(payoff,0)})` : '';
          if (per>0) creditStr = '-' + fmtPretty(per,0) + payoffStr;
        } else {
          const per = Math.round(parseFloat(r.amount)||0);
          if (per>0) normalParts.push('-' + fmtPretty(per,0));
        }
      });
      const firstLine = normalParts.join(' ');
      const secondLineParts = [];
      if (childStr) secondLineParts.push(childStr);
      if (creditStr) secondLineParts.push(creditStr);
      const secondLine = secondLineParts.join(' ');
      expExprTop.innerHTML = [firstLine, secondLine].filter(Boolean).join('<br>');
    }
  } catch {}
  // Новая статистика: инвестировано
  try{
    const investIncome = ledgerIncomes.reduce((a,r)=> a + (parseFloat(r.invest)||0), 0);
    // В погашение считаем только по закрытым расходам, чтобы не пугать суммами планов
    const investExpense = ledgerExpenses
      .filter(r=>r.closed)
      .reduce((a,r)=> a + (parseFloat(r.payoff)||0), 0);
    const investTotal = investIncome + investExpense;
    set('sumInvestIncome', investIncome);
    set('sumInvestExpense', investExpense);
    const totalEl = document.getElementById('sumInvestTotal');
    if (totalEl) totalEl.textContent = fmtPretty(investTotal, 0);
  }catch{}
  const coefEl = document.getElementById('sumCoef');
  if(coefEl) coefEl.textContent = (coef||0).toFixed(3);
  const coefTopEl = document.getElementById('sumCoefTop');
  if (coefTopEl) coefTopEl.textContent = `Кэф: ${(coef||0).toFixed(3)}`;
  // Пересчёт КПК/ЭфКПК для всех строк доходов и расходов при изменении любых данных
  try {
    // Доходы: КПК и ЭфКПК только для категорий с инвестициями (Недвижимость, Бизнес, Другое, Дивиденды)
    ledgerIncomes.forEach((row, i) => {
      const showKpd = (row.category==='Недвижимость' || row.category==='Бизнес' || row.category==='Другое' || row.category==='Дивиденды');
      let amount = parseFloat(row.amount)||0;
      if (row.category==='Дивиденды') {
        const priceNum = parseFloat(row.price)||0;
        const investNum = parseFloat(row.invest)||0;
        if (priceNum>0 && investNum>0 && Math.abs(investNum/priceNum - Math.round(investNum/priceNum))<1e-9) {
          const qty = Math.floor(investNum/priceNum);
          amount = amount * qty;
        } else {
          amount = 0;
        }
      }
      const invest = parseFloat(row.invest)||0;
      let kpkText = '';
      let effText = '';
      if (showKpd && totalExpense>0 && amount>0) {
        const delta = amount / totalExpense;
        const deltaStr = delta.toFixed(3);
        kpkText = (deltaStr==='0.000') ? '' : `+${deltaStr}`;
        if (invest>0) {
          const eff = (delta / invest) * EFKPK_SCALE * 100;
          effText = `+${(eff*10).toFixed(2)}%`;
        }
      }
      const kpkEl = document.getElementById('incKpk_'+i);
      if (kpkEl) kpkEl.textContent = kpkText;
      const effEl = document.getElementById('incKpkEff_'+i);
      if (effEl) effEl.textContent = effText;
    });
  } catch {}
  try {
    // Расходы: КПК и ЭфКПК для всех строк, исходя из текущего totalExpense
    ledgerExpenses.forEach((row, i) => {
      const amount = parseFloat(row.amount)||0;
      const invest = parseFloat(row.payoff)||0;
      const cat = row.category||'';
      const isTaxes = (cat==='Налоги');
      const isMisc = (cat==='Прочие расходы' || cat==='Другие');
      const isChild = (cat==='Ребенок');
      let aEff = amount;
      if (isChild) {
        const n = Math.max(0, parseInt(row.children||'0',10)||0);
        aEff = (parseFloat(amount)||0) * n;
      }
      const skipKpk = isTaxes || isMisc || (isChild && aEff===0);
      let kpkText = '';
      let effText = '';
      if (!skipKpk && totalExpense>0 && aEff>0) {
        const nextCoef = (totalExpense - aEff)>0 ? (passiveIncome / (totalExpense - aEff)) : 0;
        const delta = nextCoef - coef;
        const deltaPos = delta>0 ? delta : 0;
        const deltaStr = deltaPos.toFixed(3);
        kpkText = (deltaStr==='0.000') ? '' : `+${deltaStr}`;
        if (invest>0 && deltaPos>0) {
          const eff = (deltaPos / invest) * EFKPK_SCALE * 100;
          effText = `+${(eff*10).toFixed(2)}%`;
        }
      }
      const kpkEl = document.getElementById('expKpk_'+i);
      if (kpkEl) kpkEl.textContent = kpkText;
      const effEl = document.getElementById('expKpkEff_'+i);
      if (effEl) effEl.textContent = effText;
    });
  } catch {}
  // Подсветка КПД по строкам
  document.querySelectorAll('#ledgerExpenseTable .kpdBadge').forEach(el=>{
    const txt = el.getAttribute('data-val') || el.textContent || '';
    const num = parseFloat(String(txt).replace('%','')) || 0;
    el.style.color = num>2 ? '#080' : (num<1 && num>0 ? '#c33' : '#444');
    el.textContent = num ? num.toFixed(2)+'%' : '';
  });
  // Обновляем подпись для детей (только текст "Детей")
  ledgerExpenses.forEach((r,idx)=>{
    if(r.category==='Ребенок'){
      const span = document.getElementById('childLabel_'+idx);
      if(span) span.textContent = 'Детей';
    }
  });
  // Сводка по калькулятору расходов
  const sumEl = document.getElementById('expKpdSummary');
  if(sumEl){
    if (checkedInvest>0 || checkedMonthly>0) {
      const kpdTotal = (checkedInvest>0 && checkedMonthly>0) ? ((checkedMonthly/checkedInvest)*100).toFixed(2)+'%' : '';
      // КПК для отмеченных: как изменится общий коэффициент при закрытии всех отмеченных ежемесячных
      let kpkDelta = '';
      let deltaNum = 0;
      try {
        const nextCoef = (totalExpense - checkedMonthly) > 0 ? (passiveIncome / (totalExpense - checkedMonthly)) : 0;
        deltaNum = nextCoef - coef;
        const deltaPos = deltaNum>0?deltaNum:0;
        const deltaStr = deltaPos.toFixed(3);
        kpkDelta = (deltaStr==='0.000') ? '' : `+${deltaStr}`;
      } catch {}
      const eff = (checkedInvest>0 && deltaNum>0) 
        ? `ЭфКПК: <b>+${(((deltaNum)/checkedInvest)*EFKPK_SCALE*100*10).toFixed(2)}%</b><br>` 
        : '';
      sumEl.innerHTML = `Погашение: <b>${fmtPretty(checkedInvest,0)} $</b><br>`+
                        `Ежемесячно: <b>${fmtPretty(checkedMonthly,0)} $</b><br>`+
                        `${eff}`+
                        `КПК: <b>${kpkDelta||'+0.000'}</b><br>`+
                        `КПД: <b>${kpdTotal||''}</b>`;
    } else {
      sumEl.innerHTML = '';
    }
  }

  // Выражения под таблицами (доходы/расходы)
  try {
    const incExprEl = document.getElementById('ledgerIncomeExpr');
    if (incExprEl) {
      incExprEl.innerHTML = '';
    }
    // Пассивный доход: исключаем Зарплата, берём остальные доходы
    const passiveEl = document.getElementById('ledgerPassiveExpr');
    if (passiveEl) {
      const passiveItems = ledgerIncomes
        .filter(r=>r.category!=='Зарплата')
        .map(r=>parseFloat(r.amount)||0)
        .filter(v=>v>0)
        .map(v=>fmtPretty(Math.round(v),0));
      const passiveTotalStr = fmtPretty(Math.round(passiveIncome),0);
      const chunkSizeP = 6;
      const chunksP = [];
      for (let i = 0; i < passiveItems.length; i += chunkSizeP) {
        chunksP.push(passiveItems.slice(i, i + chunkSizeP));
      }
      const formattedPassive = chunksP.map((chunk, idx) => (idx>0?'+ ':'') + chunk.join(' + ')).join('<br>');
      passiveEl.innerHTML = passiveItems.length ? `${formattedPassive}<br>= <b>${passiveTotalStr}</b> пассивный доход` : '';
    }
  } catch{}
  try {
    const expExprEl = document.getElementById('ledgerExpenseExpr');
    if (expExprEl) {
      const parts = [];
      ledgerExpenses.filter(r=>!r.closed).forEach(r=>{
        if (r.category==='Ребенок'){
          const n = Math.max(0, parseInt(r.children||'0',10)||0);
          const perChild = parseFloat(r.amount)||0;
          const val = perChild * n;
          if (val>0) parts.push(fmtPretty(Math.round(val),0));
        } else {
          const val = parseFloat(r.amount)||0;
          if (val>0) parts.push(fmtPretty(Math.round(val),0));
        }
      });
      const totalStr = fmtPretty(Math.round(totalExpense),0);
      const chunkSize = 6;
      const chunks = [];
      for (let i = 0; i < parts.length; i += chunkSize) {
        chunks.push(parts.slice(i, i + chunkSize));
      }
      const formattedParts = chunks.map((chunk, idx) => (idx>0?'+ ':'') + chunk.join(' + ')).join('<br>');
      expExprEl.innerHTML = parts.length ? `${formattedParts}<br>= <b>${totalStr}</b> общий расход` : '';
    }
  } catch{}
  
  // Инициализируем данные прогноза
  try {
    initForecastData();
  } catch {}
  
  // Обновляем таблицу прогноза
  try {
    renderForecast();
  } catch {}
  
  // Обновляем всплывающую панель с финансовыми показателями
  try {
    updateFinancialPanel();
  } catch {}
  
  // Обновляем денежный поток в разделе "Ходы" при изменении ведомости
  try {
    const movesSection = document.getElementById('moves');
    if (movesSection && movesSection.classList.contains('active')) {
      renderMoves();
    }
  } catch {}
}
function addIncomeRow(){
  pushUndo();
  const cat = document.getElementById('incomeCategory').value||'Профессия';
  const name = (document.getElementById('incomeName').value||'').trim();
  const amount = parseFloat(document.getElementById('incomeAmount').value)||0;
  const invest = parseFloat(document.getElementById('incomeInvest').value)||0;
  const price = parseFloat(document.getElementById('incomePrice')?.value)||0;
  if(amount<=0){ showToast('Укажите сумму дохода'); return; }
  
  // Проверяем, достаточно ли денег для инвестиций
  const investNum = Math.round(invest||0);
  if (investNum > 0) {
    const st = getMoveState();
    const balNow = Math.round(st.balance||0);
    if (balNow < investNum) {
      // Показываем диалог подтверждения
      if (confirm(`Не хватает денег. Все равно купить?\n\nТребуется: ${fmtPretty(investNum,0)}$\nДоступно: ${fmtPretty(balNow,0)}$\nНедостает: ${fmtPretty(investNum - balNow,0)}$`)) {
        // Пользователь подтвердил - продолжаем
      } else {
        // Пользователь отменил
        return;
      }
    }
  }

  // Дивиденды: инвестировано должно быть кратно цене за шт. Предлагаем ближайшую кратную вниз
  try {
    if (cat === 'Дивиденды') {
      if (!(price > 0)) { showToast('Укажите цену за шт. для дивидендов'); return; }
      if (invest > 0) {
        const q = invest / price;
        const isInt = Math.abs(q - Math.round(q)) < 1e-9;
        if (!isInt) {
          const k = Math.floor(q);
          const suggested = Math.max(0, Math.round((k * price) * 100) / 100);
          const investEl = document.getElementById('incomeInvest');
          if (investEl) investEl.value = String(suggested);
          showToast(`Инвестировано должно быть кратно цене. Предложено: ${fmtPretty(suggested,0)} $`);
          return;
        }
      }
    }
  } catch {}
  
  if(cat==='Пенсия'){
    // только одна строка пенсии — заменяем существующую
    const idx = ledgerIncomes.findIndex(r=>r.category==='Пенсия');
    const row = {id:Date.now(),category:cat,name,amount,invest};
    if(idx>=0) ledgerIncomes[idx]=row; else ledgerIncomes.push(row);
  } else {
    const row = {id:Date.now(),category:cat,name,amount,invest};
    if (cat==='Дивиденды') row.price = price||0;
    ledgerIncomes.push(row);
  }
  LS.save('cf_ledgerIncomes', ledgerIncomes);
  addHistory('Ведомость', `Доход: <b>${cat}</b> ${name?'- '+name+' ':''}${fmtPretty(amount,0)}$`);
  // Баланс уменьшается на сумму инвестиций
  try{
    if (investNum>0){
      const st = getMoveState();
      st.balance = Math.round((st.balance||0) - investNum);
      setMoveState(st);
      updateTopBalance();
      
      // Проверяем, стал ли баланс отрицательным
      if (st.balance < 0) {
        showToast('Баланс отрицательный', 2000);
      }
      
      addHistory('Баланс', `Инвестировано: -${fmtPretty(investNum,0)}$ (${cat}${name?` — ${escapeHtml(name)}`:''})`);
      try{ addTurnEventForCurrentTurn(-investNum, `Инвестировано (${cat}${name?` — ${name}`:''})`); }catch{}
      try{ renderTurnsHistory(); }catch{}
    }
  }catch{}
  document.getElementById('incomeName').value='';
  document.getElementById('incomeAmount').value='';
  const investEl = document.getElementById('incomeInvest'); if(investEl) investEl.value='';
  // Также очищаем цену для дивидендов
  try { const priceEl = document.getElementById('incomePrice'); if (priceEl) priceEl.value = ''; } catch {}
  renderLedger();
  
  // Обновляем денежный поток в разделе "Ходы" при изменении ведомости
  try {
    const movesSection = document.getElementById('moves');
    if (movesSection && movesSection.classList.contains('active')) {
      renderMoves();
    }
  } catch {}
}
function delIncomeRow(i){
  pushUndo();
  try{
    const row = ledgerIncomes[i];
    const investNum = Math.round(parseFloat(row?.invest)||0);
    
    // Спрашиваем сумму продажи
    const defaultSalePrice = investNum > 0 ? investNum : 0;
    const saleInput = prompt(`За какую сумму продали "${row?.category||''}${row?.name?` — ${row.name}`:''}"?`, String(defaultSalePrice));
    
    if (saleInput === null) {
      // Пользователь отменил
      return;
    }
    
    const saleAmount = Math.round(parseFloat(String(saleInput).replace(',', '.'))||0);
    
    if (saleAmount > 0) {
      const st = getMoveState();
      st.balance = Math.round((st.balance||0) + saleAmount);
      setMoveState(st);
      updateTopBalance();
      
      const categoryName = row?.category || '';
      const itemName = row?.name ? ` — ${row.name}` : '';
      const fullName = categoryName + itemName;
      
      // Расчет чистой прибыли
      const netProfit = saleAmount - investNum;
      const profitRatio = investNum > 0 ? (saleAmount / investNum).toFixed(1) : '0.0';
      const profitText = netProfit >= 0 ? `(Чистые +${fmtPretty(netProfit,0)}$, х${profitRatio})` : `(Чистые ${fmtPretty(netProfit,0)}$, х${profitRatio})`;
      
      addHistory('Баланс', `Продажа ${fullName}: +${fmtPretty(saleAmount,0)}$ ${profitText}`);
      try{ addTurnEventForCurrentTurn(saleAmount, `Продажа ${fullName}. Сумма покупки ${fmtPretty(investNum,0)}$ → Сумма продажи ${fmtPretty(saleAmount,0)}$ ${profitText}`); }catch{}
      try{ renderTurnsHistory(); }catch{}
    }
  }catch{}
  
  ledgerIncomes.splice(i,1);
  LS.save('cf_ledgerIncomes', ledgerIncomes);
  renderLedger();
  
  // Обновляем денежный поток в разделе "Ходы" при изменении ведомости
  try {
    const movesSection = document.getElementById('moves');
    if (movesSection && movesSection.classList.contains('active')) {
      renderMoves();
    }
  } catch {}
}
function addExpenseRow(){
  pushUndo();
  // Подсчитываем количество существующих "Другое"
  const otherCount = ledgerExpenses.filter(r => r.category && r.category.startsWith('Другое')).length;
  const cat = `Другое ${otherCount + 1}`;
  const amount = 0;
  const payoff = 0;
  // Пользовательский расход должен быть редактируемым и с полем погашения
  const closable = true;
  ledgerExpenses.push({id:Date.now(),category:cat,amount,payoff:payoff,closable,closed:false,children:0,isCustom:true});
  LS.save('cf_ledgerExpenses', ledgerExpenses);
  addHistory('Ведомость', `Расход: <b>${cat}</b> добавлен`);
  
  // Если у нового расхода есть сумма погашения, списываем её с баланса
  if (payoff > 0) {
    try {
      const st = getMoveState();
      st.balance = Math.round((st.balance||0) - payoff);
      setMoveState(st);
      updateTopBalance();
      addHistory('Баланс', `Погашение: -${fmtPretty(payoff,0)}$ (${cat})`);
      try{ addTurnEventForCurrentTurn(-payoff, `Погашение (${cat})`); }catch{}
      try{ renderTurnsHistory(); }catch{}
    } catch(e) {
      console.warn('Ошибка при изменении баланса в addExpenseRow:', e);
    }
  }
  
  renderLedger();
  
  // Обновляем денежный поток в разделе "Ходы" при изменении ведомости
  try {
    const movesSection = document.getElementById('moves');
    if (movesSection && movesSection.classList.contains('active')) {
      renderMoves();
    }
  } catch {}
}
function delExpenseRow(i){
  if(!ledgerExpenses[i] || !ledgerExpenses[i].isCustom) return;
  pushUndo();
  
  const row = ledgerExpenses[i];
  const cat = row.category || 'Расход';
  
  // Если расход был закрыт и у него есть сумма погашения, возвращаем её на баланс
  if (row.closed && (row.payoff || 0) > 0) {
    try {
      const payoff = Math.round(parseFloat(row.payoff)||0);
      const st = getMoveState();
      st.balance = Math.round((st.balance||0) + payoff);
      setMoveState(st);
      updateTopBalance();
      addHistory('Баланс', `Возврат погашения: +${fmtPretty(payoff,0)}$ (${cat})`);
      try{ addTurnEventForCurrentTurn(payoff, `Возврат погашения (${cat})`); }catch{}
      try{ renderTurnsHistory(); }catch{}
    } catch(e) {
      console.warn('Ошибка при изменении баланса в delExpenseRow:', e);
    }
  }
  
  ledgerExpenses.splice(i,1);
  LS.save('cf_ledgerExpenses', ledgerExpenses);
  addHistory('Ведомость', `Удалён расход: <b>${cat}</b>`);
  renderLedger();
  
  // Обновляем денежный поток в разделе "Ходы" при изменении ведомости
  try {
    const movesSection = document.getElementById('moves');
    if (movesSection && movesSection.classList.contains('active')) {
      renderMoves();
    }
  } catch {}
}
function toggleExpenseClosed(i){
  if(!ledgerExpenses[i]) return;
  pushUndo();
  try{
    const willClose = !ledgerExpenses[i].closed;
    const payoff = Math.round(parseFloat(ledgerExpenses[i].payoff)||0);
    if (willClose && payoff>0){
      const stCheck = getMoveState();
      const balNow = Math.round(stCheck.balance||0);
      if (balNow < payoff){
        // Показываем диалог подтверждения
        if (confirm(`Не хватает денег. Все равно купить?\n\nТребуется: ${fmtPretty(payoff,0)}$\nДоступно: ${fmtPretty(balNow,0)}$\nНедостает: ${fmtPretty(payoff - balNow,0)}$`)) {
          // Пользователь подтвердил - продолжаем
        } else {
          // Пользователь отменил
          return;
        }
      }
    }
    // Применяем смену статуса
    ledgerExpenses[i].closed = willClose;
    LS.save('cf_ledgerExpenses', ledgerExpenses);
    // Баланс: при закрытии уменьшаем на payoff, при открытии возвращаем
    const payoff2 = Math.round(parseFloat(ledgerExpenses[i].payoff)||0);
    if (payoff2>0){
      const st = getMoveState();
      const delta = willClose ? -payoff2 : payoff2;
      st.balance = Math.round((st.balance||0) + delta);
      setMoveState(st);
      updateTopBalance();
      
      // Проверяем, стал ли баланс отрицательным
      if (st.balance < 0) {
        showToast('Баланс отрицательный', 2000);
      }
      
      addHistory('Баланс', `${willClose?'Погашение':'Отмена погашения'}: ${delta>0?'+':''}${fmtPretty(delta,0)}$ (${ledgerExpenses[i].category||''})`);
      try{ addTurnEventForCurrentTurn(delta, `${willClose?'Погашение':'Отмена погашения'} (${ledgerExpenses[i].category||''})`); }catch{}
      try{ renderTurnsHistory(); }catch{}
    }
  }catch{}
  // Мгновенно пересчитаем сводку и коэффициент
  try{ recalcLedgerTotals(); }catch{}
  renderLedger();
  
  // Обновляем денежный поток в разделе "Ходы" при изменении ведомости
  try {
    const movesSection = document.getElementById('moves');
    if (movesSection && movesSection.classList.contains('active')) {
      renderMoves();
    }
  } catch {}
}

// Функции для раздела Прогноз
let forecastData = [];

function addForecastRow(){
  pushUndo();
  const cat = document.getElementById('forecastCategory').value || 'Недвижимость';
  const name = (document.getElementById('forecastName').value || '').trim();
  const invest = parseFloat(document.getElementById('forecastInvest').value) || 0;
  const monthly = parseFloat(document.getElementById('forecastMonthly').value) || 0;
  const price = parseFloat(document.getElementById('forecastPrice')?.value) || 0;
  
  if (invest <= 0 || monthly <= 0) {
    showToast('Укажите сумму инвестиций и ежемесячный доход');
    return;
  }
  // Валидация для дивидендов: цена обязательна и инвест кратно цене
  try {
    if (cat === 'Дивиденды') {
      if (!(price > 0)) { showToast('Укажите цену за шт. для дивидендов'); return; }
      const q = invest / price;
      const isInt = Math.abs(q - Math.round(q)) < 1e-9;
      if (!isInt) {
        const k = Math.floor(q);
        const suggested = Math.max(0, Math.round((k * price) * 100) / 100);
        const investEl = document.getElementById('forecastInvest');
        if (investEl) investEl.value = String(suggested);
        showToast(`Инвестировано должно быть кратно цене. Предложено: ${fmtPretty(suggested,0)} $`);
        return;
      }
    }
  } catch {}
  
  const newRow = {
    id: Date.now(),
    category: cat,
    name: name,
    invest: invest,
    monthly: monthly,
    price: (cat==='Дивиденды') ? price : 0,
    isDefault: false
  };
  
  forecastData.push(newRow);
  LS.save('cf_forecastData', forecastData);
  addHistory('Прогноз', `Добавлен: ${cat}${name ? ' — ' + name : ''} ${fmtPretty(invest,0)}$ → ${fmtPretty(monthly,0)}$/мес`);
  
  // Очищаем поля ввода
  document.getElementById('forecastName').value = '';
  document.getElementById('forecastInvest').value = '';
  document.getElementById('forecastMonthly').value = '';
  try { const priceEl = document.getElementById('forecastPrice'); if (priceEl) priceEl.value = ''; } catch {}
  
  renderForecast();
}

function clearForecastForm(){
  // Очищаем все поля ввода формы прогноза
  document.getElementById('forecastCategory').value = 'Недвижимость';
  document.getElementById('forecastName').value = '';
  document.getElementById('forecastInvest').value = '';
  document.getElementById('forecastMonthly').value = '';
  try { 
    const priceEl = document.getElementById('forecastPrice'); 
    if (priceEl) priceEl.value = ''; 
  } catch {}
  
  // Очищаем метку ТОП
  const rankEl = document.getElementById('forecastTopRank');
  if (rankEl) {
    rankEl.textContent = '';
  }
  
  showToast('Форма прогноза очищена');
}

function delForecastRow(i){
  if (!forecastData[i]) return;
  pushUndo();
  
  const row = forecastData[i];
  const rowName = `${row.category}${row.name ? ' — ' + row.name : ''}`;
  
  // Не позволяем удалять строки по умолчанию
  if (row.isDefault) {
    showToast('Нельзя удалить строку по умолчанию');
    return;
  }
  
  forecastData.splice(i, 1);
  LS.save('cf_forecastData', forecastData);
  addHistory('Прогноз', `Удалён: ${rowName}`);
  
  renderForecast();
}

function editForecast(i, key, val){
  if (!forecastData[i]) return;
  pushUndo();
  
  const row = forecastData[i];
  const oldVal = row[key];
  row[key] = val;
  
  // Пересчитываем метрики
  if (key === 'invest' || key === 'monthly') {
    row.invest = parseFloat(row.invest) || 0;
    row.monthly = parseFloat(row.monthly) || 0;
  }
  
  LS.save('cf_forecastData', forecastData);
  addHistory('Прогноз', `Изменён: ${row.category}${row.name ? ' — ' + row.name : ''} ${key}: ${oldVal} → ${val}`);
  
  renderForecast();
}

function renderForecast(){
  const tbody = document.getElementById('forecastTableBody');
  const sumBox = document.getElementById('forecastSummary');
  if (!tbody) return;
  // Применяем тумблер "Скрыть примеры"
  try {
    const toggle = document.getElementById('forecastHideExamples');
    if (toggle && !toggle._wired) {
      toggle._wired = true;
      // Инициализация из localStorage
      const saved = localStorage.getItem('cf_forecastHideExamples');
      if (saved === '1') toggle.checked = true;
      toggle.addEventListener('change', () => {
        try { localStorage.setItem('cf_forecastHideExamples', toggle.checked ? '1' : '0'); } catch {}
        renderForecast();
      });
    }
  } catch {}
  
  // Объединяем данные по умолчанию с пользовательскими
  let allData = [...forecastData];
  try {
    const hideExamples = (localStorage.getItem('cf_forecastHideExamples') === '1');
    if (hideExamples) {
      allData = allData.filter(r => !r || !r.isDefault);
    }
  } catch {}

  // Предпросмотр новой строки по вводу в форме (жёлтый фон)
  try {
    const catSel = document.getElementById('forecastCategory');
    const nameInp = document.getElementById('forecastName');
    const invInp = document.getElementById('forecastInvest');
    const monInp = document.getElementById('forecastMonthly');
    const priceWrap = document.getElementById('forecastPriceWrap');
    const priceInp = document.getElementById('forecastPrice');
    // Показ/скрытие цены для дивидендов
    const syncForecastForm = ()=>{
      const v = (catSel && catSel.value) || '';
      if (priceWrap) priceWrap.style.display = (v==='Дивиденды') ? '' : 'none';
    };
    if (catSel) {
      catSel.addEventListener('change', syncForecastForm);
      syncForecastForm();
    }
    const previewCat = (catSel && catSel.value) || 'Недвижимость';
    const previewName = (nameInp && nameInp.value || '').trim();
    const previewInvest = parseFloat(invInp && invInp.value || '0') || 0;
    const previewMonthly = parseFloat(monInp && monInp.value || '0') || 0;
    if (previewInvest > 0 || previewMonthly > 0 || previewName) {
      allData.push({
        id: 'preview',
        category: previewCat,
        name: previewName,
        invest: previewInvest,
        monthly: previewMonthly, // сюда кладём per-unit для дивидендов, пересчитаем ниже в рендере
        price: previewCat==='Дивиденды' ? (parseFloat(priceInp && priceInp.value || '0')||0) : 0,
        isDefault: false,
        isCurrent: false,
        isPreview: true,
        source: 'forecast'
      });
    }
  } catch {}
  
  // Добавляем текущие доходы и расходы для сравнения
  ledgerIncomes.forEach(income => {
    // Если доход заложен — показываем как отдельный тип "Залог" со стоимостью залога,
    // а ежемесячно показываем его обычный (информационно), но не учитываем в дельте/эффективности
    if (income && income.pledged) {
      const pledgeAmt = Math.max(0, parseFloat(income.pledgeAmount)||0);
      let monthlyShow = parseFloat(income.amount)||0;
      if (income.category==='Дивиденды'){
        const priceNum = parseFloat(income.price)||0;
        const investNum = parseFloat(income.invest)||0;
        if (priceNum>0 && investNum>0 && Math.abs(investNum/priceNum - Math.round(investNum/priceNum))<1e-9) {
          const qty = Math.floor(investNum/priceNum);
          monthlyShow = monthlyShow * qty;
        } else if (priceNum>0) {
          monthlyShow = 0;
        }
      }
      if (pledgeAmt > 0) {
        allData.push({
          id: 'pledge_' + income.id,
          category: income.category,
          name: income.name || '',
          invest: pledgeAmt,
          monthly: monthlyShow,
          price: income.category==='Дивиденды' ? (parseFloat(income.price)||0) : 0,
          isDefault: false,
          isCurrent: true,
          source: 'pledge',
          type: 'Залог'
        });
      }
      return; // заложенные доходы не добавляем как доход
    }
    if (income.invest > 0) {
      let monthly = parseFloat(income.amount)||0;
      if (income.category==='Дивиденды'){
        const priceNum = parseFloat(income.price)||0;
        const investNum = parseFloat(income.invest)||0;
        if (priceNum>0 && investNum>0 && Math.abs(investNum/priceNum - Math.round(investNum/priceNum))<1e-9) {
          const qty = Math.floor(investNum/priceNum);
          monthly = monthly * qty;
        } else {
          monthly = 0;
        }
      }
      if (monthly > 0) {
        allData.push({
          id: 'income_' + income.id,
          category: income.category,
          name: income.name || '',
          invest: income.invest,
          monthly: monthly,
          price: income.category==='Дивиденды' ? (parseFloat(income.price)||0) : 0,
          isDefault: false,
          isCurrent: true,
          source: 'income'
        });
      }
    }
  });
  
  ledgerExpenses.forEach(expense => {
    if (expense.payoff > 0 && expense.amount > 0) {
      allData.push({
        id: 'expense_' + expense.id,
        // Переносим категорию в название, саму категорию очищаем (перенос, не копия)
        category: '',
        name: (expense.name && String(expense.name).trim()) ? expense.name : (expense.category || ''),
        invest: expense.payoff,
        monthly: expense.amount,
        isDefault: false,
        isCurrent: true,
        source: 'expense',
        isClosed: expense.closed === true
      });
    }
  });
  
  // Сортируем по ЭфКПК (по убыванию) — именно по отображаемому значению
  try {
    const totalsForSort = typeof computeTotals === 'function' ? computeTotals() : { totalExpense: 0, passiveIncome: 0, coef: 0 };
    const baseExpForSort = parseFloat(totalsForSort.totalExpense) || 0;
    const basePassForSort = parseFloat(totalsForSort.passiveIncome) || 0;
    const baseCoefForSort = parseFloat(totalsForSort.coef) || 0;
    const scale = (typeof EFKPK_SCALE !== 'undefined') ? EFKPK_SCALE : 1;
    const effFor = (row) => {
      const invest = parseFloat(row.invest) || 0;
      let monthly = parseFloat(row.monthly) || 0;
      if (row.category==='Дивиденды' && row.source!=='expense'){
        const priceNum = parseFloat(row.price)||0;
        if (priceNum>0 && invest>0 && Math.abs(invest/priceNum - Math.round(invest/priceNum))<1e-9) {
          const qty = Math.floor(invest/priceNum);
          monthly = monthly * qty;
        } else if (priceNum>0) {
          monthly = 0;
        }
      }
      if (invest <= 0 || monthly <= 0) return -Infinity;
      let delta = 0;
      if (row.source === 'expense') {
        const nextCoef = (baseExpForSort - monthly) > 0 ? (basePassForSort / (baseExpForSort - monthly)) : 0;
        delta = Math.max(0, nextCoef - baseCoefForSort);
      } else {
        if (baseExpForSort > 0) delta = monthly / baseExpForSort; else delta = 0;
      }
      if (delta <= 0) return -Infinity;
      const eff = (delta / invest) * scale * 100 * 10; // как в отображении (×10)
      return eff;
    };
    allData.sort((a, b) => {
      const ea = effFor(a);
      const eb = effFor(b);
      const isNum = (v)=> (typeof v === 'number' && isFinite(v));
      const aNum = isNum(ea);
      const bNum = isNum(eb);
      // Специально: жёлтая превью-строка держим сверху, пока нет ЭфКПК
      const aPreviewNoEff = !!a.isPreview && (!aNum || ea <= 0);
      const bPreviewNoEff = !!b.isPreview && (!bNum || eb <= 0);
      if (aPreviewNoEff && !bPreviewNoEff) return -1;
      if (!aPreviewNoEff && bPreviewNoEff) return 1;
      // Ненормальные значения и нулевые/отрицательные — в конец
      if (!aNum || ea <= 0) {
        if (!bNum || eb <= 0) return 0;
        return 1;
      }
      if (!bNum || eb <= 0) return -1;
      const diff = eb - ea; // по убыванию
      if (Math.abs(diff) > 1e-9) return diff;
      // Ровно одинаковые ЭфКПК — сохраняем текущий порядок
      return 0;
    });
  } catch {
    // Фолбек: если что-то пошло не так, сортируем по monthly/invest
    allData.sort((a, b) => (b.monthly / b.invest) - (a.monthly / a.invest));
  }
  
  tbody.innerHTML = '';
  
  let selected = [];
  // Позиция жёлтой строки (если есть) для вывода ТОПN
  const previewIndex = allData.findIndex(r => r && r.isPreview);
  // Обновим метку ТОП рядом с полями ввода
  try {
    const rankEl = document.getElementById('forecastTopRank');
    if (rankEl) {
      if (previewIndex >= 0) {
        // Получаем данные строки-превью для вычисления метрик
        const previewRow = allData[previewIndex];
        let metricsHtml = `<span style="color:#4a90e2;font-weight:600;">ТОП${previewIndex + 1}</span>   `;
        
        if (previewRow) {
          // Вычисляем метрики для строки-превью
          let kpk = '';
          let effKpk = '';
          let kpd = '';
          
          // КПД
          const monthlyPerUnit = parseFloat(previewRow.monthly) || 0;
          let monthlyTotal = monthlyPerUnit;
          try {
            if (previewRow.category === 'Дивиденды' && previewRow.source !== 'expense') {
              const priceNum = parseFloat(previewRow.price) || 0;
              const investNum = parseFloat(previewRow.invest) || 0;
              if (priceNum > 0 && investNum > 0 && Math.abs(investNum / priceNum - Math.round(investNum / priceNum)) < 1e-9) {
                const qty = Math.floor(investNum / priceNum);
                monthlyTotal = monthlyPerUnit * qty;
              } else if (priceNum > 0) {
                monthlyTotal = 0;
              }
            }
          } catch {}
          kpd = monthlyTotal > 0 && previewRow.invest > 0 ? (monthlyTotal / previewRow.invest * 100).toFixed(2) : '0.00';
          
          // КПК и ЭфКПК
          try {
            const totals = typeof computeTotals === 'function' ? computeTotals() : { totalExpense: 0, passiveIncome: 0, coef: 0 };
            const totalExpense = parseFloat(totals.totalExpense) || 0;
            const passiveIncome = parseFloat(totals.passiveIncome) || 0;
            const coef = parseFloat(totals.coef) || 0;
            if (previewRow.monthly > 0) {
              let delta = 0;
              if (previewRow.source === 'expense') {
                const nextCoef = (totalExpense - previewRow.monthly) > 0 ? (passiveIncome / (totalExpense - previewRow.monthly)) : 0;
                delta = Math.max(0, nextCoef - coef);
              } else {
                const monthlyAdj = monthlyTotal;
                if (totalExpense > 0) delta = monthlyAdj / totalExpense;
              }
              if (delta > 0) {
                kpk = `+${delta.toFixed(3)}`;
                if (previewRow.invest > 0) {
                  const scale = (typeof EFKPK_SCALE !== 'undefined') ? EFKPK_SCALE : 1;
                  const eff = (delta / previewRow.invest) * scale * 100;
                  effKpk = `+${(eff*10).toFixed(2)}%`;
                }
              }
            }
          } catch {}
          
          // Формируем HTML с метриками
          if (effKpk || kpk || kpd !== '0.00') {
            metricsHtml += '<span style="font-size:12px;color:#666;font-weight:normal;line-height:1.3;display:inline-block;text-align:left;">';
            if (effKpk) metricsHtml += `ЭфКПК: ${effKpk} `;
            if (kpk) metricsHtml += `КПК: ${kpk} `;
            if (kpd !== '0.00') metricsHtml += `КПД: ${kpd}%`;
            metricsHtml += '</span>';
          }
        }
        
        rankEl.innerHTML = metricsHtml;
      } else {
        rankEl.textContent = '';
      }
    }
  } catch {}
  allData.forEach((row, i) => {
    const tr = document.createElement('tr');
    
    // Вычисляем метрики (как в ведомости: КПК/ЭфКПК через дельту к коэффициенту)
    let kpk = '';
    let effKpk = '';
    // Для дивидендов monthly хранит доход за шт.; здесь считаем общий ежемесячный для отображения/КПД
    let monthlyPerUnit = parseFloat(row.monthly) || 0;
    let monthlyTotal = monthlyPerUnit;
    try {
      if (row.category === 'Дивиденды' && row.source !== 'expense') {
        const priceNum = parseFloat(row.price) || 0;
        const investNum = parseFloat(row.invest) || 0;
        if (priceNum > 0 && investNum > 0 && Math.abs(investNum / priceNum - Math.round(investNum / priceNum)) < 1e-9) {
          const qty = Math.floor(investNum / priceNum);
          monthlyTotal = monthlyPerUnit * qty;
        } else if (priceNum > 0) {
          monthlyTotal = 0;
        }
      }
    } catch {}
    const kpd = monthlyTotal > 0 && row.invest > 0 ? (monthlyTotal / row.invest * 100).toFixed(2) : '0.00';
    try {
      const totals = typeof computeTotals === 'function' ? computeTotals() : { totalExpense: 0, passiveIncome: 0, coef: 0 };
      const totalExpense = parseFloat(totals.totalExpense) || 0;
      const passiveIncome = parseFloat(totals.passiveIncome) || 0;
      const coef = parseFloat(totals.coef) || 0;
      if (row.monthly > 0) {
        let delta = 0;
        if (row.source === 'expense') {
          const nextCoef = (totalExpense - row.monthly) > 0 ? (passiveIncome / (totalExpense - row.monthly)) : 0;
          delta = Math.max(0, nextCoef - coef);
        } else {
          // Для залога не считаем дельту эффективности, только отображаем ежемесячно
          if (row.source === 'pledge') {
            delta = 0;
          } else {
            const monthlyAdj = monthlyTotal; // уже учтены особенности дивидендов
            if (totalExpense > 0) delta = monthlyAdj / totalExpense;
          }
        }
        if (delta > 0) {
          kpk = `+${delta.toFixed(3)}`;
          if (row.invest > 0) {
            const scale = (typeof EFKPK_SCALE !== 'undefined') ? EFKPK_SCALE : 1;
            const eff = (delta / row.invest) * scale * 100;
            effKpk = `+${(eff*10).toFixed(2)}%`;
          } else {
            effKpk = '';
          }
        }
      }
    } catch {}
    
    // Определяем стили для строк
    let rowStyle = '';
    if (row.isPreview) {
      rowStyle = 'background:#fffbe6;';
    } else if (row.isCurrent && row.source === 'income') {
      rowStyle = 'background:#f0f8ff;';
    } else if (row.isCurrent && row.source === 'expense') {
      if (row.isClosed) {
        rowStyle = 'background:#f8f8f8;text-decoration:line-through;color:#aaa;';
      } else {
        rowStyle = 'background:#fff0f0;';
      }
    } else if (row.isDefault) {
      rowStyle = 'background:#f2f2f2;';
    }
    
    // Определяем кнопки действий
    let actionCell = '';
    if (!row.isDefault && !row.isCurrent) {
      // Находим индекс в оригинальном массиве forecastData
      const originalIndex = forecastData.findIndex(f => f.id === row.id);
      if (originalIndex >= 0) {
        actionCell = `<button class="actBtn" onclick="delForecastRow(${originalIndex})" title="Удалить">✖️</button>`;
      }
    } else if (row.isDefault) {
      actionCell = '';
    } else if (row.isCurrent) {
      actionCell = '';
    }
    const editBtn = (row.isCurrent || row.isPreview) ? '' : '<button class="actBtn fc-edit" data-id="'+row.id+'" title="Редактировать">✎</button> ';

    // Определяем тип строки
    let typeLabel = 'Прогноз';
    if (row.isCurrent && row.source === 'income') typeLabel = 'Доход';
    if (row.isCurrent && row.source === 'pledge') typeLabel = 'Залог';
    else if (row.isCurrent && row.source === 'expense') typeLabel = 'Расход';
    else if (row.isDefault) typeLabel = 'Пример';

    // Цвета по типу: Расход — красный, Доход — зелёный, Залог — фиолетовый, Прогноз — синий, Пример — серый
    const typeColor = typeLabel === 'Расход' ? '#c33' : (typeLabel === 'Доход' ? '#080' : (typeLabel === 'Залог' ? '#8b5cf6' : (typeLabel === 'Прогноз' ? '#2563eb' : '#666')));
    // Подсветка: прогноз — синий фон
    if (!row.isCurrent && !row.isDefault && !row.isPreview) {
      rowStyle = 'background:#f0f8ff;';
    }
    if (row.isCurrent && row.source === 'income') {
      rowStyle = 'background:#f0f8ff;';
    }

    tr.innerHTML = `
      <td style="border:1px solid #b3d6f6;padding:8px;text-align:center;${rowStyle}"><input type="checkbox" class="forecastChk" data-id="${row.id}" style="width:22px;height:22px;accent-color:#4a90e2"></td>
      <td style="border:1px solid #b3d6f6;padding:8px;text-align:center;font-weight:bold;color:#080;${rowStyle}"><span class="fc-eff" data-id="${row.id}" style="${row.isClosed ? 'text-decoration:line-through;color:#888;' : ''}">${effKpk}</span></td>
      <td style="border:1px solid #b3d6f6;padding:8px;text-align:center;color:#666;${rowStyle}"><span class="fc-kpk" data-id="${row.id}" style="${row.isClosed ? 'text-decoration:line-through;color:#888;' : ''}">${kpk}</span></td>
      <td style="border:1px solid #b3d6f6;padding:8px;text-align:center;color:#226;${rowStyle}"><span style="${row.isClosed ? 'text-decoration:line-through;color:#888;' : ''}">${kpd}%</span></td>
      <td style="border:1px solid #b3d6f6;padding:8px;text-align:center;${rowStyle}"><span class="fc-name" data-id="${row.id}" style="${row.isClosed ? 'text-decoration:line-through;color:#888;' : ''}">${row.name || ''}</span></td>
      <td style="border:1px solid #b3d6f6;padding:8px;text-align:center;font-weight:bold;color:#444;${rowStyle}"><span class="fc-invest" data-id="${row.id}" style="${row.isClosed ? 'text-decoration:line-through;color:#888;' : ''}">${fmtPretty(row.invest,0)}</span></td>
      <td style="border:1px solid #b3d6f6;padding:8px;text-align:center;font-weight:bold;${row.source==='expense'?'color:#c33':'color:#080'};${rowStyle}"><span class="fc-monthly" data-id="${row.id}" style="${row.isClosed ? 'text-decoration:line-through;color:#888;' : ''}${row.source==='pledge' ? 'text-decoration:line-through;' : ''}">${row.source==='expense' ? '-' : ''}${fmtPretty(row.source==='expense' ? (parseFloat(row.monthly)||0) : monthlyTotal,0)}</span></td>
      <td style="border:1px solid #b3d6f6;padding:8px;text-align:center;${rowStyle}"><span class="fc-category" data-id="${row.id}" style="${row.isClosed ? 'text-decoration:line-through;color:#888;' : ''}">${row.category||''}</span></td>
      <td style="border:1px solid #b3d6f6;padding:8px;text-align:center;${rowStyle};color:${typeColor};font-weight:600"><span class="fc-type" data-id="${row.id}" style="${row.isClosed ? 'text-decoration:line-through;color:#888;' : ''}">${typeLabel}</span></td>
      <td style="border:1px solid #b3d6f6;padding:8px;text-align:center;${rowStyle}"><span class="fc-perunit" data-id="${row.id}" style="${row.isClosed ? 'text-decoration:line-through;color:#888;' : ''}">${row.category==='Дивиденды' ? ( (parseFloat(row.monthly)||0) ? fmtPretty(parseFloat(row.monthly)||0,0) : '' ) : ''}</span></td>
      <td style="border:1px solid #b3d6f6;padding:8px;text-align:center;${rowStyle}"><span class="fc-qty" data-id="${row.id}" style="${row.isClosed ? 'text-decoration:line-through;color:#888;' : ''}">${row.category==='Дивиденды' && row.price>0 && row.invest>0 ? Math.floor((parseFloat(row.invest)||0)/(parseFloat(row.price)||1)) : ''}</span></td>
      <td style="border:1px solid #b3d6f6;padding:8px;text-align:center;${rowStyle}"><span class="fc-price" data-id="${row.id}" style="${row.isClosed ? 'text-decoration:line-through;color:#888;' : ''}">${row.category==='Дивиденды' ? fmtPretty(row.price||0,0) : ''}</span></td>
      <td style="border:1px solid #b3d6f6;padding:8px;text-align:center;${rowStyle}">${row.isPreview?'':(editBtn+actionCell)}</td>
    `;
    
    tbody.appendChild(tr);
  });

  // Инлайн-редактирование
  tbody.querySelectorAll('.fc-edit').forEach(btn => {
    btn.addEventListener('click', () => {
      const id = btn.getAttribute('data-id');
      const nameEl = tbody.querySelector(`.fc-name[data-id="${CSS.escape(id)}"]`);
      const invEl = tbody.querySelector(`.fc-invest[data-id="${CSS.escape(id)}"]`);
      const monEl = tbody.querySelector(`.fc-monthly[data-id="${CSS.escape(id)}"]`);
      const qtyEl = tbody.querySelector(`.fc-qty[data-id="${CSS.escape(id)}"]`);
      const catEl = tbody.querySelector(`.fc-category[data-id="${CSS.escape(id)}"]`);
      const typeEl = tbody.querySelector(`.fc-type[data-id="${CSS.escape(id)}"]`);
      const priceEl = tbody.querySelector(`.fc-price[data-id="${CSS.escape(id)}"]`);
      const perUnitEl = tbody.querySelector(`.fc-perunit[data-id="${CSS.escape(id)}"]`);
      const row = allData.find(r => String(r.id) === String(id));
      if (!row) return;
      const editing = nameEl && nameEl.contentEditable === 'true';
      // Определяем переменные для категории и типа заранее
      let newCategory = '';
      let newTypeTxt = '';
      
      if (!editing) {
        if (nameEl) { nameEl.contentEditable = 'true'; nameEl.style.background = '#fffbe6'; }
        if (invEl) { invEl.contentEditable = 'true'; invEl.style.background = '#fffbe6'; }
        if (monEl) { monEl.contentEditable = 'true'; monEl.style.background = '#fffbe6'; }
        if (catEl) { 
          // Создаем select для категории
          const catSelect = document.createElement('select');
          catSelect.style.cssText = 'width:100%;padding:4px;border:1px solid #ccc;border-radius:4px;background:#fffbe6';
          catSelect.innerHTML = `
            <option value="Недвижимость" ${row.category === 'Недвижимость' ? 'selected' : ''}>Недвижимость</option>
            <option value="Бизнес" ${row.category === 'Бизнес' ? 'selected' : ''}>Бизнес</option>
            <option value="Дивиденды" ${row.category === 'Дивиденды' ? 'selected' : ''}>Дивиденды</option>
            <option value="Другое" ${row.category === 'Другое' ? 'selected' : ''}>Другое</option>
          `;
          catEl.innerHTML = '';
          catEl.appendChild(catSelect);
        }
        if (typeEl) { 
          // Создаем select для типа
          const typeSelect = document.createElement('select');
          typeSelect.style.cssText = 'width:100%;padding:4px;border:1px solid #ccc;border-radius:4px;background:#fffbe6';
          typeSelect.innerHTML = `
            <option value="Прогноз" ${!row.isDefault ? 'selected' : ''}>Прогноз</option>
            <option value="Пример" ${row.isDefault ? 'selected' : ''}>Пример</option>
          `;
          typeEl.innerHTML = '';
          typeEl.appendChild(typeSelect);
        }
        // Делаем дивидендные поля доступными для редактирования для любой строки,
        // чтобы можно было быстро ввести значения (будут учтены только для категории "Дивиденды")
        if (qtyEl) { qtyEl.contentEditable = 'true'; qtyEl.style.background = '#fffbe6'; }
        if (priceEl) { priceEl.contentEditable = 'true'; priceEl.style.background = '#fffbe6'; }
        if (perUnitEl) { perUnitEl.contentEditable = 'true'; perUnitEl.style.background = '#fffbe6'; }
        // Если пусто — подставим 0, чтобы было куда нажать
        try {
          if (perUnitEl && String(perUnitEl.innerText||'').trim()==='') perUnitEl.innerText = '0';
          if (qtyEl && String(qtyEl.innerText||'').trim()==='') qtyEl.innerText = '0';
          if (priceEl && String(priceEl.innerText||'').trim()==='') priceEl.innerText = '0';
        } catch {}
        btn.textContent = '✔';
      } else {
        const originalIndex = forecastData.findIndex(f => String(f.id) === String(row.id));
        if (originalIndex >= 0) {
          const cleanNum = (txt)=>{ const n = parseFloat(String(txt).replace(/[^0-9.\-]/g,'')||'0'); return isFinite(n)?n:0; };
          const newName = (nameEl?.innerText||'').trim();
          const newInvest = cleanNum(invEl?.innerText||'0');
          const newMonthly = cleanNum(monEl?.innerText||'0');
          let newQty = qtyEl ? Math.max(0, Math.floor(cleanNum(qtyEl.innerText||'0'))) : null;
          newCategory = catEl?.querySelector('select')?.value || (catEl?.innerText||'').trim();
          newTypeTxt = typeEl?.querySelector('select')?.value || (typeEl?.innerText||'').trim();
          const newPrice = priceEl ? cleanNum(priceEl.innerText||'0') : 0;
          const newPerUnit = perUnitEl ? cleanNum(perUnitEl.innerText||'0') : null;
          forecastData[originalIndex].name = newName;
          forecastData[originalIndex].invest = newInvest;
          // Обновляем категорию
          if (typeof newCategory === 'string' && newCategory) {
            forecastData[originalIndex].category = newCategory;
          }
          // Обновляем тип: допускаем только Пример/Прогноз
          if (newTypeTxt === 'Пример') { forecastData[originalIndex].isDefault = true; }
          if (newTypeTxt === 'Прогноз') { forecastData[originalIndex].isDefault = false; }
          // Дивиденды: сохраняем цену и перерасчитываем invest/monthly при изменении qty/per-unit
          if ((forecastData[originalIndex].category||'') === 'Дивиденды') {
            if (!isNaN(newPrice)) { forecastData[originalIndex].price = newPrice; }
            if (newQty !== null && (forecastData[originalIndex].price||0) > 0) {
              forecastData[originalIndex].invest = (forecastData[originalIndex].price||0) * newQty;
            }
            if (newPerUnit !== null && newPerUnit >= 0) {
              // monthly хранит доход за шт. для дивидендов
              forecastData[originalIndex].monthly = newPerUnit;
            } else {
              forecastData[originalIndex].monthly = newMonthly;
            }
          } else {
            // Не дивиденды: обычное ежемесячное значение
            forecastData[originalIndex].monthly = newMonthly;
            // Сбрасываем цену, чтобы не мешала расчётам
            forecastData[originalIndex].price = 0;
          }
          // Если пользователь ввёл qty/per-unit/price для не-дивидендной строки,
          // и при этом категория пустая или это Пример — конвертируем в Дивиденды, чтобы сохранить ввод
          // НО НЕ для примеров "Дом 2/1" и НЕ для записей с уже установленной категорией
          if ((forecastData[originalIndex].category||'') !== 'Дивиденды') {
            const name = String(forecastData[originalIndex].name||'').trim();
            const isHouseExample = name === 'Дом 2/1';
            const hasExistingCategory = (forecastData[originalIndex].category||'').trim() !== '';
            
            const hasDivInputs = (newQty !== null && newQty >= 0) || (!isNaN(newPrice) && newPrice >= 0) || (newPerUnit !== null && newPerUnit >= 0);
            // Конвертируем только если нет существующей категории И это не пример "Дом 2/1"
            if (hasDivInputs && !isHouseExample && !hasExistingCategory) {
              forecastData[originalIndex].category = 'Дивиденды';
              if (!isNaN(newPrice) && newPrice >= 0) forecastData[originalIndex].price = newPrice;
              if (newQty !== null && newQty >= 0 && (forecastData[originalIndex].price||0) > 0) {
                forecastData[originalIndex].invest = (forecastData[originalIndex].price||0) * newQty;
              }
              if (newPerUnit !== null && newPerUnit >= 0) {
                forecastData[originalIndex].monthly = newPerUnit;
              }
            }
          }
          // Если редактируется количество для дивидендов — пересчитываем invest из цены
          try {
            const price = parseFloat(forecastData[originalIndex].price||'0')||0;
            if (row.category==='Дивиденды' && price>0 && newQty!==null) {
              forecastData[originalIndex].invest = price * newQty;
            }
          } catch {}
          LS.save('cf_forecastData', forecastData);
        }
        if (nameEl) { nameEl.contentEditable = 'false'; nameEl.style.background = ''; }
        if (invEl) { invEl.contentEditable = 'false'; invEl.style.background = ''; invEl.textContent = fmtPretty(parseFloat(forecastData.find(f=>String(f.id)===String(row.id))?.invest||0),0); }
        if (monEl) { monEl.contentEditable = 'false'; monEl.style.background = ''; monEl.textContent = fmtPretty(parseFloat(forecastData.find(f=>String(f.id)===String(row.id))?.monthly||0),0); }
        if (catEl) { 
          catEl.innerHTML = newCategory || '';
          catEl.style.background = '';
        }
        if (typeEl) { 
          typeEl.innerHTML = newTypeTxt || '';
          typeEl.style.background = '';
        }
        if (qtyEl) { qtyEl.contentEditable = 'false'; qtyEl.style.background = ''; }
        if (priceEl) { priceEl.contentEditable = 'false'; priceEl.style.background = ''; }
        if (perUnitEl) { perUnitEl.contentEditable = 'false'; perUnitEl.style.background = ''; }
        btn.textContent = '✎';
        renderForecast();
      }
    });
  });

  // Сумма по отмеченным
  function updateForecastSummary(){
    const chks = tbody.querySelectorAll('.forecastChk:checked');
    let sumInvest = 0;
    let sumPassiveAdd = 0;   // сумма добавления пассива (доходы)
    let sumExpenseReduce = 0; // сумма уменьшения расходов (расходы)
    const selectedIds = [];
    chks.forEach(ch => {
      const id = ch.getAttribute('data-id');
      selectedIds.push(String(id));
      const row = allData.find(r => String(r.id) === String(id));
      if (!row) return;
      const inv = parseFloat(row.invest)||0;
      let mon = parseFloat(row.monthly)||0;
      if (row.category==='Дивиденды' && row.source!=='expense'){
        const priceNum = parseFloat(row.price)||0;
        if (priceNum>0 && inv>0 && Math.abs(inv/priceNum - Math.round(inv/priceNum))<1e-9) {
          const qty = Math.floor(inv/priceNum);
          mon = mon * qty;
        } else if (priceNum>0) {
          mon = 0;
        }
      }
      sumInvest += inv;
      if (row.source === 'expense') {
        sumExpenseReduce += mon; // mon > 0 всегда; показываем со знаком минус
      } else {
        sumPassiveAdd += mon;
      }
    });

    // Базовые текущие итоги
    let baseTotals = { totalIncome:0, passiveIncome:0, totalExpense:0, coef:0 };
    try { baseTotals = computeTotals(); } catch {}

    // Сценарные итоги с учётом выбранных галочек
    const scenarioPassive = (parseFloat(baseTotals.passiveIncome)||0) + sumPassiveAdd;
    const scenarioExpense = Math.max(0, (parseFloat(baseTotals.totalExpense)||0) - sumExpenseReduce);
    const scenarioCoef = scenarioExpense > 0 ? (scenarioPassive / scenarioExpense) : 0;

    // Сводные метрики по сумме
    const sumMonthlyNet = sumPassiveAdd + sumExpenseReduce; // чистый прирост потока (доходы + снижение расходов)
    const kpdNum = (sumInvest>0) ? ((sumMonthlyNet/sumInvest)*100) : 0;
    const fmtSigned = (num, digits=3)=>{
      const n = Number(num||0);
      const s = n.toFixed(digits);
      if (n>0) return '+'+s; if (n<0) return s; return '+0'+(digits?('.'+'0'.repeat(digits)):'');
    };
    const fmtSignedPct = (num, digits=2)=>{
      const n = Number(num||0);
      const s = n.toFixed(digits);
      if (n>0) return '+'+s+'%'; if (n<0) return s+'%'; return '+0.00%';
    };
    let kpkStr = '+0.000';
    let effStr = '+0.00%';

    if (sumBox) {
      const baseCoefNum = parseFloat(baseTotals.coef)||0;
      const dCoef = scenarioCoef - baseCoefNum;
      const dPass = scenarioPassive - (parseFloat(baseTotals.passiveIncome)||0);
      const dExp = scenarioExpense - (parseFloat(baseTotals.totalExpense)||0);
      const smallStyle = 'color:#666;font-size:12px;margin-left:6px;font-weight:400';
      // КПК и ЭфКПК в сводке считаем как у вас: КПК = Δкоэф, ЭфКПК = (Δкоэф/инвест)×масштаб×100×10
      const dCoefPos = Math.max(0, dCoef);
      kpkStr = fmtSigned(dCoefPos, 3);
      if (sumInvest>0) {
        const eff = (dCoefPos / sumInvest) * (typeof EFKPK_SCALE!=='undefined'?EFKPK_SCALE:1) * 100 * 10;
        effStr = fmtSignedPct(eff, 2);
      }
      sumBox.innerHTML =
        `<div style=\"margin-bottom:6px\">Сумма: <b style=\"color:#2563eb\">${fmtPretty(sumInvest,0)} $</b></div>`+
        `Пасив: <b style=\"color:#080\">${fmtPretty(Math.round(sumPassiveAdd),0)} $</b><br>`+
        `Расход: <b style=\"color:#c33\">-${fmtPretty(Math.round(sumExpenseReduce),0)} $</b><br>`+
        `<br>`+
        `ЭфКПК: <b>${effStr}</b><br>`+
        `КПК: <b>${kpkStr}</b><br>`+
        `КПД: <b>${kpdNum.toFixed(2)}%</b><br>`+
        `<div style=\"margin-top:6px;padding-top:6px;border-top:1px solid #cdeccd\">`+
          `Коэффициент: <b style=\"color:#ffd700\">${scenarioCoef.toFixed(3)}</b>`+
          `<span style=\"${smallStyle}\">(${fmtSigned(dCoef,3)}, х${baseCoefNum > 0 ? (scenarioCoef / baseCoefNum).toFixed(1) : '∞'})</span><br>`+
          `Пассивный доход: <b style=\"color:#080\">${fmtPretty(Math.round(scenarioPassive),0)} $</b>`+
          `<span style=\"${smallStyle}\">(${dPass>0?'+':''}${fmtPretty(Math.abs(Math.round(dPass)),0)})</span><br>`+
          `Расход: <b style=\"color:#c33\">${fmtPretty(Math.round(scenarioExpense),0)} $</b>`+
          `<span style=\"${smallStyle}\">(${dExp>0?'+':''}${fmtPretty(Math.round(dExp),0)})</span>`+
        `</div>`;
    }

    // Пересчёт ЭфКПК/КПК по строкам с учетом текущих выбранных галочек (маржинально относительно сценарной базы)
    try {
      allData.forEach(row => {
        const baseExp = scenarioExpense;
        const basePass = scenarioPassive;
        const baseCoef = scenarioCoef;
        let delta = 0;
        if (row.source === 'expense') {
          const nextCoef = (baseExp - (parseFloat(row.monthly)||0)) > 0 ? (basePass / (baseExp - (parseFloat(row.monthly)||0))) : 0;
          delta = Math.max(0, nextCoef - baseCoef);
        } else {
          // Доходы: учитываем дивиденды как per-unit × qty
          let monthlyAdj = parseFloat(row.monthly)||0;
          try {
            if (row.category==='Дивиденды' && row.source!=='expense'){
              const priceNum = parseFloat(row.price)||0;
              const investNum = parseFloat(row.invest)||0;
              if (priceNum>0 && investNum>0 && Math.abs(investNum/priceNum - Math.round(investNum/priceNum))<1e-9) {
                const qty = Math.floor(investNum/priceNum);
                monthlyAdj = monthlyAdj * qty;
              } else if (priceNum>0) {
                monthlyAdj = 0;
              }
            }
          } catch {}
          if (baseExp > 0) delta = monthlyAdj / baseExp; else delta = 0;
        }
        let kpkText = '';
        let effText = '';
        if (delta > 0) {
          kpkText = `+${delta.toFixed(3)}`;
          const inv = parseFloat(row.invest)||0;
          if (inv > 0) {
            const scale = (typeof EFKPK_SCALE !== 'undefined') ? EFKPK_SCALE : 1;
            const eff = (delta / inv) * scale * 100;
            effText = `+${(eff*10).toFixed(2)}%`;
          }
        }
        const idSel = `[data-id="${CSS.escape(String(row.id))}"]`;
        const effEl = tbody.querySelector(`.fc-eff${idSel}`);
        const kpkEl = tbody.querySelector(`.fc-kpk${idSel}`);
        if (effEl) effEl.textContent = effText;
        if (kpkEl) kpkEl.textContent = kpkText;
      });
    } catch {}
  }
  tbody.querySelectorAll('.forecastChk').forEach(ch => {
    ch.addEventListener('change', updateForecastSummary);
  });
  updateForecastSummary();
}

// Оптимизатор по бюджету: выбирает комбинации (из прогноза, доходов и расходов)
// которые максимизируют итоговый коэффициент при бюджете <= optBudget.
// Жадно: на каждом шаге пересчитывает маржинальную дельту КПК/ЭфКПК с учетом уже выбранных.
function runOptimization(){
  try{
    const out = document.getElementById('optResult');
    if (!out) return;
    const budgetInputEl = document.getElementById('optBudget');
    let budgetRaw = (budgetInputEl && budgetInputEl.value!=null) ? String(budgetInputEl.value) : '0';
    // Поддержка выражений вида "10000+2400" в сумме оптимизации
    // Минус обрабатывается только при нажатии кнопки "Посчитать", как и плюс
    const evalMathExpr = (txt)=>{
      try{
        if (txt==null) return NaN;
        let s = String(txt).trim().replace(/,/g, '.');
        // Разрешаем только цифры, пробелы и базовые операторы
        if (!/^[-+*/().\d\s]+$/.test(s)) return NaN;
        // Удаляем пробелы
        s = s.replace(/\s+/g, '');
        // Простая проверка скобок
        let bal = 0; for (let ch of s){ if (ch==='(') bal++; else if (ch===')') bal--; if (bal<0) return NaN; } if (bal!==0) return NaN;
        // Вычисляем безопасно в строгом режиме
        // eslint-disable-next-line no-new-func
        const val = Function('"use strict"; return ('+s+')')();
        const num = Number(val);
        return isFinite(num) ? num : NaN;
      }catch{ return NaN; }
    };
    
    // Проверяем, содержит ли ввод математическое выражение
    const hasMathExpr = budgetRaw.includes('+') || budgetRaw.includes('-') || budgetRaw.includes('*') || budgetRaw.includes('/') || budgetRaw.includes('(');
    
    let budgetEval = NaN;
    if (hasMathExpr) {
      // Если есть математическое выражение, вычисляем его
      budgetEval = evalMathExpr(budgetRaw);
      if (!isNaN(budgetEval)){
        // Округляем до целого и подставляем обратно в поле
        const rounded = Math.round(budgetEval);
        if (budgetInputEl && String(rounded) !== budgetRaw.trim()) {
          budgetInputEl.value = String(rounded);
        }
      }
    } else {
      // Если нет математического выражения, просто парсим число
      budgetEval = parseFloat(budgetRaw) || 0;
    }
    
    const budget = isNaN(budgetEval) ? 0 : Math.round(budgetEval);
    if (budget <= 0 || !isFinite(budget)) { 
      out.innerHTML = '<div style="color:#888">Введите корректную сумму для оптимизации</div>'; 
      return; 
    }

    // Собираем доступные варианты из текущего рендера прогноза
    // Повторим сбор из renderForecast
    const items = [];
    // Источник: forecastData
    try {
      (forecastData||[]).forEach(r=>{
        if (!r || typeof r !== 'object') return; // Пропускаем некорректные записи
        
        const isExample = !!r.isDefault;
        const inv = parseFloat(r.invest)||0; 
        const monPerUnit = parseFloat(r.monthly)||0; // для дивидендов — доход за шт.
        const cat = r.category;
        const name = r.name||'';
        
        // Проверяем корректность данных
        if (!isFinite(inv) || !isFinite(monPerUnit)) return;
        
        // Обработка дивидендов: переводим в общий ежемесячный доход = per-unit × qty, если цена корректна
        if (cat==='Дивиденды'){
          const price = parseFloat(r.price)||0;
          if (!isFinite(price) || price <= 0) return;
          
          let qty = 0;
          let monthlyTotal = 0;
          if (price>0 && inv>0 && Math.abs(inv/price - Math.round(inv/price)) < 1e-9){
            qty = Math.floor(inv/price);
            monthlyTotal = monPerUnit * qty;
          }
          if (inv>0 && monthlyTotal>0 && isFinite(monthlyTotal)){
            // Для дивидендов добавляем как конечный элемент (если это не пример)
            if (!isExample) {
              items.push({
                id:'f_'+r.id, source:'forecast', category:cat, name,
                invest:inv, monthly:monthlyTotal,
                type: 'Прогноз', price: price, perUnit: monPerUnit, qty: qty,
                isDefault: false, example: false
              });
            }
          }
        } else {
          if (inv>0 && monPerUnit>0){
            items.push({
              id:'f_'+r.id, source:'forecast', category:cat, name,
              invest:inv, monthly:monPerUnit, type: isExample ? 'Пример' : 'Прогноз',
              isDefault: !!r.isDefault, example: isExample
            });
          }
        }
      });
    } catch (e) {
      console.warn('Ошибка при обработке forecastData в оптимизации:', e);
    }
    // Доходы уже куплены — не включаем их в список для покупки (оставляем только прогноз и погашение расходов)
    // Источник: текущие расходы (как снижение расходов)
    try {
      (ledgerExpenses||[]).forEach(r=>{
        if (!r || typeof r !== 'object') return; // Пропускаем некорректные записи
        
        // ИСКЛЮЧАЕМ строки с "нету" из оптимизации
        if (r.closed === true) return;
        
        const inv = parseFloat(r.payoff)||0; 
        const mon = parseFloat(r.amount)||0;
        
        // Проверяем корректность данных
        if (!isFinite(inv) || !isFinite(mon)) return;
        
        if (inv>0 && mon>0) {
          // Для расходов используем название из таблицы расходов, если оно есть
          let expenseName = '';
          if (r.name && String(r.name).trim()) {
            expenseName = String(r.name).trim();
          } else if (r.category === 'Банк. кредит') {
            expenseName = 'Кредит';
          } else {
            expenseName = r.category; // Используем категорию как название
          }
          
          items.push({
            id: 'e_'+r.id, 
            source:'expense', 
            category:r.category, 
            name: expenseName, 
            invest:inv, 
            monthly:mon, 
            type:'Расход'
          });
        }
      });
    } catch (e) {
      console.warn('Ошибка при обработке ledgerExpenses в оптимизации:', e);
    }

    // Базовые итоги
    let base = { totalIncome:0, passiveIncome:0, totalExpense:0, coef:0 };
    try { base = computeTotals(); } catch {}
    
    let currentExpense = parseFloat(base.totalExpense)||0;
    let currentPassive = parseFloat(base.passiveIncome)||0;
    
    // Проверяем корректность базовых значений
    if (!isFinite(currentExpense)) currentExpense = 0;
    if (!isFinite(currentPassive)) currentPassive = 0;
    
    let currentCoef = currentExpense>0 ? (currentPassive/currentExpense) : 0;
    if (!isFinite(currentCoef)) currentCoef = 0;

    let remain = budget;
    if (!isFinite(remain)) remain = 0;
    const chosen = [];

    // Копия массива доступных
    const pool = items.slice();
    // Добавим бесконечный источник "Дивиденды (юнит)" на основе текущих доходов дивидендов (инвест=цена, monthly=их ежемесячно/штук)
    try {
      (ledgerIncomes||[]).forEach(r=>{
        // Заложенные доходы учитываем как возможность выкупа обратно
        if (r && r.category==='Дивиденды' && (parseFloat(r.price)||0)>0 && (parseFloat(r.amount)||0)>0) {
          const unitInvest = parseFloat(r.price)||0;
          // amount в ведомости для дивидендов — это доход за шт., не делим на количество
          const unitMonthly = parseFloat(r.amount)||0;
          if (unitInvest>0 && unitMonthly>0 && isFinite(unitInvest) && isFinite(unitMonthly)) {
            pool.push({
              id:`div_unit_${r.id}`, source:'dividend_unit', category:r.category,
              name:(r.name||''), invest:unitInvest, monthly:unitMonthly,
              type:'Дивиденды', price: unitInvest, perUnit: unitMonthly, qty: 1
            });
          }
        }
      });
    } catch (e) {
      console.warn('Ошибка при добавлении дивидендов в пул оптимизации:', e);
    }
    
    // Добавим бесконечный источник "Дивиденды (юнит)" на основе прогнозов дивидендов
    try {
      (forecastData||[]).forEach(r=>{
        if (r && r.category==='Дивиденды' && (parseFloat(r.price)||0)>0 && (parseFloat(r.monthly)||0)>0 && !r.isDefault) {
          const unitInvest = parseFloat(r.price)||0;
          // monthly в прогнозе для дивидендов — это доход за шт.
          const unitMonthly = parseFloat(r.monthly)||0;
          if (unitInvest>0 && unitMonthly>0 && isFinite(unitInvest) && isFinite(unitMonthly)) {
            pool.push({
              id:`forecast_div_unit_${r.id}`, source:'forecast_dividend_unit', category:r.category,
              name:(r.name||''), invest:unitInvest, monthly:unitMonthly,
              type:'Прогноз', price: unitInvest, perUnit: unitMonthly, qty: 1
            });
          }
        }
      });
    } catch (e) {
      console.warn('Ошибка при добавлении прогнозов дивидендов в пул оптимизации:', e);
    }

    // Добавим заложенные доходы как возможность выкупа обратно
    try {
      (ledgerIncomes||[]).forEach(r=>{
        if (r && r.pledged && (parseFloat(r.pledgeAmount)||0)>0) {
          const pledgeAmount = parseFloat(r.pledgeAmount)||0;
          const monthlyIncome = parseFloat(r.amount)||0;
          
          if (pledgeAmount>0 && monthlyIncome>0 && isFinite(pledgeAmount) && isFinite(monthlyIncome)) {
            // Для дивидендов учитываем количество
            let totalMonthly = monthlyIncome;
            if (r.category==='Дивиденды'){
              const priceNum = parseFloat(r.price)||0;
              const investNum = parseFloat(r.invest)||0;
              if (priceNum>0 && investNum>0 && Math.abs(investNum/priceNum - Math.round(investNum/priceNum))<1e-9) {
                const qty = Math.floor(investNum/priceNum);
                totalMonthly = monthlyIncome * qty;
              }
            }
            
            if (totalMonthly>0) {
              pool.push({
                id:`pledge_${r.id}`, source:'pledge', category:r.category,
                name:(r.name||''), invest:pledgeAmount, monthly:totalMonthly,
                type:'Залог', isPledged: true
              });
            }
          }
        }
      });
    } catch (e) {
      console.warn('Ошибка при добавлении залогов в пул оптимизации:', e);
    }

    // Жадный выбор по максимальной маржинальной эффективности (ИСКЛЮЧАЕМ примеры)
    let iterationCount = 0;
    const maxIterations = 10000; // Увеличиваем лимит для больших бюджетов
    
    while (iterationCount < maxIterations){
      iterationCount++;
      let best = null;
      let bestScore = 0;
      for (const it of pool){
        if (!it || typeof it !== 'object') continue; // Пропускаем некорректные элементы
        
        // ИСКЛЮЧАЕМ примеры из оптимизации
        if (it.type === 'Пример' || it.isDefault || it.example) continue;
        
        const inv = parseFloat(it.invest)||0; 
        if (inv<=0 || !isFinite(inv)) continue;
        if (inv>remain) continue; // Только в рамках бюджета
        
        const mon = parseFloat(it.monthly)||0;
        if (!isFinite(mon)) continue;
        
        let delta = 0;
        if (it.source === 'expense'){
          const nextCoef = (currentExpense - mon)>0 ? (currentPassive / (currentExpense - mon)) : 0;
          delta = Math.max(0, nextCoef - currentCoef);
        } else if (it.source === 'pledge'){
          // Для залогов считаем как восстановление дохода
          if (currentExpense>0) delta = mon / currentExpense; else delta = 0;
        } else {
          if (currentExpense>0) delta = mon / currentExpense; else delta = 0;
        }
        if (delta <= 0 || !isFinite(delta)) continue;
        
        // ЭфКПК — маржинальная на единицу инвестиций
        const eff = (delta / inv) * (typeof EFKPK_SCALE!=='undefined'?EFKPK_SCALE:1) * 100;
        if (!isFinite(eff)) continue;
        
        // Основной критерий — eff, запасной — delta
        const score = (eff*10) + delta;
        if (score > bestScore && isFinite(score)){ 
          bestScore = score; 
          best = { ...it, delta, eff: eff*10 }; 
        }
      }
      if (!best) break;
      // Берем элемент
      chosen.push(best);
      remain -= best.invest;
      if (!isFinite(remain)) remain = 0;
      
      // Обновляем базу с проверкой корректности
      if (best.source === 'expense'){
        currentExpense = Math.max(0, currentExpense - best.monthly);
      } else if (best.source === 'pledge'){
        // Для залогов восстанавливаем пассивный доход
        currentPassive = currentPassive + best.monthly;
      } else {
        currentPassive = currentPassive + best.monthly;
      }
      
      // Проверяем корректность значений
      if (!isFinite(currentExpense)) currentExpense = 0;
      if (!isFinite(currentPassive)) currentPassive = 0;
      
      currentCoef = currentExpense>0 ? (currentPassive/currentExpense) : 0;
      if (!isFinite(currentCoef)) currentCoef = 0;
      
      // Удаляем из пула только конечные элементы; для юнитов дивидендов оставляем, чтобы можно было покупать многократно
      const idx = pool.findIndex(x=>x.id===best.id);
      if (idx>=0 && best.source!=='dividend_unit' && best.source!=='forecast_dividend_unit') pool.splice(idx,1);
      
      // Дополнительная проверка: если остаток бюджета слишком мал для любых доступных покупок, выходим
      const minInvestment = Math.min(...pool.map(item => parseFloat(item.invest) || Infinity));
      if (remain < minInvestment && minInvestment !== Infinity) {
        console.log(`Остаток бюджета ${remain} меньше минимальной инвестиции ${minInvestment}, завершаем оптимизацию`);
        break;
      }
    }
    
    // Проверяем, не превысили ли лимит итераций
    if (iterationCount >= maxIterations) {
      console.warn('Оптимизация остановлена по лимиту итераций');
    }
    
    // Логируем информацию об использовании бюджета
    const usedBudget = budget - remain;
    const usagePercent = (usedBudget / budget * 100).toFixed(1);
    console.log(`Оптимизация завершена: использовано ${usedBudget} из ${budget} (${usagePercent}%), остаток: ${remain}`);

    // Результаты
    if (!chosen.length){ out.innerHTML = '<div style="color:#888">Нет подходящих комбинаций в рамках бюджета</div>'; return; }

    // Итоги считаем только по реальным (не-пример) строкам
    const chosenReal = chosen.filter(c=> !c.example && !c.isDefault);
    const spent = chosenReal.reduce((a,c)=>a + (parseFloat(c.invest)||0), 0);
    const addPassive = chosenReal.filter(c=>c.source!=='expense').reduce((a,c)=>a + (parseFloat(c.monthly)||0), 0);
    const cutExpense = chosenReal.filter(c=>c.source==='expense').reduce((a,c)=>a + (parseFloat(c.monthly)||0), 0);
    const baseCoef = (parseFloat(base.totalExpense)||0)>0 ? ((parseFloat(base.passiveIncome)||0)/(parseFloat(base.totalExpense)||0)) : 0;
    const finalPassive = (parseFloat(base.passiveIncome)||0) + addPassive;
    const finalExpense = Math.max(0, (parseFloat(base.totalExpense)||0) - cutExpense);
    const finalCoef = finalExpense>0 ? (finalPassive/finalExpense) : 0;

    // Переменные для отслеживания накопленных значений
    let currentAccumulatedPassive = parseFloat(base.passiveIncome)||0;
    let currentAccumulatedExpense = parseFloat(base.totalExpense)||0;
    let currentAccumulatedCoef = currentAccumulatedExpense > 0 ? (currentAccumulatedPassive / currentAccumulatedExpense) : 0;

    // Верификационная таблица по шагам
    const rows = chosen.map((c,i)=>{
      const isDivUnit = c.source==='dividend_unit' || c.source==='forecast_dividend_unit';
      const price = (c.category==='Дивиденды') ? (parseFloat(c.price|| (isDivUnit?c.invest:0))||0) : '';
      const monthly = parseFloat(c.monthly)||0;
      const invest = parseFloat(c.invest)||0;
      const kpd = (monthly>0 && invest>0) ? ((monthly/invest)*100).toFixed(2)+'%' : '';
      const isExampleRow = !!c.example || !!c.isDefault;
      const typeLabel = isExampleRow ? 'Пример' : (c.type || (c.source==='expense'?'Расход': (isDivUnit?'Дивиденды':'Прогноз')));
      const qty = (c.category==='Дивиденды') ? (isDivUnit ? 1 : (parseFloat(c.qty)|| (price>0 ? Math.floor(invest/price) : ''))) : '';
      const perUnit = (c.category==='Дивиденды') ? (parseFloat(c.perUnit|| (isDivUnit?monthly : (qty? (monthly/qty): 0)))||0) : '';
      
      // Рассчитываем накопленные значения после текущей покупки (только для не-примеров)
      if (!isExampleRow) {
        if (c.source === 'expense') {
          // Если это погашение расхода, уменьшаем расходы
          currentAccumulatedExpense = Math.max(0, currentAccumulatedExpense - monthly);
        } else {
          // Если это доход, увеличиваем пассивный доход
          currentAccumulatedPassive += monthly;
        }
        currentAccumulatedCoef = currentAccumulatedExpense > 0 ? (currentAccumulatedPassive / currentAccumulatedExpense) : 0;
      }
      
      // Форматируем значения для отображения
      const displayPassive = isExampleRow ? '' : fmtPretty(currentAccumulatedPassive, 0);
      const displayExpense = isExampleRow ? '' : fmtPretty(currentAccumulatedExpense, 0);
      const displayCoef = isExampleRow ? '' : currentAccumulatedCoef.toFixed(3);
      
      return `<tr${isExampleRow ? ' style="background:#f2f2f2;color:#888"' : ''}>
        <td style="text-align:center"><input type="checkbox" class="optimizerChk" data-id="${c.id}" style="margin:0;cursor:pointer" onchange="updateOptimizerSummary()"></td>
        <td style="text-align:center">${i+1}</td>
        <td style="text-align:center;color:#080">+${((c.eff||0)).toFixed(2)}%</td>
        <td style="text-align:center">+${(c.delta||0).toFixed(3)}</td>
        <td style="text-align:center">${kpd}</td>
        <td style="text-align:center">${escapeHtml(c.name||'')}</td>
        <td style="text-align:center;${isExampleRow ? 'color:#888' : (c.source==='expense'?'color:#c33':'color:#080')}">${c.source==='expense'?'-':''}${fmtPretty(monthly,0)}</td>
        <td style="text-align:center">${fmtPretty(invest,0)}</td>
        <td style="text-align:center">${escapeHtml(c.category||'')}</td>
        <td style=\"text-align:center\">${escapeHtml(typeLabel)}</td>
        <td style=\"text-align:center;${isExampleRow ? 'color:#888' : 'color:#080'}\">${displayPassive}</td>
        <td style=\"text-align:center;${isExampleRow ? 'color:#888' : 'color:#c33'}\">${displayExpense}</td>
        <td style=\"text-align:center;${isExampleRow ? 'color:#888' : 'color:#080'}\">${displayCoef}</td>
        <td style=\"text-align:center\">${(c.category==='Дивиденды' && perUnit)?fmtPretty(perUnit,0):''}</td>
        <td style=\"text-align:center\">${(c.category==='Дивиденды' && qty)?qty:''}</td>
        <td style=\"text-align:center\">${(c.category==='Дивиденды' && price)?fmtPretty(price,0):''}</td>
      </tr>`;
    }).join('');
    
    // Добавляем строки "примеры" в основную таблицу как серые строки (не влияющие на расчеты)
    const exampleRows = [];
    let exampleIndex = 0;
    try {
      (forecastData||[]).forEach(r=>{
        if (r && r.isDefault && typeof r === 'object') {
          const inv = parseFloat(r.invest)||0;
          const mon = parseFloat(r.monthly)||0;
          const price = parseFloat(r.price)||0;
          const cat = r.category||'';
          const name = r.name||'';
          
          if (inv>0 && mon>0) {
            let monthlyTotal = mon;
            let qty = '';
            let perUnit = '';
            
            // Обработка дивидендов
            if (cat==='Дивиденды' && price>0) {
              if (Math.abs(inv/price - Math.round(inv/price)) < 1e-9) {
                qty = Math.floor(inv/price);
                monthlyTotal = mon * qty;
                perUnit = mon;
              }
            }
            
            const kpd = (monthlyTotal>0 && inv>0) ? ((monthlyTotal/inv)*100).toFixed(2)+'%' : '';
            
            // Вычисляем ЭфКПК и КПК для примеров (но они не влияют на показатели)
            let effKpk = '';
            let kpk = '';
            try {
              const totals = typeof computeTotals === 'function' ? computeTotals() : { totalExpense: 0, passiveIncome: 0, coef: 0 };
              const totalExpense = parseFloat(totals.totalExpense) || 0;
              const passiveIncome = parseFloat(totals.passiveIncome) || 0;
              const coef = parseFloat(totals.coef) || 0;
              if (monthlyTotal > 0) {
                let delta = 0;
                if (totalExpense > 0) delta = monthlyTotal / totalExpense;
                if (delta > 0) {
                  kpk = `+${delta.toFixed(3)}`;
                  if (inv > 0) {
                    const scale = (typeof EFKPK_SCALE !== 'undefined') ? EFKPK_SCALE : 1;
                    const eff = (delta / inv) * scale * 100;
                    effKpk = `+${(eff*10).toFixed(2)}%`;
                  }
                }
              }
            } catch {}
            
            exampleIndex++;
            exampleRows.push(`<tr style="background:#f2f2f2;color:#888" data-is-example="true">
              <td style="text-align:center;color:#888"><input type="checkbox" class="optimizerChk" data-id="example_${exampleIndex}" style="margin:0;cursor:pointer" onchange="updateOptimizerSummary()"></td>
              <td style="text-align:center;color:#888">${chosen.length + exampleIndex}</td>
              <td style="text-align:center;color:#888">${effKpk}</td>
              <td style="text-align:center;color:#888">${kpk}</td>
              <td style="text-align:center;color:#888">${kpd}</td>
              <td style="text-align:center;color:#888">${escapeHtml(name)}</td>
              <td style="text-align:center;color:#888">${fmtPretty(monthlyTotal,0)}</td>
              <td style="text-align:center;color:#888">${fmtPretty(inv,0)}</td>
              <td style="text-align:center;color:#888">${escapeHtml(cat)}</td>
              <td style="text-align:center;color:#888">Пример</td>
              <td style="text-align:center;color:#888"></td>
              <td style="text-align:center;color:#888"></td>
              <td style="text-align:center;color:#888"></td>
              <td style="text-align:center;color:#888">${(cat==='Дивиденды' && perUnit)?fmtPretty(perUnit,0):''}</td>
              <td style="text-align:center;color:#888">${qty}</td>
              <td style="text-align:center;color:#888">${(cat==='Дивиденды' && price)?fmtPretty(price,0):''}</td>
            </tr>`);
          }
        }
      });
    } catch (e) {
      console.warn('Ошибка при добавлении примеров в таблицу оптимизации:', e);
    }
    
    // Объединяем основные строки с серыми примерами
    const allRows = rows + exampleRows.join('');

          out.innerHTML = `
      <div style="margin-bottom:8px">Бюджет: <b style=\"color:#6d28d9\">${fmtPretty(budget,0)} $</b> • Потрачено: <b style=\"color:#6d28d9\">${fmtPretty(spent,0)} $</b> • Остаток: <b style=\"color:#6d28d9\">${fmtPretty(budget-spent,0)} $</b> • Использовано: <b style=\"color:#6d28d9\">${usagePercent}%</b></div>
      <div style="margin-bottom:8px">Пассив: <b>${fmtPretty(parseFloat(base.passiveIncome)||0,0)} → ${fmtPretty(finalPassive,0)}$ <span style="color:#080">(+${fmtPretty(addPassive,0)}$)</span></b></div>
      <div style="margin-bottom:8px">Расход: <b>${fmtPretty(parseFloat(base.totalExpense)||0,0)} → ${fmtPretty(finalExpense,0)}$ <span style="color:#c33">(-${fmtPretty(cutExpense,0)}$)</span></b></div>
      <div style="margin-bottom:8px">Коэффициент: ${baseCoef.toFixed(3)} → ${finalCoef.toFixed(3)} (+${(finalCoef - baseCoef).toFixed(3)}, х${baseCoef > 0 ? (finalCoef / baseCoef).toFixed(1) : '∞'})</div>
      <!-- Сводка по отмеченным галочкам -->
      <div class="optimizer-summary" style="margin:8px 0;padding:8px;background:#f8f9fa;border:1px solid #dee2e6;border-radius:4px;font-size:13px;">
        <div style="margin-bottom:6px">Сумма: <b style="color:#2563eb">0 $</b></div>
        Пасив: <b style="color:#080">0 $</b><br>
        Расход: <b style="color:#c33">-0 $</b><br>
        <br>
        ЭфКПК: <b>+0.00%</b><br>
        КПК: <b>+0.000</b><br>
        КПД: <b>0.00%</b><br>
        <div style="margin-top:6px;padding-top:6px;border-top:1px solid #cdeccd">
          Коэффициент: <b style="color:#ffd700">${baseCoef.toFixed(3)}</b>
          <span style="color:#666;font-size:12px;margin-left:6px;font-weight:400">(+0.000, х1.0)</span><br>
          Пассивный доход: <b style="color:#080">${fmtPretty(Math.round(parseFloat(base.passiveIncome)||0),0)} $</b>
          <span style="color:#666;font-size:12px;margin-left:6px;font-weight:400">(0)</span><br>
          Расход: <b style="color:#c33">${fmtPretty(Math.round(parseFloat(base.totalExpense)||0),0)} $</b>
          <span style="color:#666;font-size:12px;margin-left:6px;font-weight:400">(0)</span>
        </div>
      </div>
      <!-- Кнопки переключения видов таблицы -->
      <div id="optCollapseControls" style="margin:8px 0;display:block">
        <button class="btn" id="optView1Btn" onclick="setOptimizerView(1)" style="background:#4a90e2;font-size:13px;padding:6px 12px">Вид 1</button>
        <button class="btn" id="optView2Btn" onclick="setOptimizerView(2)" style="background:#6c757d;font-size:13px;padding:6px 12px;margin-left:8px">Вид 2</button>
        <button class="btn" id="optView3Btn" onclick="setOptimizerView(3)" style="background:#6c757d;font-size:13px;padding:6px 12px;margin-left:8px">Вид 3</button>
      </div>
      <div class="table-scroll-container">
        <table id="optimizerTable" style="width:100%;border-collapse:collapse;font-size:13px;text-align:center">
          <thead>
            <tr>
              <th style="border:1px solid #ddd;padding:6px;background:#f3e8ff;color:#4c1d95;text-align:center">✓</th>
              <th style="border:1px solid #ddd;padding:6px;background:#f3e8ff;color:#4c1d95;text-align:center">№</th>
              <th style="border:1px solid #ddd;padding:6px;background:#f3e8ff;color:#4c1d95;text-align:center">ЭфКПК</th>
              <th style="border:1px solid #ddd;padding:6px;background:#f3e8ff;color:#4c1d95;text-align:center">КПК</th>
              <th style="border:1px solid #ddd;padding:6px;background:#f3e8ff;color:#4c1d95;text-align:center">КПД</th>
              <th style="border:1px solid #ddd;padding:6px;background:#f3e8ff;color:#4c1d95;text-align:center">Название</th>
              <th style="border:1px solid #ddd;padding:6px;background:#f3e8ff;color:#4c1d95;text-align:center">Ежемесячно</th>
              <th style="border:1px solid #ddd;padding:6px;background:#f3e8ff;color:#4c1d95;text-align:center">Инвестиции</th>
              <th style="border:1px solid #ddd;padding:6px;background:#f3e8ff;color:#4c1d95;text-align:center">Категория</th>
              <th style="border:1px solid #ddd;padding:6px;background:#f3e8ff;color:#4c1d95;text-align:center">Тип</th>
              <th style="border:1px solid #ddd;padding:6px;background:#f3e8ff;color:#4c1d95;text-align:center">Пассив</th>
              <th style="border:1px solid #ddd;padding:6px;background:#f3e8ff;color:#4c1d95;text-align:center">Расход</th>
              <th style="border:1px solid #ddd;padding:6px;background:#f3e8ff;color:#4c1d95;text-align:center">Кэф</th>
              <th style="border:1px solid #ddd;padding:6px;background:#f3e8ff;color:#4c1d95;text-align:center">Ежемес<br>за шт.</th>
              <th style="border:1px solid #ddd;padding:6px;background:#f3e8ff;color:#4c1d95;text-align:center">Штук</th>
              <th style="border:1px solid #ddd;padding:6px;background:#f3e8ff;color:#4c1d95;text-align:center">Цена за шт.</th>
            </tr>
          </thead>
          <tbody>${allRows}</tbody>
        </table>
      </div>
      
      `;
    
          // Сохраняем данные для сворачивания
      const exampleItems = (forecastData || []).filter(item => item && item.isDefault);
      console.log('Оптимизация завершена, найдено серых строк:', exampleItems.length, exampleItems);
      window.optimizerData = { 
        chosen, 
        budget, 
        spent, 
        addPassive, 
        cutExpense, 
        baseCoef, 
        finalCoef, 
        exampleRows: [],
        exampleRowsHtml: exampleRows.join('') // Сохраняем HTML серых строк
      };
      // Сбрасываем состояние сворачивания
      window.optimizerCollapsed = false;
      window.optimizerGroupsCollapsed = false;
      
      // Автоматически применяем Вид 3 (самый краткий) после формирования таблицы
      setTimeout(() => {
        if (typeof setOptimizerView === 'function') {
          setOptimizerView(3);
        }
      }, 100);
  }catch(e){
    try{ document.getElementById('optResult').innerHTML = '<div style="color:#c33">Ошибка в оптимизаторе</div>'; }catch{}
    console.warn('runOptimization error', e);
  }
}

// Функция для обновления сводки по отмеченным галочкам в оптимизаторе
function updateOptimizerSummary() {
  try {
    if (!window.optimizerData || !window.optimizerData.chosen) return;
    
    const chosen = window.optimizerData.chosen;
    const chks = document.querySelectorAll('.optimizerChk:checked');
    let sumInvest = 0;
    let sumPassiveAdd = 0;
    let sumExpenseReduce = 0;
    
    chks.forEach(ch => {
      const id = ch.getAttribute('data-id');
      if (id.startsWith('example_')) {
        // Это строка примера, пропускаем
        return;
      }
      
      if (id.startsWith('group_')) {
        // Это групповая галочка, обрабатываем все элементы группы
        const groupIds = id.replace('group_', '').split('_');
        const firstIndex = parseInt(groupIds[0]) - 1;
        const lastIndex = parseInt(groupIds[1]) - 1;
        
        for (let i = firstIndex; i <= lastIndex; i++) {
          if (i >= 0 && i < chosen.length) {
            const row = chosen[i];
            const inv = parseFloat(row.invest) || 0;
            let mon = parseFloat(row.monthly) || 0;
            
            if (row.category === 'Дивиденды' && row.source !== 'expense') {
              const priceNum = parseFloat(row.price) || 0;
              if (priceNum > 0 && inv > 0 && Math.abs(inv/priceNum - Math.round(inv/priceNum)) < 1e-9) {
                const qty = Math.floor(inv/priceNum);
                mon = mon * qty;
              } else if (priceNum > 0) {
                mon = 0;
              }
            }
            
            sumInvest += inv;
            if (row.source === 'expense') {
              sumExpenseReduce += mon;
            } else {
              sumPassiveAdd += mon;
            }
          }
        }
        return;
      }
      
      const row = chosen.find(r => String(r.id) === String(id));
      if (!row) return;
      
      const inv = parseFloat(row.invest) || 0;
      let mon = parseFloat(row.monthly) || 0;
      
      if (row.category === 'Дивиденды' && row.source !== 'expense') {
        const priceNum = parseFloat(row.price) || 0;
        if (priceNum > 0 && inv > 0 && Math.abs(inv/priceNum - Math.round(inv/priceNum)) < 1e-9) {
          const qty = Math.floor(inv/priceNum);
          mon = mon * qty;
        } else if (priceNum > 0) {
          mon = 0;
        }
      }
      
      sumInvest += inv;
      if (row.source === 'expense') {
        sumExpenseReduce += mon;
      } else {
        sumPassiveAdd += mon;
      }
    });

    // Базовые текущие итоги
    let baseTotals = { totalIncome: 0, passiveIncome: 0, totalExpense: 0, coef: 0 };
    try { baseTotals = computeTotals(); } catch {}

    // Сценарные итоги с учётом выбранных галочек
    const scenarioPassive = (parseFloat(baseTotals.passiveIncome) || 0) + sumPassiveAdd;
    const scenarioExpense = Math.max(0, (parseFloat(baseTotals.totalExpense) || 0) - sumExpenseReduce);
    const scenarioCoef = scenarioExpense > 0 ? (scenarioPassive / scenarioExpense) : 0;
    const baseCoef = parseFloat(baseTotals.coef) || 0;

    // Сводные метрики по сумме
    const sumMonthlyNet = sumPassiveAdd + sumExpenseReduce;
    const kpdNum = (sumInvest > 0) ? ((sumMonthlyNet/sumInvest) * 100) : 0;
    const fmtSigned = (num, digits = 3) => {
      const n = Number(num || 0);
      const s = n.toFixed(digits);
      if (n > 0) return '+' + s; if (n < 0) return s; return '+0' + (digits ? ('.' + '0'.repeat(digits)) : '');
    };
    const fmtSignedPct = (num, digits = 2) => {
      const n = Number(num || 0);
      const s = n.toFixed(digits);
      if (n > 0) return '+' + s + '%'; if (n < 0) return s + '%'; return '+0.00%';
    };
    
    let kpkStr = '+0.000';
    let effStr = '+0.00%';

    const dCoef = scenarioCoef - baseCoef;
    const dCoefPos = Math.max(0, dCoef);
    kpkStr = fmtSigned(dCoefPos, 3);
    if (sumInvest > 0) {
      const eff = (dCoefPos / sumInvest) * (typeof EFKPK_SCALE !== 'undefined' ? EFKPK_SCALE : 1) * 100 * 10;
      effStr = fmtSignedPct(eff, 2);
    }

    // Обновляем сводку в оптимизаторе
    const summaryDiv = document.getElementById('optResult');
    if (summaryDiv) {
      const existingSummary = summaryDiv.querySelector('.optimizer-summary');
      if (existingSummary) {
        existingSummary.innerHTML = `
          <div style="margin-bottom:6px">Сумма: <b style="color:#2563eb">${fmtPretty(sumInvest,0)} $</b></div>
          Пасив: <b style="color:#080">${fmtPretty(Math.round(sumPassiveAdd),0)} $</b><br>
          Расход: <b style="color:#c33">-${fmtPretty(Math.round(sumExpenseReduce),0)} $</b><br>
          <br>
          ЭфКПК: <b>${effStr}</b><br>
          КПК: <b>${kpkStr}</b><br>
          КПД: <b>${kpdNum.toFixed(2)}%</b><br>
          <div style="margin-top:6px;padding-top:6px;border-top:1px solid #cdeccd">
            Коэффициент: <b style="color:#ffd700">${scenarioCoef.toFixed(3)}</b>
            <span style="color:#666;font-size:12px;margin-left:6px;font-weight:400">(${fmtSigned(dCoef,3)}, х${baseCoef > 0 ? (scenarioCoef / baseCoef).toFixed(1) : '∞'})</span><br>
            Пассивный доход: <b style="color:#080">${fmtPretty(Math.round(scenarioPassive),0)} $</b>
            <span style="color:#666;font-size:12px;margin-left:6px;font-weight:400">(${scenarioPassive > (parseFloat(baseTotals.passiveIncome) || 0) ? '+' : ''}${fmtPretty(Math.abs(Math.round(scenarioPassive - (parseFloat(baseTotals.passiveIncome) || 0))),0)})</span><br>
            Расход: <b style="color:#c33">${fmtPretty(Math.round(scenarioExpense),0)} $</b>
            <span style="color:#666;font-size:12px;margin-left:6px;font-weight:400">(${scenarioExpense < (parseFloat(baseTotals.totalExpense) || 0) ? '+' : ''}${fmtPretty(Math.round((parseFloat(baseTotals.totalExpense) || 0) - scenarioExpense),0)})</span>
          </div>
        `;
      }
    }
  } catch (e) {
    console.warn('updateOptimizerSummary error', e);
  }
}

// Функция для переключения сворачивания/разворачивания дублирующихся строк в оптимизаторе
function toggleOptimizerDuplicates() {
  try {
    if (!window.optimizerData || !window.optimizerData.chosen) return;
    
    const isCollapsed = window.optimizerCollapsed;
    const chosen = window.optimizerData.chosen;
    const table = document.getElementById('optimizerTable');
    const toggleBtn = document.getElementById('optCollapseBtn');
    
    if (!table || !toggleBtn) return;
    
    if (!isCollapsed) {
      // Сворачиваем дубликаты
      // Группируем только строки с категорией "Дивиденды"
      const groups = {};
      chosen.forEach((item, index) => {
        // Сворачиваем только дивиденды
        if (item.category !== 'Дивиденды') {
          // Для не-дивидендов создаем отдельную группу для каждой строки
          const key = `non_dividend_${index}`;
          groups[key] = {
            items: [{ ...item, originalIndex: index + 1 }],
            firstIndex: index + 1,
            lastIndex: index + 1
          };
        } else {
          // Для дивидендов группируем по ключевым параметрам
          const key = `${item.source}_${item.category}_${item.name}_${item.type}_${item.price || ''}_${item.perUnit || ''}_${item.monthly}_${item.invest}_${(item.eff || 0).toFixed(2)}_${(item.delta || 0).toFixed(3)}`;
          if (!groups[key]) {
            groups[key] = {
              items: [],
              firstIndex: index + 1,
              lastIndex: index + 1
            };
          }
          groups[key].items.push({ ...item, originalIndex: index + 1 });
          groups[key].lastIndex = index + 1;
        }
      });
      
      // Создаем свернутые строки
      const collapsedRows = Object.values(groups).map(group => {
        if (group.items.length === 1) {
          // Одна строка - оставляем как есть
          const item = group.items[0];
          return `<tr>
            <td style="text-align:center"><input type="checkbox" class="optimizerChk" data-id="${item.id}" style="margin:0;cursor:pointer" onchange="updateOptimizerSummary()"></td>
            <td style="text-align:center">${item.originalIndex}</td>
            <td style="text-align:center;color:#080">+${((item.eff||0)).toFixed(2)}%</td>
            <td style="text-align:center">+${(item.delta||0).toFixed(3)}</td>
            <td style="text-align:center">${(item.monthly>0 && item.invest>0) ? ((item.monthly/item.invest)*100).toFixed(2)+'%' : ''}</td>
            <td style="text-align:center">${escapeHtml(item.name||'')}</td>
            <td style="text-align:center;${item.source==='expense'?'color:#c33':'color:#080'}">${item.source==='expense'?'-':''}${fmtPretty(item.monthly,0)}</td>
            <td style="text-align:center">${fmtPretty(item.invest,0)}</td>
            <td style="text-align:center">${escapeHtml(item.category||'')}</td>
            <td style="text-align:center">${escapeHtml(item.type || (item.source==='expense'?'Расход': (item.source==='dividend_unit'?'Дивиденды':(item.isDefault?'Пример':'Прогноз'))))}</td>
            <td style="text-align:center">${(item.category==='Дивиденды' && item.perUnit)?fmtPretty(item.perUnit,0):''}</td>
            <td style="text-align:center">${(item.category==='Дивиденды' && item.qty)?item.qty:''}</td>
            <td style="text-align:center">${(item.category==='Дивиденды' && item.price)?fmtPretty(item.price,0):''}</td>
          </tr>`;
        } else {
          // Несколько строк - сворачиваем
          const firstItem = group.items[0];
          const totalMonthly = group.items.reduce((sum, item) => sum + (parseFloat(item.monthly)||0), 0);
          const totalInvest = group.items.reduce((sum, item) => sum + (parseFloat(item.invest)||0), 0);
          const totalDelta = group.items.reduce((sum, item) => sum + (parseFloat(item.delta)||0), 0);
          const totalEff = group.items.reduce((sum, item) => sum + (parseFloat(item.eff||0)), 0);
          
          // Рассчитываем средние значения для процентов
          const avgKpd = totalInvest > 0 ? (totalMonthly / totalInvest * 100) : 0;
          const avgEff = group.items.length > 0 ? (totalEff / group.items.length) : 0;
          
          return `<tr>
            <td style="text-align:center"><input type="checkbox" class="optimizerChk" data-id="group_${group.firstIndex}_${group.lastIndex}" style="margin:0;cursor:pointer" onchange="updateOptimizerSummary()"></td>
            <td style="text-align:center">${group.firstIndex}-${group.lastIndex}</td>
            <td style="text-align:center;color:#080">+${avgEff.toFixed(2)}%</td>
            <td style="text-align:center">+${totalDelta.toFixed(3)}</td>
            <td style="text-align:center">${avgKpd.toFixed(2)}%</td>
            <td style="text-align:center">${escapeHtml(firstItem.name||'')}</td>
            <td style="text-align:center;${firstItem.source==='expense'?'color:#c33':'color:#080'}">${firstItem.source==='expense'?'-':''}${fmtPretty(totalMonthly,0)}</td>
            <td style="text-align:center">${fmtPretty(totalInvest,0)}</td>
            <td style="text-align:center">${escapeHtml(firstItem.category||'')}</td>
            <td style="text-align:center">${escapeHtml(firstItem.type || (firstItem.source==='expense'?'Расход': (firstItem.source==='dividend_unit'?'Дивиденды':(firstItem.isDefault?'Пример':'Прогноз'))))}</td>
            <td style="text-align:center">${(firstItem.category==='Дивиденды' && firstItem.perUnit)?fmtPretty(firstItem.perUnit,0):''}</td>
            <td style="text-align:center">${group.items.length}</td>
            <td style="text-align:center">${(firstItem.category==='Дивиденды' && firstItem.price)?fmtPretty(firstItem.price,0):''}</td>
          </tr>`;
        }
      }).join('');
      
      // Генерируем HTML для серых строк-примеров (берем из исходных данных)
      const exampleRows = (forecastData || []).filter(item => item && item.isDefault);
      let exampleRowsHtml = '';
      if (exampleRows.length > 0) {
        exampleRowsHtml = exampleRows.map((item, i) => {
          const inv = parseFloat(item.invest)||0;
          const mon = parseFloat(item.monthly)||0;
          const price = parseFloat(item.price)||0;
          const cat = item.category||'';
          const name = item.name||'';
          
          if (inv>0 && mon>0) {
            let monthlyTotal = mon;
            let qty = '';
            let perUnit = '';
            
            // Обработка дивидендов
            if (cat==='Дивиденды' && price>0) {
              if (Math.abs(inv/price - Math.round(inv/price)) < 1e-9) {
                qty = Math.floor(inv/price);
                monthlyTotal = mon * qty;
                perUnit = mon;
              }
            }
            
            const kpd = (monthlyTotal>0 && inv>0) ? ((monthlyTotal/inv)*100).toFixed(2)+'%' : '';
            
            // Вычисляем ЭфКПК и КПК для примеров (но они не влияют на показатели)
            let effKpk = '';
            let kpk = '';
            try {
              const totals = typeof computeTotals === 'function' ? computeTotals() : { totalExpense: 0, passiveIncome: 0, coef: 0 };
              const totalExpense = parseFloat(totals.totalExpense) || 0;
              const passiveIncome = parseFloat(totals.passiveIncome) || 0;
              const coef = parseFloat(totals.coef) || 0;
              if (monthlyTotal > 0) {
                let delta = 0;
                if (totalExpense > 0) delta = monthlyTotal / totalExpense;
                if (delta > 0) {
                  kpk = `+${delta.toFixed(3)}`;
                  if (inv > 0) {
                    const scale = (typeof EFKPK_SCALE !== 'undefined') ? EFKPK_SCALE : 1;
                    const eff = (delta / inv) * scale * 100;
                    effKpk = `+${(eff*10).toFixed(2)}%`;
                  }
                }
              }
            } catch {}
            
            return `<tr style="background:#f2f2f2;color:#888" data-is-example="true">
              <td style="text-align:center;color:#888"><input type="checkbox" class="optimizerChk" data-id="example_${i}" style="margin:0;cursor:pointer" onchange="updateOptimizerSummary()"></td>
              <td style="text-align:center;color:#888">${chosen.length + i + 1}</td>
              <td style="text-align:center;color:#888">${effKpk}</td>
              <td style="text-align:center;color:#888">${kpk}</td>
              <td style="text-align:center;color:#888">${kpd}</td>
              <td style="text-align:center;color:#888">${escapeHtml(name)}</td>
              <td style="text-align:center;color:#888">${fmtPretty(monthlyTotal,0)}</td>
              <td style="text-align:center;color:#888">${fmtPretty(inv,0)}</td>
              <td style="text-align:center;color:#888">${escapeHtml(cat)}</td>
              <td style="text-align:center;color:#888">Пример</td>
              <td style="text-align:center;color:#888">${(cat==='Дивиденды' && perUnit)?fmtPretty(perUnit,0):''}</td>
              <td style="text-align:center;color:#888">${qty}</td>
              <td style="text-align:center;color:#888">${(cat==='Дивиденды' && price)?fmtPretty(price,0):''}</td>
            </tr>`;
          }
          return '';
        }).join('');
      }
      
      // Обновляем таблицу
      const tbody = table.querySelector('tbody');
      if (tbody) {
        tbody.innerHTML = collapsedRows + exampleRowsHtml;
      }
      
      // Сохраняем HTML серых строк для последующего использования
      window.optimizerData.exampleRowsHtml = exampleRowsHtml;
      
      // Меняем кнопку на "Развернуть дубликаты"
      toggleBtn.textContent = 'Развернуть дубликаты дивидендов';
      toggleBtn.style.background = '#28a745';
      
      // Показываем вторую кнопку для группировки
      const groupsBtn = document.getElementById('optCollapseGroupsBtn');
      if (groupsBtn) {
        groupsBtn.style.display = 'inline-block';
      }
      
      // Сохраняем состояние
      window.optimizerCollapsed = true;
      
    } else {
      // Разворачиваем дубликаты
      // Восстанавливаем оригинальные строки
      const originalRows = chosen.map((item, index) => {
        const isDivUnit = item.source==='dividend_unit';
        const price = (item.category==='Дивиденды') ? (parseFloat(item.price|| (isDivUnit?item.invest:0))||0) : '';
        const monthly = parseFloat(item.monthly)||0;
        const invest = parseFloat(item.invest)||0;
        const kpd = (monthly>0 && invest>0) ? ((monthly/invest)*100).toFixed(2)+'%' : '';
        const typeLabel = item.type || (item.source==='expense'?'Расход': (isDivUnit?'Дивиденды':(item.isDefault?'Пример':'Прогноз')));
        const qty = (item.category==='Дивиденды') ? (isDivUnit ? 1 : (parseFloat(item.qty)|| (price>0 ? Math.floor(invest/price) : ''))) : '';
        const perUnit = (item.category==='Дивиденды') ? (parseFloat(item.perUnit|| (isDivUnit?monthly : (qty? (monthly/qty): 0)))||0) : '';
        
        return `<tr>
          <td style="text-align:center"><input type="checkbox" class="optimizerChk" data-id="${item.id}" style="margin:0;cursor:pointer" onchange="updateOptimizerSummary()"></td>
          <td style="text-align:center">${index+1}</td>
          <td style="text-align:center;color:#080">+${((item.eff||0)).toFixed(2)}%</td>
          <td style="text-align:center">+${(item.delta||0).toFixed(3)}</td>
          <td style="text-align:center">${kpd}</td>
          <td style="text-align:center">${escapeHtml(item.name||'')}</td>
          <td style="text-align:center;${item.source==='expense'?'color:#c33':'color:#080'}">${item.source==='expense'?'-':''}${fmtPretty(monthly,0)}</td>
          <td style="text-align:center">${fmtPretty(invest,0)}</td>
          <td style="text-align:center">${escapeHtml(item.category||'')}</td>
          <td style="text-align:center">${escapeHtml(typeLabel)}</td>
          <td style="text-align:center">${(item.category==='Дивиденды' && perUnit)?fmtPretty(perUnit,0):''}</td>
          <td style="text-align:center">${(item.category==='Дивиденды' && qty)?qty:''}</td>
          <td style="text-align:center">${(item.category==='Дивиденды' && price)?fmtPretty(price,0):''}</td>
        </tr>`;
      }).join('');
      
      // Обновляем таблицу
      const tbody = table.querySelector('tbody');
      if (tbody) {
        tbody.innerHTML = originalRows;
      }
      
      // Добавляем серые строки-примеры после основных (берем из исходных данных)
      const exampleRows = (forecastData || []).filter(item => item && item.isDefault);
      console.log('Разворачиваем дубликаты, найдено серых строк:', exampleRows.length, exampleRows);
      if (exampleRows.length > 0) {
        const exampleRowsHtml = exampleRows.map((item, i) => {
          const inv = parseFloat(item.invest)||0;
          const mon = parseFloat(item.monthly)||0;
          const price = parseFloat(item.price)||0;
          const cat = item.category||'';
          const name = item.name||'';
          
          if (inv>0 && mon>0) {
            let monthlyTotal = mon;
            let qty = '';
            let perUnit = '';
            
            // Обработка дивидендов
            if (cat==='Дивиденды' && price>0) {
              if (Math.abs(inv/price - Math.round(inv/price)) < 1e-9) {
                qty = Math.floor(inv/price);
                monthlyTotal = mon * qty;
                perUnit = mon;
              }
            }
            
            const kpd = (monthlyTotal>0 && inv>0) ? ((monthlyTotal/inv)*100).toFixed(2)+'%' : '';
            
            // Вычисляем ЭфКПК и КПК для примеров (но они не влияют на показатели)
            let effKpk = '';
            let kpk = '';
            try {
              const totals = typeof computeTotals === 'function' ? computeTotals() : { totalExpense: 0, passiveIncome: 0, coef: 0 };
              const totalExpense = parseFloat(totals.totalExpense) || 0;
              const passiveIncome = parseFloat(totals.passiveIncome) || 0;
              const coef = parseFloat(totals.coef) || 0;
              if (monthlyTotal > 0) {
                let delta = 0;
                if (totalExpense > 0) delta = monthlyTotal / totalExpense;
                if (delta > 0) {
                  kpk = `+${delta.toFixed(3)}`;
                  if (inv > 0) {
                    const scale = (typeof EFKPK_SCALE !== 'undefined') ? EFKPK_SCALE : 1;
                    const eff = (delta / inv) * scale * 100;
                    effKpk = `+${(eff*10).toFixed(2)}%`;
                  }
                }
              }
            } catch {}
            
            return `<tr style="background:#f2f2f2;color:#888" data-is-example="true">
              <td style="text-align:center;color:#888"><input type="checkbox" class="optimizerChk" data-id="example_${i}" style="margin:0;cursor:pointer" onchange="updateOptimizerSummary()"></td>
              <td style="text-align:center;color:#888">${chosen.length + i + 1}</td>
              <td style="text-align:center;color:#888">${effKpk}</td>
              <td style="text-align:center;color:#888">${kpk}</td>
              <td style="text-align:center;color:#888">${kpd}</td>
              <td style="text-align:center;color:#888">${escapeHtml(name)}</td>
              <td style="text-align:center;color:#888">${fmtPretty(monthlyTotal,0)}</td>
              <td style="text-align:center;color:#888">${fmtPretty(inv,0)}</td>
              <td style="text-align:center;color:#888">${escapeHtml(cat)}</td>
              <td style="text-align:center;color:#888">Пример</td>
              <td style="text-align:center;color:#888">${(cat==='Дивиденды' && perUnit)?fmtPretty(perUnit,0):''}</td>
              <td style="text-align:center;color:#888">${qty}</td>
              <td style="text-align:center;color:#888">${(cat==='Дивиденды' && price)?fmtPretty(price,0):''}</td>
            </tr>`;
          }
          return '';
        }).join('');
        
        tbody.innerHTML += exampleRowsHtml;
      }
      
      // Меняем кнопку обратно на "Свернуть дубликаты"
      toggleBtn.textContent = 'Свернуть дубликаты дивидендов';
      toggleBtn.style.background = '#6c757d';
      
      // Скрываем вторую кнопку для группировки
      const groupsBtn = document.getElementById('optCollapseGroupsBtn');
      if (groupsBtn) {
        groupsBtn.style.display = 'none';
      }
      
      // Сбрасываем состояние группировки
      window.optimizerGroupsCollapsed = false;
      
      // Сохраняем состояние
      window.optimizerCollapsed = false;
    }
    
  } catch (e) {
    console.warn('Ошибка при переключении дубликатов:', e);
  }
}

// Функция для переключения группировки по названию, ежемесячному доходу за единицу и цене за единицу
function toggleOptimizerGroups() {
  try {
    if (!window.optimizerData || !window.optimizerData.chosen) return;
    
    const isGroupsCollapsed = window.optimizerGroupsCollapsed;
    const chosen = window.optimizerData.chosen;
    const table = document.getElementById('optimizerTable');
    const toggleBtn = document.getElementById('optCollapseGroupsBtn');
    
    if (!table || !toggleBtn) return;
    
    if (!isGroupsCollapsed) {
      // Сворачиваем группы только для дивидендов
      const groups = {};
      chosen.forEach((item, index) => {
        // Сворачиваем только дивиденды
        if (item.category !== 'Дивиденды') {
          // Для не-дивидендов создаем отдельную группу для каждой строки
          const key = `non_dividend_${index}`;
          groups[key] = {
            items: [{ ...item, originalIndex: index + 1 }],
            firstIndex: index + 1,
            lastIndex: index + 1
          };
        } else {
          // Для дивидендов группируем по названию, ежемесячному доходу за единицу и цене за единицу
          const key = `${item.name}_${item.perUnit || ''}_${item.price || ''}`;
          if (!groups[key]) {
            groups[key] = {
              items: [],
              firstIndex: index + 1,
              lastIndex: index + 1
            };
          }
          groups[key].items.push({ ...item, originalIndex: index + 1 });
          groups[key].lastIndex = index + 1;
        }
      });
      
      // Создаем свернутые строки для групп
      const collapsedGroupRows = Object.values(groups).map(group => {
        if (group.items.length === 1) {
          // Одна строка - оставляем как есть
          const item = group.items[0];
          return `<tr>
            <td style="text-align:center">${item.originalIndex}</td>
            <td style="text-align:center;color:#080">+${((item.eff||0)).toFixed(2)}%</td>
            <td style="text-align:center">+${(item.delta||0).toFixed(3)}</td>
            <td style="text-align:center">${(item.monthly>0 && item.invest>0) ? ((item.monthly/item.invest)*100).toFixed(2)+'%' : ''}</td>
            <td style="text-align:center">${escapeHtml(item.name||'')}</td>
            <td style="text-align:center;${item.source==='expense'?'color:#c33':'color:#080'}">${item.source==='expense'?'-':''}${fmtPretty(item.monthly,0)}</td>
            <td style="text-align:center">${fmtPretty(item.invest,0)}</td>
            <td style="text-align:center">${escapeHtml(item.category||'')}</td>
            <td style="text-align:center">${escapeHtml(item.type || (item.source==='expense'?'Расход': (item.source==='dividend_unit'?'Дивиденды':(item.isDefault?'Пример':'Прогноз'))))}</td>
            <td style="text-align:center">${(item.category==='Дивиденды' && item.perUnit)?fmtPretty(item.perUnit,0):''}</td>
            <td style="text-align:center">${(item.category==='Дивиденды' && item.qty)?item.qty:''}</td>
            <td style="text-align:center">${(item.category==='Дивиденды' && item.price)?fmtPretty(item.price,0):''}</td>
          </tr>`;
        } else {
          // Несколько строк - сворачиваем в группу
          const firstItem = group.items[0];
          const totalMonthly = group.items.reduce((sum, item) => sum + (parseFloat(item.monthly)||0), 0);
          const totalInvest = group.items.reduce((sum, item) => sum + (parseFloat(item.invest)||0), 0);
          const totalDelta = group.items.reduce((sum, item) => sum + (parseFloat(item.delta)||0), 0);
          const totalEff = group.items.reduce((sum, item) => sum + (parseFloat(item.eff||0)), 0);
          
          // Рассчитываем средние значения для процентов
          const avgKpd = totalInvest > 0 ? (totalMonthly / totalInvest * 100) : 0;
          const avgEff = group.items.length > 0 ? (totalEff / group.items.length) : 0;
          
          return `<tr>
            <td style="text-align:center">${group.firstIndex}–${group.lastIndex}</td>
            <td style="text-align:center;color:#080">+${avgEff.toFixed(2)}%</td>
            <td style="text-align:center">+${totalDelta.toFixed(3)}</td>
            <td style="text-align:center">${avgKpd.toFixed(2)}%</td>
            <td style="text-align:center">${escapeHtml(firstItem.name||'')}</td>
            <td style="text-align:center;${firstItem.source==='expense'?'color:#c33':'color:#080'}">${firstItem.source==='expense'?'-':''}${fmtPretty(totalMonthly,0)}</td>
            <td style="text-align:center">${fmtPretty(totalInvest,0)}</td>
            <td style="text-align:center">${escapeHtml(firstItem.category||'')}</td>
            <td style="text-align:center">${escapeHtml(firstItem.type || (firstItem.source==='expense'?'Расход': (firstItem.source==='dividend_unit'?'Дивиденды':(firstItem.isDefault?'Пример':'Прогноз'))))}</td>
            <td style="text-align:center">${(firstItem.category==='Дивиденды' && firstItem.perUnit)?fmtPretty(firstItem.perUnit,0):''}</td>
            <td style="text-align:center">${group.items.length}</td>
            <td style="text-align:center">${(firstItem.category==='Дивиденды' && firstItem.price)?fmtPretty(firstItem.price,0):''}</td>
          </tr>`;
        }
      }).join('');
      
      // Генерируем HTML для серых строк-примеров (берем из исходных данных)
      const exampleRows = (forecastData || []).filter(item => item && item.isDefault);
      let exampleRowsHtml = '';
      if (exampleRows.length > 0) {
        exampleRowsHtml = exampleRows.map((item, i) => {
          const inv = parseFloat(item.invest)||0;
          const mon = parseFloat(item.monthly)||0;
          const price = parseFloat(item.price)||0;
          const cat = item.category||'';
          const name = item.name||'';
          
          if (inv>0 && mon>0) {
            let monthlyTotal = mon;
            let qty = '';
            let perUnit = '';
            
            // Обработка дивидендов
            if (cat==='Дивиденды' && price>0) {
              if (Math.abs(inv/price - Math.round(inv/price)) < 1e-9) {
                qty = Math.floor(inv/price);
                monthlyTotal = mon * qty;
                perUnit = mon;
              }
            }
            
            const kpd = (monthlyTotal>0 && inv>0) ? ((monthlyTotal/inv)*100).toFixed(2)+'%' : '';
            
            // Вычисляем ЭфКПК и КПК для примеров (но они не влияют на показатели)
            let effKpk = '';
            let kpk = '';
            try {
              const totals = typeof computeTotals === 'function' ? computeTotals() : { totalExpense: 0, passiveIncome: 0, coef: 0 };
              const totalExpense = parseFloat(totals.totalExpense) || 0;
              const passiveIncome = parseFloat(totals.passiveIncome) || 0;
              const coef = parseFloat(totals.coef) || 0;
              if (monthlyTotal > 0) {
                let delta = 0;
                if (totalExpense > 0) delta = monthlyTotal / totalExpense;
                if (delta > 0) {
                  kpk = `+${delta.toFixed(3)}`;
                  if (inv > 0) {
                    const scale = (typeof EFKPK_SCALE !== 'undefined') ? EFKPK_SCALE : 1;
                    const eff = (delta / inv) * scale * 100;
                    effKpk = `+${(eff*10).toFixed(2)}%`;
                  }
                }
              }
            } catch {}
            
            return `<tr style="background:#f2f2f2;color:#888" data-is-example="true">
              <td style="text-align:center;color:#888"><input type="checkbox" class="optimizerChk" data-id="example_${i}" style="margin:0;cursor:pointer" onchange="updateOptimizerSummary()"></td>
              <td style="text-align:center;color:#888">${chosen.length + i + 1}</td>
              <td style="text-align:center;color:#888">${effKpk}</td>
              <td style="text-align:center;color:#888">${kpk}</td>
              <td style="text-align:center;color:#888">${kpd}</td>
              <td style="text-align:center;color:#888">${escapeHtml(name)}</td>
              <td style="text-align:center;color:#888">${fmtPretty(monthlyTotal,0)}</td>
              <td style="text-align:center;color:#888">${fmtPretty(inv,0)}</td>
              <td style="text-align:center;color:#888">${escapeHtml(cat)}</td>
              <td style="text-align:center;color:#888">Пример</td>
              <td style="text-align:center;color:#888">${(cat==='Дивиденды' && perUnit)?fmtPretty(perUnit,0):''}</td>
              <td style="text-align:center;color:#888">${qty}</td>
              <td style="text-align:center;color:#888">${(cat==='Дивиденды' && price)?fmtPretty(price,0):''}</td>
            </tr>`;
          }
          return '';
        }).join('');
      }
      
      // Обновляем таблицу
      const tbody = table.querySelector('tbody');
      if (tbody) {
        tbody.innerHTML = collapsedGroupRows + exampleRowsHtml;
      }
      
      // Меняем кнопку на "Развернуть группы"
      toggleBtn.textContent = 'Развернуть группы дивидендов';
      toggleBtn.style.background = '#28a745';
      
      // Сохраняем состояние
      window.optimizerGroupsCollapsed = true;
      
    } else {
      // Разворачиваем группы - возвращаемся к состоянию свернутых дубликатов
      // Восстанавливаем строки свернутых дубликатов (только для дивидендов)
      const groups = {};
      chosen.forEach((item, index) => {
        // Сворачиваем только дивиденды
        if (item.category !== 'Дивиденды') {
          // Для не-дивидендов создаем отдельную группу для каждой строки
          const key = `non_dividend_${index}`;
          groups[key] = {
            items: [{ ...item, originalIndex: index + 1 }],
            firstIndex: index + 1,
            lastIndex: index + 1
          };
        } else {
          // Для дивидендов группируем по ключевым параметрам
          const key = `${item.source}_${item.category}_${item.name}_${item.type}_${item.price || ''}_${item.perUnit || ''}_${item.monthly}_${item.invest}_${(item.eff || 0).toFixed(2)}_${(item.delta || 0).toFixed(3)}`;
          if (!groups[key]) {
            groups[key] = {
              items: [],
              firstIndex: index + 1,
              lastIndex: index + 1
            };
          }
          groups[key].items.push({ ...item, originalIndex: index + 1 });
          groups[key].lastIndex = index + 1;
        }
      });
      
      // Создаем свернутые строки дубликатов
      const collapsedRows = Object.values(groups).map(group => {
        if (group.items.length === 1) {
          // Одна строка - оставляем как есть
          const item = group.items[0];
          return `<tr>
            <td style="text-align:center">${item.originalIndex}</td>
            <td style="text-align:center;color:#080">+${((item.eff||0)).toFixed(2)}%</td>
            <td style="text-align:center">+${(item.delta||0).toFixed(3)}</td>
            <td style="text-align:center">${(item.monthly>0 && item.invest>0) ? ((item.monthly/item.invest)*100).toFixed(2)+'%' : ''}</td>
            <td style="text-align:center">${escapeHtml(item.name||'')}</td>
            <td style="text-align:center;${item.source==='expense'?'color:#c33':'color:#080'}">${item.source==='expense'?'-':''}${fmtPretty(item.monthly,0)}</td>
            <td style="text-align:center">${fmtPretty(item.invest,0)}</td>
            <td style="text-align:center">${escapeHtml(item.category||'')}</td>
            <td style="text-align:center">${escapeHtml(item.type || (item.source==='expense'?'Расход': (item.source==='dividend_unit'?'Дивиденды':(item.isDefault?'Пример':'Прогноз'))))}</td>
            <td style="text-align:center">${(item.category==='Дивиденды' && item.perUnit)?fmtPretty(item.perUnit,0):''}</td>
            <td style="text-align:center">${(item.category==='Дивиденды' && item.qty)?item.qty:''}</td>
            <td style="text-align:center">${(item.category==='Дивиденды' && item.price)?fmtPretty(item.price,0):''}</td>
          </tr>`;
        } else {
          // Несколько строк - сворачиваем
          const firstItem = group.items[0];
          const totalMonthly = group.items.reduce((sum, item) => sum + (parseFloat(item.monthly)||0), 0);
          const totalInvest = group.items.reduce((sum, item) => sum + (parseFloat(item.invest)||0), 0);
          const totalDelta = group.items.reduce((sum, item) => sum + (parseFloat(item.delta)||0), 0);
          const totalEff = group.items.reduce((sum, item) => sum + (parseFloat(item.eff||0)), 0);
          
          // Рассчитываем средние значения для процентов
          const avgKpd = totalInvest > 0 ? (totalMonthly / totalInvest * 100) : 0;
          const avgEff = group.items.length > 0 ? (totalEff / group.items.length) : 0;
          
          return `<tr>
            <td style="text-align:center">${group.firstIndex}-${group.lastIndex}</td>
            <td style="text-align:center;color:#080">+${avgEff.toFixed(2)}%</td>
            <td style="text-align:center">+${totalDelta.toFixed(3)}</td>
            <td style="text-align:center">${avgKpd.toFixed(2)}%</td>
            <td style="text-align:center">${escapeHtml(firstItem.name||'')}</td>
            <td style="text-align:center;${firstItem.source==='expense'?'color:#c33':'color:#080'}">${firstItem.source==='expense'?'-':''}${fmtPretty(totalMonthly,0)}</td>
            <td style="text-align:center">${fmtPretty(totalInvest,0)}</td>
            <td style="text-align:center">${escapeHtml(firstItem.category||'')}</td>
            <td style="text-align:center">${escapeHtml(firstItem.type || (firstItem.source==='expense'?'Расход': (firstItem.source==='dividend_unit'?'Дивиденды':(firstItem.isDefault?'Пример':'Прогноз'))))}</td>
            <td style="text-align:center">${(firstItem.category==='Дивиденды' && firstItem.perUnit)?fmtPretty(firstItem.perUnit,0):''}</td>
            <td style="text-align:center">${group.items.length}</td>
            <td style="text-align:center">${(firstItem.category==='Дивиденды' && firstItem.price)?fmtPretty(firstItem.price,0):''}</td>
          </tr>`;
        }
      }).join('');
      
      // Генерируем HTML для серых строк-примеров (берем из исходных данных)
      const exampleRows = (forecastData || []).filter(item => item && item.isDefault);
      let exampleRowsHtml = '';
      if (exampleRows.length > 0) {
        exampleRowsHtml = exampleRows.map((item, i) => {
          const inv = parseFloat(item.invest)||0;
          const mon = parseFloat(item.monthly)||0;
          const price = parseFloat(item.price)||0;
          const cat = item.category||'';
          const name = item.name||'';
          
          if (inv>0 && mon>0) {
            let monthlyTotal = mon;
            let qty = '';
            let perUnit = '';
            
            // Обработка дивидендов
            if (cat==='Дивиденды' && price>0) {
              if (Math.abs(inv/price - Math.round(inv/price)) < 1e-9) {
                qty = Math.floor(inv/price);
                monthlyTotal = mon * qty;
                perUnit = mon;
              }
            }
            
            const kpd = (monthlyTotal>0 && inv>0) ? ((monthlyTotal/inv)*100).toFixed(2)+'%' : '';
            
            // Вычисляем ЭфКПК и КПК для примеров (но они не влияют на показатели)
            let effKpk = '';
            let kpk = '';
            try {
              const totals = typeof computeTotals === 'function' ? computeTotals() : { totalExpense: 0, passiveIncome: 0, coef: 0 };
              const totalExpense = parseFloat(totals.totalExpense) || 0;
              const passiveIncome = parseFloat(totals.passiveIncome) || 0;
              const coef = parseFloat(totals.coef) || 0;
              if (monthlyTotal > 0) {
                let delta = 0;
                if (totalExpense > 0) delta = monthlyTotal / totalExpense;
                if (delta > 0) {
                  kpk = `+${delta.toFixed(3)}`;
                  if (inv > 0) {
                    const scale = (typeof EFKPK_SCALE !== 'undefined') ? EFKPK_SCALE : 1;
                    const eff = (delta / inv) * scale * 100;
                    effKpk = `+${(eff*10).toFixed(2)}%`;
                  }
                }
              }
            } catch {}
            
            return `<tr style="background:#f2f2f2;color:#888" data-is-example="true">
              <td style="text-align:center;color:#888"><input type="checkbox" class="optimizerChk" data-id="example_${i}" style="margin:0;cursor:pointer" onchange="updateOptimizerSummary()"></td>
              <td style="text-align:center;color:#888">${chosen.length + i + 1}</td>
              <td style="text-align:center;color:#888">${effKpk}</td>
              <td style="text-align:center;color:#888">${kpk}</td>
              <td style="text-align:center;color:#888">${kpd}</td>
              <td style="text-align:center;color:#888">${escapeHtml(name)}</td>
              <td style="text-align:center;color:#888">${fmtPretty(monthlyTotal,0)}</td>
              <td style="text-align:center;color:#888">${fmtPretty(inv,0)}</td>
              <td style="text-align:center;color:#888">${escapeHtml(cat)}</td>
              <td style="text-align:center;color:#888">Пример</td>
              <td style="text-align:center;color:#888">${(cat==='Дивиденды' && perUnit)?fmtPretty(perUnit,0):''}</td>
              <td style="text-align:center;color:#888">${qty}</td>
              <td style="text-align:center;color:#888">${(cat==='Дивиденды' && price)?fmtPretty(price,0):''}</td>
            </tr>`;
          }
          return '';
        }).join('');
      }
      
      // Обновляем таблицу
      const tbody = table.querySelector('tbody');
      if (tbody) {
        tbody.innerHTML = collapsedRows + exampleRowsHtml;
      }
      
      // Меняем кнопку обратно на "Свернуть группы"
      toggleBtn.textContent = 'Свернуть группы дивидендов';
      toggleBtn.style.background = '#6c757d';
      
      // Сохраняем состояние
      window.optimizerGroupsCollapsed = false;
    }
    
  } catch (e) {
    console.warn('Ошибка при переключении групп:', e);
  }
}

// Функция для переключения между тремя видами отображения таблицы оптимизации
function setOptimizerView(viewNumber) {
  try {
    console.log('setOptimizerView вызвана с параметром:', viewNumber);
    if (!window.optimizerData || !window.optimizerData.chosen) {
      console.log('Нет данных оптимизации');
      return;
    }
    
    const chosen = window.optimizerData.chosen;
    const table = document.getElementById('optimizerTable');
    if (!table) return;
    
    // Обновляем стили кнопок
    const view1Btn = document.getElementById('optView1Btn');
    const view2Btn = document.getElementById('optView2Btn');
    const view3Btn = document.getElementById('optView3Btn');
    
    // Сначала показываем все столбцы
    const headerRow = table.querySelector('thead tr');
    if (headerRow) {
      const headers = headerRow.querySelectorAll('th');
      if (headers.length >= 13) {
        headers[10].style.display = 'table-cell'; // Пассив
        headers[11].style.display = 'table-cell'; // Расход  
        headers[12].style.display = 'table-cell'; // Кэф
      }
    }
    
    // Показываем все ячейки в строках примеров
    const exampleCells = table.querySelectorAll('.passive-col, .expense-col, .coef-col');
    exampleCells.forEach(cell => {
      cell.style.display = 'table-cell';
    });
    
    if (view1Btn && view2Btn && view3Btn) {
      // Сбрасываем все кнопки к неактивному состоянию
      view1Btn.style.background = '#6c757d';
      view2Btn.style.background = '#6c757d';
      view3Btn.style.background = '#6c757d';
      
      // Активируем выбранную кнопку
      switch (viewNumber) {
        case 1:
          view1Btn.style.background = '#4a90e2';
          break;
        case 2:
          view2Btn.style.background = '#4a90e2';
          break;
        case 3:
          view3Btn.style.background = '#4a90e2';
          break;
      }
    }
    
    // Генерируем HTML для серых строк-примеров (берем из исходных данных)
    const exampleRows = (forecastData || []).filter(item => item && item.isDefault);
    let exampleRowsHtml = '';
    if (exampleRows.length > 0) {
      exampleRowsHtml = exampleRows.map((item, i) => {
        const inv = parseFloat(item.invest)||0;
        const mon = parseFloat(item.monthly)||0;
        const price = parseFloat(item.price)||0;
        const cat = item.category||'';
        const name = item.name||'';
        
        if (inv>0 && mon>0) {
          let monthlyTotal = mon;
          let qty = '';
          let perUnit = '';
          
          // Обработка дивидендов
          if (cat==='Дивиденды' && price>0) {
            if (Math.abs(inv/price - Math.round(inv/price)) < 1e-9) {
              qty = Math.floor(inv/price);
              monthlyTotal = mon * qty;
              perUnit = mon;
            }
          }
          
          const kpd = (monthlyTotal>0 && inv>0) ? ((monthlyTotal/inv)*100).toFixed(2)+'%' : '';
          
          // Вычисляем ЭфКПК и КПК для примеров (но они не влияют на показатели)
          let effKpk = '';
          let kpk = '';
          try {
            const totals = typeof computeTotals === 'function' ? computeTotals() : { totalExpense: 0, passiveIncome: 0, coef: 0 };
            const totalExpense = parseFloat(totals.totalExpense) || 0;
            const passiveIncome = parseFloat(totals.passiveIncome) || 0;
            if (monthlyTotal > 0) {
              let delta = 0;
              if (totalExpense > 0) delta = monthlyTotal / totalExpense;
              if (delta > 0) {
                kpk = `+${delta.toFixed(3)}`;
                if (inv > 0) {
                  const scale = (typeof EFKPK_SCALE !== 'undefined') ? EFKPK_SCALE : 1;
                  const eff = (delta / inv) * scale * 100;
                  effKpk = `+${(eff*10).toFixed(2)}%`;
                }
              }
            }
          } catch {}
          
          return `<tr style="background:#f2f2f2;color:#888" data-is-example="true">
            <td style="text-align:center;color:#888"><input type="checkbox" class="optimizerChk" data-id="example_${i}" style="margin:0;cursor:pointer" onchange="updateOptimizerSummary()"></td>
            <td style="text-align:center;color:#888">${chosen.length + i + 1}</td>
            <td style="text-align:center;color:#888">${effKpk}</td>
            <td style="text-align:center;color:#888">${kpk}</td>
            <td style="text-align:center;color:#888">${kpd}</td>
            <td style="text-align:center;color:#888">${escapeHtml(name)}</td>
            <td style="text-align:center;color:#888">${fmtPretty(monthlyTotal,0)}</td>
            <td style="text-align:center;color:#888">${fmtPretty(inv,0)}</td>
            <td style="text-align:center;color:#888">${escapeHtml(cat)}</td>
            <td style="text-align:center;color:#888">Пример</td>
            <td style="text-align:center;color:#888" class="passive-col"></td>
            <td style="text-align:center;color:#888" class="expense-col"></td>
            <td style="text-align:center;color:#888" class="coef-col"></td>
            <td style="text-align:center;color:#888">${(cat==='Дивиденды' && perUnit)?fmtPretty(perUnit,0):''}</td>
            <td style="text-align:center;color:#888">${(cat==='Дивиденды' && qty)?qty:''}</td>
            <td style="text-align:center;color:#888">${(cat==='Дивиденды' && price)?fmtPretty(price,0):''}</td>
          </tr>`;
        }
        return '';
      }).join('');
    }
    
    switch (viewNumber) {
      case 1:
        // Вид 1: все дубликаты показываются (оригинальный вид)
        console.log('Применяется Вид 1: показ всех дубликатов');
        
        // Показываем все столбцы
        const headerRow1 = table.querySelector('thead tr');
        if (headerRow1) {
          const headers1 = headerRow1.querySelectorAll('th');
          if (headers1.length >= 13) {
            headers1[10].style.display = 'table-cell'; // Пассив
            headers1[11].style.display = 'table-cell'; // Расход  
            headers1[12].style.display = 'table-cell'; // Кэф
          }
        }
        
        // Показываем все ячейки в строках примеров
        const exampleCells1 = table.querySelectorAll('.passive-col, .expense-col, .coef-col');
        exampleCells1.forEach(cell => {
          cell.style.display = 'table-cell';
        });
        
        // Переменные для отслеживания накопленных значений
        let currentAccumulatedPassive1 = parseFloat(window.optimizerData.basePassive || computeTotals().passiveIncome)||0;
        let currentAccumulatedExpense1 = parseFloat(window.optimizerData.baseExpense || computeTotals().totalExpense)||0;
        let currentAccumulatedCoef1 = currentAccumulatedExpense1 > 0 ? (currentAccumulatedPassive1 / currentAccumulatedExpense1) : 0;
        
        const originalRows = chosen.map((item, index) => {
          const isDivUnit = item.source==='dividend_unit';
          const price = (item.category==='Дивиденды') ? (parseFloat(item.price|| (isDivUnit?item.invest:0))||0) : '';
          const monthly = parseFloat(item.monthly)||0;
          const invest = parseFloat(item.invest)||0;
          const kpd = (monthly>0 && invest>0) ? ((monthly/invest)*100).toFixed(2)+'%' : '';
          const typeLabel = item.type || (item.source==='expense'?'Расход': (isDivUnit?'Дивиденды':(item.isDefault?'Пример':'Прогноз')));
          const qty = (item.category==='Дивиденды') ? (isDivUnit ? 1 : (parseFloat(item.qty)|| (price>0 ? Math.floor(invest/price) : ''))) : '';
          const perUnit = (item.category==='Дивиденды') ? (parseFloat(item.perUnit|| (isDivUnit?monthly : (qty? (monthly/qty): 0)))||0) : '';
          
          // Рассчитываем накопленные значения после текущей покупки
          const isExampleRow = !!item.example || !!item.isDefault;
          if (!isExampleRow) {
            if (item.source === 'expense') {
              // Если это погашение расхода, уменьшаем расходы
              currentAccumulatedExpense1 = Math.max(0, currentAccumulatedExpense1 - monthly);
            } else {
              // Если это доход, увеличиваем пассивный доход
              currentAccumulatedPassive1 += monthly;
            }
            currentAccumulatedCoef1 = currentAccumulatedExpense1 > 0 ? (currentAccumulatedPassive1 / currentAccumulatedExpense1) : 0;
          }
          
          // Форматируем значения для отображения
          const displayPassive = isExampleRow ? '' : fmtPretty(currentAccumulatedPassive1, 0);
          const displayExpense = isExampleRow ? '' : fmtPretty(currentAccumulatedExpense1, 0);
          const displayCoef = isExampleRow ? '' : currentAccumulatedCoef1.toFixed(3);
          
          return `<tr>
            <td style="text-align:center"><input type="checkbox" class="optimizerChk" data-id="${item.id}" style="margin:0;cursor:pointer" onchange="updateOptimizerSummary()"></td>
            <td style="text-align:center">${index+1}</td>
            <td style="text-align:center;color:#080">+${((item.eff||0)).toFixed(2)}%</td>
            <td style="text-align:center">+${(item.delta||0).toFixed(3)}</td>
            <td style="text-align:center">${kpd}</td>
            <td style="text-align:center">${escapeHtml(item.name||'')}</td>
            <td style="text-align:center;${item.source==='expense'?'color:#c33':'color:#080'}">${item.source==='expense'?'-':''}${fmtPretty(monthly,0)}</td>
            <td style="text-align:center">${fmtPretty(invest,0)}</td>
            <td style="text-align:center">${escapeHtml(item.category||'')}</td>
            <td style="text-align:center">${escapeHtml(typeLabel)}</td>
            <td style="text-align:center;${isExampleRow ? 'color:#888' : 'color:#080'}">${displayPassive}</td>
            <td style="text-align:center;${isExampleRow ? 'color:#888' : 'color:#c33'}">${displayExpense}</td>
            <td style="text-align:center;${isExampleRow ? 'color:#888' : 'color:#080'}">${displayCoef}</td>
            <td style="text-align:center">${(item.category==='Дивиденды' && perUnit)?fmtPretty(perUnit,0):''}</td>
            <td style="text-align:center">${(item.category==='Дивиденды' && qty)?qty:''}</td>
            <td style="text-align:center">${(item.category==='Дивиденды' && price)?fmtPretty(price,0):''}</td>
          </tr>`;
        }).join('');
        
        // Обновляем таблицу
        const tbody1 = table.querySelector('tbody');
        if (tbody1) {
          tbody1.innerHTML = originalRows + exampleRowsHtml;
        }
        
        // Сохраняем состояние
        window.optimizerCollapsed = false;
        window.optimizerGroupsCollapsed = false;
        break;
        
      case 2:
        // Вид 2: дубликаты дивидендов свернуты
        console.log('Применяется Вид 2: сворачивание дубликатов дивидендов');
        
        // Показываем все столбцы
        const headerRow2 = table.querySelector('thead tr');
        if (headerRow2) {
          const headers2 = headerRow2.querySelectorAll('th');
          if (headers2.length >= 13) {
            headers2[10].style.display = 'table-cell'; // Пассив
            headers2[11].style.display = 'table-cell'; // Расход  
            headers2[12].style.display = 'table-cell'; // Кэф
          }
        }
        
        // Показываем все ячейки в строках примеров
        const exampleCells2 = table.querySelectorAll('.passive-col, .expense-col, .coef-col');
        exampleCells2.forEach(cell => {
          cell.style.display = 'table-cell';
        });
        
        // Переменные для отслеживания накопленных значений
        let currentAccumulatedPassive2 = parseFloat(window.optimizerData.basePassive || computeTotals().passiveIncome)||0;
        let currentAccumulatedExpense2 = parseFloat(window.optimizerData.baseExpense || computeTotals().totalExpense)||0;
        let currentAccumulatedCoef2 = currentAccumulatedExpense2 > 0 ? (currentAccumulatedPassive2 / currentAccumulatedExpense2) : 0;
        
        const groups = {};
        chosen.forEach((item, index) => {
          // Сворачиваем только дивиденды
          if (item.category !== 'Дивиденды') {
            // Для не-дивидендов создаем отдельную группу для каждой строки
            const key = `non_dividend_${index}`;
            groups[key] = {
              items: [{ ...item, originalIndex: index + 1 }],
              firstIndex: index + 1,
              lastIndex: index + 1
            };
          } else {
            // Для дивидендов группируем по ключевым параметрам
            const key = `${item.source}_${item.category}_${item.name}_${item.type}_${item.price || ''}_${item.perUnit || ''}_${item.monthly}_${item.invest}_${(item.eff || 0).toFixed(2)}_${(item.delta || 0).toFixed(3)}`;
            if (!groups[key]) {
              groups[key] = {
                items: [],
                firstIndex: index + 1,
                lastIndex: index + 1
              };
            }
            groups[key].items.push({ ...item, originalIndex: index + 1 });
            groups[key].lastIndex = index + 1;
          }
        });
        
        // Создаем свернутые строки
        const collapsedRows = Object.values(groups).map(group => {
          if (group.items.length === 1) {
            // Одна строка - оставляем как есть
            const item = group.items[0];
            
            // Рассчитываем накопленные значения после текущей покупки
            const isExampleRow = !!item.example || !!item.isDefault;
            if (!isExampleRow) {
              if (item.source === 'expense') {
                // Если это погашение расхода, уменьшаем расходы
                currentAccumulatedExpense2 = Math.max(0, currentAccumulatedExpense2 - (parseFloat(item.monthly)||0));
              } else {
                // Если это доход, увеличиваем пассивный доход
                currentAccumulatedPassive2 += (parseFloat(item.monthly)||0);
              }
              currentAccumulatedCoef2 = currentAccumulatedExpense2 > 0 ? (currentAccumulatedPassive2 / currentAccumulatedExpense2) : 0;
            }
            
            // Форматируем значения для отображения
            const displayPassive = isExampleRow ? '' : fmtPretty(currentAccumulatedPassive2, 0);
            const displayExpense = isExampleRow ? '' : fmtPretty(currentAccumulatedExpense2, 0);
            const displayCoef = isExampleRow ? '' : currentAccumulatedCoef2.toFixed(3);
            
            return `<tr>
              <td style="text-align:center"><input type="checkbox" class="optimizerChk" data-id="${item.id}" style="margin:0;cursor:pointer" onchange="updateOptimizerSummary()"></td>
              <td style="text-align:center">${item.originalIndex}</td>
              <td style="text-align:center;color:#080">+${((item.eff||0)).toFixed(2)}%</td>
              <td style="text-align:center">+${(item.delta||0).toFixed(3)}</td>
              <td style="text-align:center">${(item.monthly>0 && item.invest>0) ? ((item.monthly/item.invest)*100).toFixed(2)+'%' : ''}</td>
              <td style="text-align:center">${escapeHtml(item.name||'')}</td>
              <td style="text-align:center;${item.source==='expense'?'color:#c33':'color:#080'}">${item.source==='expense'?'-':''}${fmtPretty(item.monthly,0)}</td>
              <td style="text-align:center">${fmtPretty(item.invest,0)}</td>
              <td style="text-align:center">${escapeHtml(item.category||'')}</td>
              <td style="text-align:center">${escapeHtml(item.type || (item.source==='expense'?'Расход': (item.source==='dividend_unit'?'Дивиденды':(item.isDefault?'Пример':'Прогноз'))))}</td>
              <td style="text-align:center;${isExampleRow ? 'color:#888' : 'color:#080'}">${displayPassive}</td>
              <td style="text-align:center;${isExampleRow ? 'color:#888' : 'color:#c33'}">${displayExpense}</td>
              <td style="text-align:center;${isExampleRow ? 'color:#888' : 'color:#080'}">${displayCoef}</td>
              <td style="text-align:center">${(item.category==='Дивиденды' && item.perUnit)?fmtPretty(item.perUnit,0):''}</td>
              <td style="text-align:center">${(item.category==='Дивиденды' && item.qty)?item.qty:''}</td>
              <td style="text-align:center">${(item.category==='Дивиденды' && item.price)?fmtPretty(item.price,0):''}</td>
            </tr>`;
          } else {
            // Несколько строк - сворачиваем
            const firstItem = group.items[0];
            const totalMonthly = group.items.reduce((sum, item) => sum + (parseFloat(item.monthly)||0), 0);
            const totalInvest = group.items.reduce((sum, item) => sum + (parseFloat(item.invest)||0), 0);
            const totalDelta = group.items.reduce((sum, item) => sum + (parseFloat(item.delta)||0), 0);
            const totalEff = group.items.reduce((sum, item) => sum + (parseFloat(item.eff||0)), 0);
            
            // Рассчитываем средние значения для процентов
            const avgKpd = totalInvest > 0 ? (totalMonthly / totalInvest * 100) : 0;
            const avgEff = group.items.length > 0 ? (totalEff / group.items.length) : 0;
            
            // Рассчитываем накопленные значения после всех покупок в группе
            // Для свернутых групп берем значения из последней строки группы
            const lastItem = group.items[group.items.length - 1];
            const isExampleRow = !!lastItem.example || !!lastItem.isDefault;
            
            // Обновляем накопленные значения для всех элементов группы
            group.items.forEach(item => {
              if (!item.example && !item.isDefault) {
                if (item.source === 'expense') {
                  currentAccumulatedExpense2 = Math.max(0, currentAccumulatedExpense2 - (parseFloat(item.monthly)||0));
                } else {
                  currentAccumulatedPassive2 += (parseFloat(item.monthly)||0);
                }
              }
            });
            currentAccumulatedCoef2 = currentAccumulatedExpense2 > 0 ? (currentAccumulatedPassive2 / currentAccumulatedExpense2) : 0;
            
            // Форматируем значения для отображения
            const displayPassive = isExampleRow ? '' : fmtPretty(currentAccumulatedPassive2, 0);
            const displayExpense = isExampleRow ? '' : fmtPretty(currentAccumulatedExpense2, 0);
            const displayCoef = isExampleRow ? '' : currentAccumulatedCoef2.toFixed(3);
            
            return `<tr>
              <td style="text-align:center"><input type="checkbox" class="optimizerChk" data-id="group_${group.firstIndex}_${group.lastIndex}" style="margin:0;cursor:pointer" onchange="updateOptimizerSummary()"></td>
              <td style="text-align:center">${group.firstIndex}-${group.lastIndex}</td>
              <td style="text-align:center;color:#080">+${avgEff.toFixed(2)}%</td>
              <td style="text-align:center">+${totalDelta.toFixed(3)}</td>
              <td style="text-align:center">${avgKpd.toFixed(2)}%</td>
              <td style="text-align:center">${escapeHtml(firstItem.name||'')}</td>
              <td style="text-align:center;${firstItem.source==='expense'?'color:#c33':'color:#080'}">${firstItem.source==='expense'?'-':''}${fmtPretty(totalMonthly,0)}</td>
              <td style="text-align:center">${fmtPretty(totalInvest,0)}</td>
              <td style="text-align:center">${escapeHtml(firstItem.category||'')}</td>
              <td style="text-align:center">${escapeHtml(firstItem.type || (firstItem.source==='expense'?'Расход': (firstItem.source==='dividend_unit'?'Дивиденды':(firstItem.isDefault?'Пример':'Прогноз'))))}</td>
              <td style="text-align:center;${isExampleRow ? 'color:#888' : 'color:#080'}">${displayPassive}</td>
              <td style="text-align:center;${isExampleRow ? 'color:#888' : 'color:#c33'}">${displayExpense}</td>
              <td style="text-align:center;${isExampleRow ? 'color:#888' : 'color:#080'}">${displayCoef}</td>
              <td style="text-align:center">${(firstItem.category==='Дивиденды' && firstItem.perUnit)?fmtPretty(firstItem.perUnit,0):''}</td>
              <td style="text-align:center">${group.items.length}</td>
              <td style="text-align:center">${(firstItem.category==='Дивиденды' && firstItem.price)?fmtPretty(firstItem.price,0):''}</td>
            </tr>`;
          }
        }).join('');
        
        // Обновляем таблицу
        const tbody2 = table.querySelector('tbody');
        if (tbody2) {
          tbody2.innerHTML = collapsedRows + exampleRowsHtml;
        }
        
        // Сохраняем состояние
        window.optimizerCollapsed = true;
        window.optimizerGroupsCollapsed = false;
        break;
        
      case 3:
        // Вид 3: самый краткий - группы дивидендов свернуты, без столбцов Пассив/Расход/Кэф
        console.log('Применяется Вид 3: сворачивание групп дивидендов без столбцов Пассив/Расход/Кэф');
        
        // Скрываем столбцы Пассив, Расход, Кэф в заголовке
        const headerRow = table.querySelector('thead tr');
        if (headerRow) {
          const headers = headerRow.querySelectorAll('th');
          if (headers.length >= 13) {
            // Скрываем столбцы 11 (Пассив), 12 (Расход), 13 (Кэф)
            headers[10].style.display = 'none'; // Пассив
            headers[11].style.display = 'none'; // Расход  
            headers[12].style.display = 'none'; // Кэф
          }
        }
        
        // Скрываем ячейки в строках примеров
        const exampleCells = table.querySelectorAll('.passive-col, .expense-col, .coef-col');
        exampleCells.forEach(cell => {
          cell.style.display = 'none';
        });
        
        // Переменные для отслеживания накопленных значений
        let currentAccumulatedPassive3 = parseFloat(window.optimizerData.basePassive || computeTotals().passiveIncome)||0;
        let currentAccumulatedExpense3 = parseFloat(window.optimizerData.baseExpense || computeTotals().totalExpense)||0;
        let currentAccumulatedCoef3 = currentAccumulatedExpense3 > 0 ? (currentAccumulatedPassive3 / currentAccumulatedExpense3) : 0;
        
        const groupsByType = {};
        chosen.forEach((item, index) => {
          // Сворачиваем только дивиденды
          if (item.category !== 'Дивиденды') {
            // Для не-дивидендов создаем отдельную группу для каждой строки
            const key = `non_dividend_${index}`;
            groupsByType[key] = {
              items: [{ ...item, originalIndex: index + 1 }],
              firstIndex: index + 1,
              lastIndex: index + 1
            };
          } else {
            // Для дивидендов группируем по названию, ежемесячному доходу за единицу и цене за единицу
            const key = `${item.name}_${item.perUnit || ''}_${item.price || ''}`;
            if (!groupsByType[key]) {
              groupsByType[key] = {
                items: [],
                firstIndex: index + 1,
                lastIndex: index + 1
              };
            }
            groupsByType[key].items.push({ ...item, originalIndex: index + 1 });
            groupsByType[key].lastIndex = index + 1;
          }
        });
        
        // Создаем свернутые строки для групп
        const collapsedGroupRows = Object.values(groupsByType).map(group => {
          if (group.items.length === 1) {
            // Одна строка - оставляем как есть
            const item = group.items[0];
            
            // Рассчитываем накопленные значения после текущей покупки
            const isExampleRow = !!item.example || !!item.isDefault;
            if (!isExampleRow) {
              if (item.source === 'expense') {
                // Если это погашение расхода, уменьшаем расходы
                currentAccumulatedExpense3 = Math.max(0, currentAccumulatedExpense3 - (parseFloat(item.monthly)||0));
              } else {
                // Если это доход, увеличиваем пассивный доход
                currentAccumulatedPassive3 += (parseFloat(item.monthly)||0);
              }
              currentAccumulatedCoef3 = currentAccumulatedExpense3 > 0 ? (currentAccumulatedPassive3 / currentAccumulatedExpense3) : 0;
            }
            
            // Форматируем значения для отображения
            const displayPassive = isExampleRow ? '' : fmtPretty(currentAccumulatedPassive3, 0);
            const displayExpense = isExampleRow ? '' : fmtPretty(currentAccumulatedExpense3, 0);
            const displayCoef = isExampleRow ? '' : currentAccumulatedCoef3.toFixed(3);
            
            return `<tr>
              <td style="text-align:center"><input type="checkbox" class="optimizerChk" data-id="${item.id}" style="margin:0;cursor:pointer" onchange="updateOptimizerSummary()"></td>
              <td style="text-align:center">${item.originalIndex}</td>
              <td style="text-align:center;color:#080">+${((item.eff||0)).toFixed(2)}%</td>
              <td style="text-align:center">+${(item.delta||0).toFixed(3)}</td>
              <td style="text-align:center">${(item.monthly>0 && item.invest>0) ? ((item.monthly/item.invest)*100).toFixed(2)+'%' : ''}</td>
              <td style="text-align:center">${escapeHtml(item.name||'')}</td>
              <td style="text-align:center;${item.source==='expense'?'color:#c33':'color:#080'}">${item.source==='expense'?'-':''}${fmtPretty(item.monthly,0)}</td>
              <td style="text-align:center">${fmtPretty(item.invest,0)}</td>
              <td style="text-align:center">${escapeHtml(item.category||'')}</td>
              <td style="text-align:center">${escapeHtml(item.type || (item.source==='expense'?'Расход': (item.source==='dividend_unit'?'Дивиденды':(item.isDefault?'Пример':'Прогноз'))))}</td>
              <td style="display:none"></td>
              <td style="display:none"></td>
              <td style="display:none"></td>
              <td style="text-align:center">${(item.category==='Дивиденды' && item.perUnit)?fmtPretty(item.perUnit,0):''}</td>
              <td style="text-align:center">${(item.category==='Дивиденды' && item.qty)?item.qty:''}</td>
              <td style="text-align:center">${(item.category==='Дивиденды' && item.price)?fmtPretty(item.price,0):''}</td>
            </tr>`;
          } else {
            // Несколько строк - сворачиваем в группу
            const firstItem = group.items[0];
            const totalMonthly = group.items.reduce((sum, item) => sum + (parseFloat(item.monthly)||0), 0);
            const totalInvest = group.items.reduce((sum, item) => sum + (parseFloat(item.invest)||0), 0);
            const totalDelta = group.items.reduce((sum, item) => sum + (parseFloat(item.delta)||0), 0);
            const totalEff = group.items.reduce((sum, item) => sum + (parseFloat(item.eff||0)), 0);
            
            // Рассчитываем средние значения для процентов
            const avgKpd = totalInvest > 0 ? (totalMonthly / totalInvest * 100) : 0;
            const avgEff = group.items.length > 0 ? (totalEff / group.items.length) : 0;
            
            // Рассчитываем накопленные значения после всех покупок в группе
            // Для свернутых групп берем значения из последней строки группы
            const lastItem = group.items[group.items.length - 1];
            const isExampleRow = !!lastItem.example || !!lastItem.isDefault;
            
            // Обновляем накопленные значения для всех элементов группы
            group.items.forEach(item => {
              if (!item.example && !item.isDefault) {
                if (item.source === 'expense') {
                  currentAccumulatedExpense3 = Math.max(0, currentAccumulatedExpense3 - (parseFloat(item.monthly)||0));
                } else {
                  currentAccumulatedPassive3 += (parseFloat(item.monthly)||0);
                }
              }
            });
            currentAccumulatedCoef3 = currentAccumulatedExpense3 > 0 ? (currentAccumulatedPassive3 / currentAccumulatedExpense3) : 0;
            
            // Форматируем значения для отображения
            const displayPassive = isExampleRow ? '' : fmtPretty(currentAccumulatedPassive3, 0);
            const displayExpense = isExampleRow ? '' : fmtPretty(currentAccumulatedExpense3, 0);
            const displayCoef = isExampleRow ? '' : currentAccumulatedCoef3.toFixed(3);
            
            return `<tr>
              <td style="text-align:center"><input type="checkbox" class="optimizerChk" data-id="group_${group.firstIndex}_${group.lastIndex}" style="margin:0;cursor:pointer" onchange="updateOptimizerSummary()"></td>
              <td style="text-align:center">${group.firstIndex}–${group.lastIndex}</td>
              <td style="text-align:center;color:#080">+${avgEff.toFixed(2)}%</td>
              <td style="text-align:center">+${totalDelta.toFixed(3)}</td>
              <td style="text-align:center">${avgKpd.toFixed(2)}%</td>
              <td style="text-align:center">${escapeHtml(firstItem.name||'')}</td>
              <td style="text-align:center;${firstItem.source==='expense'?'color:#c33':'color:#080'}">${firstItem.source==='expense'?'-':''}${fmtPretty(totalMonthly,0)}</td>
              <td style="text-align:center">${fmtPretty(totalInvest,0)}</td>
              <td style="text-align:center">${escapeHtml(firstItem.category||'')}</td>
              <td style="text-align:center">${escapeHtml(firstItem.type || (firstItem.source==='expense'?'Расход': (firstItem.source==='dividend_unit'?'Дивиденды':(item.isDefault?'Пример':'Прогноз'))))}</td>
              <td style="display:none"></td>
              <td style="display:none"></td>
              <td style="display:none"></td>
              <td style="text-align:center">${(firstItem.category==='Дивиденды' && firstItem.perUnit)?fmtPretty(firstItem.perUnit,0):''}</td>
              <td style="text-align:center">${group.items.length}</td>
              <td style="text-align:center">${(firstItem.category==='Дивиденды' && firstItem.price)?fmtPretty(firstItem.price,0):''}</td>
            </tr>`;
          }
        }).join('');
        
        // Обновляем таблицу
        const tbody3 = table.querySelector('tbody');
        if (tbody3) {
          tbody3.innerHTML = collapsedGroupRows + exampleRowsHtml;
        }
        
        // Сохраняем состояние
        window.optimizerCollapsed = true;
        window.optimizerGroupsCollapsed = true;
        break;
    }
    
    console.log('Вид таблицы успешно изменен на:', viewNumber);
    
  } catch (e) {
    console.warn('Ошибка при переключении вида таблицы:', e);
  }
}

function expandOptimizerDuplicates() {
  try {
    if (!window.optimizerData || !window.optimizerData.chosen) return;
    
    const chosen = window.optimizerData.chosen;
    const table = document.getElementById('optimizerTable');
    if (!table) return;
    
    // Восстанавливаем оригинальные строки
    const originalRows = chosen.map((item, index) => {
      const isDivUnit = item.source==='dividend_unit';
      const price = (item.category==='Дивиденды') ? (parseFloat(item.price|| (isDivUnit?item.invest:0))||0) : '';
      const monthly = parseFloat(item.monthly)||0;
      const invest = parseFloat(item.invest)||0;
      const kpd = (monthly>0 && invest>0) ? ((monthly/invest)*100).toFixed(2)+'%' : '';
      const typeLabel = item.type || (item.source==='expense'?'Расход': (isDivUnit?'Дивиденды':(item.isDefault?'Пример':'Прогноз')));
      const qty = (item.category==='Дивиденды') ? (isDivUnit ? 1 : (parseFloat(item.qty)|| (price>0 ? Math.floor(invest/price) : ''))) : '';
      const perUnit = (item.category==='Дивиденды') ? (parseFloat(item.perUnit|| (isDivUnit?monthly : (qty? (monthly/qty): 0)))||0) : '';
      
      return `<tr>
        <td style="text-align:center"><input type="checkbox" class="optimizerChk" data-id="${item.id}" style="margin:0;cursor:pointer" onchange="updateOptimizerSummary()"></td>
        <td style="text-align:center">${index+1}</td>
        <td style="text-align:center;color:#080">+${((item.eff||0)).toFixed(2)}%</td>
        <td style="text-align:center">+${(item.delta||0).toFixed(3)}</td>
        <td style="text-align:center">${kpd}</td>
        <td style="text-align:center">${escapeHtml(item.name||'')}</td>
        <td style="text-align:center;${item.source==='expense'?'color:#c33':'color:#080'}">${item.source==='expense'?'-':''}${fmtPretty(monthly,0)}</td>
        <td style="text-align:center">${fmtPretty(invest,0)}</td>
        <td style="text-align:center">${escapeHtml(item.category||'')}</td>
        <td style="text-align:center">${escapeHtml(typeLabel)}</td>
        <td style="text-align:center">${(item.category==='Дивиденды' && perUnit)?fmtPretty(perUnit,0):''}</td>
        <td style="text-align:center">${(item.category==='Дивиденды' && qty)?qty:''}</td>
        <td style="text-align:center">${(item.category==='Дивиженды' && price)?fmtPretty(price,0):''}</td>
      </tr>`;
    }).join('');
    
    // Добавляем серые строки-примеры после основных (упрощенная версия)
    const exampleRows = (forecastData || []).filter(item => item && item.isDefault);
    if (exampleRows.length > 0) {
      const exampleRowsHtml = exampleRows.map((item, i) => {
        const inv = parseFloat(item.invest)||0;
        const mon = parseFloat(item.monthly)||0;
        const kpd = (mon>0 && inv>0) ? ((mon/inv)*100).toFixed(2)+'%' : '';
        
        return `<tr style="background:#f2f2f2;color:#888" data-is-example="true">
          <td style="text-align:center;color:#888"><input type="checkbox" class="optimizerChk" data-id="example_${i}" style="margin:0;cursor:pointer" onchange="updateOptimizerSummary()"></td>
          <td style="text-align:center;color:#888">${chosen.length + i + 1}</td>
          <td style="text-align:center;color:#888"></td>
          <td style="text-align:center;color:#888"></td>
          <td style="text-align:center;color:#888">${kpd}</td>
          <td style="text-align:center;color:#888">${escapeHtml(item.name||'')}</td>
          <td style="text-align:center;color:#888">${fmtPretty(mon,0)}</td>
          <td style="text-align:center;color:#888">${fmtPretty(inv,0)}</td>
          <td style="text-align:center;color:#888">${escapeHtml(item.category||'')}</td>
          <td style="text-align:center;color:#888">Пример</td>
          <td style="text-align:center;color:#888"></td>
          <td style="text-align:center;color:#888"></td>
          <td style="text-align:center;color:#888"></td>
        </tr>`;
      }).join('');
      
      tbody.innerHTML += exampleRowsHtml;
    }
    
    // Сохраняем состояние
    window.optimizerCollapsed = false;
    
  } catch (e) {
    console.warn('Ошибка при разворачивании дубликатов:', e);
  }
}
function initForecastData(){
  // Загружаем сохраненные данные
  forecastData = LS.load('cf_forecastData', []);
      // Миграция дефолтного примера SD (переводим per-unit=10, price=1200, qty=1 → invest=1200)
  try {
    let migrated = false;
    (forecastData||[]).forEach(r => {
          // Гарантируем для примера SD категорию "Дивиденды" (только для SD!)
    if (r && r.isDefault && (String(r.name||'').trim() === 'SD')) {
        if ((r.category||'') !== 'Дивиденды') { r.category = 'Дивиденды'; migrated = true; }
        const priceNow = parseFloat(r.price)||0;
        const monthlyPerUnit = parseFloat(r.monthly)||0;
        if (priceNow !== 1200 || monthlyPerUnit !== 10) {
          r.price = 1200;
          r.monthly = 10; // доход за штуку
          r.invest = 1200 * 1; // 1 штука по умолчанию
          migrated = true;
        }
      }
      // Для других примеров НЕ принудительно устанавливаем категорию
    });
    if (migrated) LS.save('cf_forecastData', forecastData);
  } catch {}
  
  // Если данных нет, добавляем данные по умолчанию
  if (forecastData.length === 0) {
    forecastData = [
      {id: 'default_1', category: 'Недвижимость', name: 'Дом 2/1', invest: 5000, monthly: 140, isDefault: true},
      {id: 'default_2', category: 'Недвижимость', name: 'Дом 2/1', invest: 5000, monthly: 100, isDefault: true},
      // Пример для дивидендов: monthly = доход за шт., price = цена за шт., invest = цена × штук
      // Доход за шт. = 10, цена за шт. = 1200, количество = 1 → invest = 1200
      {id: 'default_3', category: 'Дивиденды', name: 'SD', invest: 1200, monthly: 10, price: 1200, isDefault: true},
      // Новый пример: 8плекс
      {id: 'default_4', category: 'Недвижимость', name: '8плекс', invest: 100000, monthly: 5000, isDefault: true}
    ];
    LS.save('cf_forecastData', forecastData);
  }
  
  renderForecast();
}

function renderParticipants(){
  // Ведомость (доходы/расходы)
  try{ renderLedger(); }catch(e){ console.warn('renderLedger error', e); }
  
  // Перезагружаем участников на случай если они были сброшены
  participants = LS.load('cf_participants', []);
  
  // Убеждаемся, что кнопки управления звуком всегда отображаются
  try{ ensureTimerSoundControlsAlways(); }catch(e){ console.warn('ensureTimerSoundControlsAlways error', e); }
  
  const tbl=$('#participantsTable');tbl.innerHTML='';
  tbl.innerHTML='<tr><th>Имя</th><th>Ком %</th><th></th></tr>';
  participants.forEach((p,i)=>{
    const owner = localStorage.getItem('cf_owner') || participants[0] || '';
    const isOwner = p===owner;
    const tr=document.createElement('tr');
    tr.innerHTML=`<td><input type="text" value="${p}" class="editName" data-i="${i}" style="width:120px"></td><td><input type="number" min="0" max="100" step="1" value="${isOwner?0:(participantCom[p]??20)}" class="editCom" data-p="${p}" style="width:60px" ${isOwner?'readonly style="background:#eee;color:#888"':''}></td><td><button class="actBtn" onclick="delParticipant(${i})">✖️</button></td>`;
    tbl.appendChild(tr);
  });
  tbl.querySelectorAll('.editName').forEach(inp=>inp.onchange=editName);
  tbl.querySelectorAll('.editCom').forEach(inp=>inp.oninput=editCom);
  // владелец select
  const sel = document.getElementById('ownerSelect');
  if(sel){
    sel.innerHTML = ['<option value="">— выбрать —</option>'].concat(participants.map(p=>`<option value="${p}">${p}</option>`)).join('');
    sel.value = localStorage.getItem('cf_owner') || participants[0] || '';
    sel.onchange = (e)=>{
      localStorage.setItem('cf_owner', e.target.value);
      renderParticipants();
    };
  }
  
  // Обновляем список участников в разделе "Деньги партнеру"
  const partnerPaySelect = document.getElementById('partnerPayName');
  if(partnerPaySelect){
    partnerPaySelect.innerHTML = ['<option value="">— выбрать —</option>'].concat(participants.map(p=>`<option value="${p}">${p}</option>`)).join('');
  }
  
  // Обновим калькулятор кэфа расхода под участниками
  try { renderExpenseCoef(); } catch(e) { console.warn('renderExpenseCoef error', e); }
  // Если после очистки нет ни одной записи — добавим временную строку владельца
  try {
    const rowsWrap = document.getElementById('expenseCoefRows');
    if (rowsWrap && rowsWrap.children.length === 0) {
      expenseCoef = expenseCoef || {};
      const owner = localStorage.getItem('cf_owner') || participants[0] || '_owner_';
      if (!expenseCoef[owner]) {
        expenseCoef[owner] = { total: '', monthly: '' };
        LS.save('cf_expenseCoef', expenseCoef);
      }
      renderExpenseCoef();
    }
  } catch {}
}
function addParticipant(){pushUndo();const name=$('#newParticipant').value.trim();if(!name)return;participants.push(name);participantCom[name]=20;saveAll();$('#newParticipant').value='';renderParticipants();
  // Автофокус и выделение поля для быстрого ввода следующего участника
  setTimeout(()=>{const inp=document.getElementById('newParticipant');if(inp){inp.focus();inp.select();}},0);
  addHistory('Участник', `Добавлен: <b>${name}</b>`);
  
  // Записываем в историю ходов добавление участника
  try{ addTurnEventForCurrentTurn(0, `Добавлен участник: ${name}`); }catch{}
  try{ renderTurnsHistory(); }catch{}
  
  // Если владелец ещё не выбран — назначаем первого
  if (!localStorage.getItem('cf_owner') && participants.length) {
    localStorage.setItem('cf_owner', participants[0]);
    renderParticipants();
  }
}
function delParticipant(i){pushUndo();const name=participants[i];participants.splice(i,1);delete participantCom[name];if(participants.length===0) participantCom={};saveAll();renderParticipants();
  addHistory('Участник', `Удалён: <b>${name}</b>`);
  
  // Записываем в историю ходов удаление участника
  try{ addTurnEventForCurrentTurn(0, `Удалён участник: ${name}`); }catch{}
  try{ renderTurnsHistory(); }catch{}
}
function editName(e){const i=+e.target.dataset.i;const old=participants[i];const val=e.target.value.trim();if(!val)return;participants[i]=val;if(holdings[val]===undefined&&holdings[old]!==undefined){holdings[val]=holdings[old];delete holdings[old];}if(participantCom[val]===undefined&&participantCom[old]!==undefined){participantCom[val]=participantCom[old];delete participantCom[old];}saveAll();renderParticipants();
  
  // Записываем в историю ходов изменение имени участника
  try{ addTurnEventForCurrentTurn(0, `Переименован участник: ${old} → ${val}`); }catch{}
  try{ renderTurnsHistory(); }catch{}
}
function editCom(e){
  const p=e.target.dataset.p;
  const val=parseFloat(e.target.value)||0;
  participantCom[p]=val;
  saveAll();
  renderParticipants();
  
  // Записываем в историю ходов изменение комиссии участника
  try{ addTurnEventForCurrentTurn(0, `Комиссия ${p}: ${val}%`); }catch{}
  try{ renderTurnsHistory(); }catch{}
}
  function resetAll(){
  if (!confirm('Вы уверены, что хотите удалить ВСЕ данные? Это действие необратимо!')) return;
  
  // Записываем в историю ходов сброс всех данных
  try{ addTurnEventForCurrentTurn(0, 'Сброс всех данных'); }catch{}
  try{ renderTurnsHistory(); }catch{}
  
  // Сохраняем вступительный текст перед очисткой
  const introTextValue = localStorage.getItem('cf_intro_text') || '';
  
  // Очищаем все данные, кроме поля текста стартового
  localStorage.removeItem('cf_participants');
  localStorage.removeItem('cf_participantCom');
  localStorage.removeItem('cf_holdings');
  localStorage.removeItem('cf_buyDeals');
  localStorage.removeItem('cf_partnerRows');
  localStorage.removeItem('cf_paidSells'); // Очищаем галочки!
  localStorage.removeItem('cf_sellPrices'); // Очищаем цены продажи!
  localStorage.removeItem('cf_sellCardCom'); // Сбрасываем проценты посредника
  localStorage.removeItem('cf_sellCardRecipient'); // Сбрасываем получателя посредника
  localStorage.removeItem('cf_sellFactors'); // Сбрасываем коэффициенты
  localStorage.removeItem('cf_burnedSymbols'); // Сбрасываем флаг сгорания
  localStorage.removeItem('cf_buySumOriginal'); // Сбрасываем сумму покупки по символам
  localStorage.removeItem('cf_buySumByParticipant'); // Сбрасываем вложения по участникам
  localStorage.removeItem('cf_sellCardDefaultCom'); // Сбрасываем дефолтные проценты посредника
  localStorage.removeItem('cf_sellCardDefaultRecipient'); // Сбрасываем дефолтного посредника
  // Главная вкладка (ведомость)
  localStorage.removeItem('cf_ledgerIncomes');
  localStorage.removeItem('cf_ledgerExpenses');
  // Калькулятор кэфа расхода — очищаем значения
  localStorage.removeItem('cf_expenseCoef');
  // Новые разделы: Ходы, Таймер, Баланс
  localStorage.removeItem('cf_moves_state');
  localStorage.removeItem('cf_moves_turn');
  localStorage.removeItem('cf_turn_number');
  
  localStorage.removeItem('cf_post_turn');
  // Сбрасываем флаг кредита при удалении всех данных
  
  localStorage.removeItem('cf_history');
  localStorage.removeItem('cf_turns');
  // Временные данные покупки
  localStorage.removeItem('cf_buyTemp');
  // Стеки undo/redo
  localStorage.removeItem('cf_undoStack');
  localStorage.removeItem('cf_redoStack');
  // Очищаем предыдущую сумму партнеров
  localStorage.removeItem('cf_partnerPrevSum');
  localStorage.removeItem('cf_partnerBalance');
  // Сбрасываем активную вкладку и версию состояния, чтобы графики/капитал перерисовались корректно
  localStorage.removeItem('cf_activeTab');
  localStorage.removeItem('cf_stateVersion');
  // НЕ удаляем позицию таймера при сбросе данных
  // localStorage.removeItem('cf_timer_pos');
  // НЕ удаляем шаблоны покупки и продажи
  // НЕ удаляем поле текста стартового
  
  // Восстанавливаем вступительный текст
  if (introTextValue) {
    localStorage.setItem('cf_intro_text', introTextValue);
  }
  
  try{
    // Чистим визуальные артефакты ходов
    document.getElementById('diceSelected') && (document.getElementById('diceSelected').textContent='');
    document.getElementById('cardSelected') && (document.getElementById('cardSelected').textContent='');
    document.getElementById('cashflowApplied') && (document.getElementById('cashflowApplied').textContent='');
    document.getElementById('cardStatus') && (document.getElementById('cardStatus').textContent='');
    document.getElementById('creditStatus') && (document.getElementById('creditStatus').textContent='');
    
    // Убираем галочки с кнопок в разделе ходов
    document.getElementById('diceChoices')?.querySelectorAll('.dice-btn').forEach(btn => {
      btn.classList.remove('active');
    });
    document.getElementById('cardYes')?.classList.remove('active', 'btn-checkmark');
    document.getElementById('cardNo')?.classList.remove('active', 'btn-checkmark');
    document.getElementById('cashflowYes')?.classList.remove('active', 'btn-checkmark');
    document.getElementById('cashflowNo')?.classList.remove('active', 'btn-checkmark');

    
    // Убираем классы done с элементов ходов
    document.getElementById('move1')?.classList.remove('done');
    document.getElementById('move2')?.classList.remove('done');
    document.getElementById('move3')?.classList.remove('done', 'dimmed');

  }catch{}
          // НЕ удаляем позицию таймера при сбросе данных
        // localStorage.removeItem('cf_timer_pos');
  // Стеки undo/redo
  localStorage.removeItem('cf_undoStack');
  localStorage.removeItem('cf_redoStack');
  // Очищаем предыдущую сумму партнеров
  localStorage.removeItem('cf_partnerPrevSum');
  localStorage.removeItem('cf_partnerBalance');
  // Не трогаем cf_buySymbolTpls и cf_buyPriceTpls
  // На всякий случай очистим отображение истории/графиков до перезагрузки
  try {
    const hist = document.getElementById('historyList');
    if (hist) hist.innerHTML = '';
    const turns = document.getElementById('turnsHistoryList');
    if (turns) turns.innerHTML = '';
    const canvas = document.getElementById('balanceChart');
    if (canvas && canvas.getContext) {
      const ctx = canvas.getContext('2d');
      ctx && ctx.clearRect(0,0,canvas.width||0,canvas.height||0);
    }
  } catch {}
  
  // Сохраняем данные прогноза по умолчанию перед сбросом
  try {
    const defaultForecastData = [
      {id: 'default_1', category: 'Недвижимость', name: 'Дом 2/1', invest: 5000, monthly: 140, isDefault: true},
      {id: 'default_2', category: 'Недвижимость', name: 'Дом 2/1', invest: 5000, monthly: 100, isDefault: true},
      {id: 'default_3', category: 'Дивиденды', name: 'SD', invest: 1200, monthly: 1, price: 1200, isDefault: true}
    ];
    localStorage.setItem('cf_forecastData', JSON.stringify(defaultForecastData));
  } catch {}
  
  // Очищаем калькулятор кэфа расхода, оставляя только структуру
  try {
    localStorage.removeItem('cf_expenseCoef');
  } catch {}
  
  // Создаем кнопки управления звуком перед перезагрузкой
  try {
    ensureTimerSoundControlsAlways();
  } catch {}
  
  location.reload();
}
// Автоматическое сохранение: все изменения сохраняются в localStorage мгновенно, черновики и состояние вкладок не теряются при закрытии или обновлении страницы.
// 1. Список сделок в разделе 'Купить' с возможностью редактирования
let buyDeals=LS.load('cf_buyDeals',[]);
function renderBuy(){
  const tbl=$('#buyTable');tbl.innerHTML='';
  
  // Перезагружаем участников на случай если они были сброшены
  participants = LS.load('cf_participants', []);
  
  tbl.innerHTML='<tr><th>Участник</th><th>Сумма</th><th>Акций</th></tr>';
  participants.forEach(p=>{const tr=document.createElement('tr');tr.innerHTML=`<td>${p}</td><td><div style="display:flex;gap:6px;align-items:center;justify-content:center"><button class="actBtn buyQuick" data-p="${p}" title="Быстрый ввод">⚡</button><input type="number" min="0" class="buySum" data-p="${p}" value="" onfocus="clearZeroOnFocus(this)"></div></td><td class="buyQty">0</td>`;tbl.appendChild(tr);});
  // Восстанавливаем временные значения
  loadBuyTempFields();
  tbl.querySelectorAll('.buySum').forEach(inp=>{
    inp.oninput=()=>{updateBuyCalc();saveBuyTempFields();};
    inp.onchange=()=>{updateBuyCalc();saveBuyTempFields();};
  });
  if($('#buyPrice')){
    $('#buyPrice').addEventListener('input',()=>{saveBuyTempFields();updateBuyCalc();});
    $('#buyPrice').addEventListener('change',()=>{saveBuyTempFields();updateBuyCalc();});
  }
  if($('#buySymbol')){
    $('#buySymbol').addEventListener('input',()=>{saveBuyTempFields();updateBuyCalc();});
    $('#buySymbol').addEventListener('change',()=>{saveBuyTempFields();updateBuyCalc();});
  }
  // Кнопки быстрого ввода суммы (по 1000 × N)
  tbl.querySelectorAll('.buyQuick').forEach(btn=>{
    btn.onclick = ()=>{
      try{
        const tr = btn.closest('tr');
        const inp = tr ? tr.querySelector('.buySum') : null;
        if (inp) openQuickAmountPicker(inp, btn.getAttribute('data-p')||'');
      }catch{}
    };
  });
  updateBuyCalc();
  renderBuyTemplates();
  renderBuyDeals();
  // Обновляем заголовки после рендера всех элементов
  setTimeout(() => updateBuyHeaders(), 0);
  // Инициализируем поле ввода хода по умолчанию текущим номером
  try{
    const t = parseInt(localStorage.getItem('cf_turn_number')||'1',10)||1;
    const el = document.getElementById('buyTurnInput');
    if (el) {
      el.value = 'Ход ' + t;
      // Добавляем обработчик для обновления заголовков при изменении хода
      el.addEventListener('input', () => updateBuyHeaders());
      el.addEventListener('change', () => updateBuyHeaders());
    }
  }catch{}
  // Вставляем кнопку "Очистить поля" после кнопки "Сохранить сделку" с двумя строками отступа
  setTimeout(()=>{
    let btn = document.getElementById('clearBuyFieldsBtn');
    if(!btn){
      btn = document.createElement('button');
      btn.id = 'clearBuyFieldsBtn';
      btn.className = 'btn';
      btn.textContent = 'Очистить поля';
      btn.onclick = clearBuyFields;
      btn.style.background = '#eee';
      btn.style.color = '#444';
      btn.style.border = '1px solid #ccc';
    }
    btn.style.margin = '32px 0 0 0'; // 2 строки отступа
    const saveBtn = document.querySelector("#buy section > button.btn, #buy > button.btn, #buyTable ~ button.btn");
    if(saveBtn && saveBtn.parentNode){
      if(btn.parentNode !== saveBtn.parentNode){
        saveBtn.parentNode.insertBefore(btn, saveBtn.nextSibling);
      } else if(btn !== saveBtn.nextSibling){
        saveBtn.parentNode.insertBefore(btn, saveBtn.nextSibling);
      }
    }
  }, 0);
  
  // Добавляем обработчики для калькуляторов
  setTimeout(() => {
    // Обработчики для Легкой покупки
    const easySum = document.getElementById('easySum');
    const easyPrice = document.getElementById('easyPrice');
    if (easySum) {
      easySum.removeEventListener('input', updateEasyBuy);
      easySum.addEventListener('input', updateEasyBuy);
    }
    if (easyPrice) {
      easyPrice.removeEventListener('input', updateEasyBuy);
      easyPrice.addEventListener('input', updateEasyBuy);
    }
    
    // Обработчики для Калькулятора КПД
    document.querySelectorAll('.kpdInvest, .kpdPassive, .kpdCheck').forEach(input => {
      input.oninput = updateKPD;
      input.onchange = updateKPD;
    });
    // Инициализация сворачивания КПД в покупке
    try { initBuyKpdToggle(); } catch {}
    try { initMainKpdToggle(); } catch {}
    try { initProfitableBuyToggle(); } catch {}
    try {
      if (typeof runOptimization === 'function') runOptimization();
    } catch {}
    
      // Вызываем функции для обновления результатов
  try{ updateEasyBuy(); }catch{}
  try{ updateKPD(); }catch{}
  }, 100);
}

// Всплывающий выбор суммы 1–30 (по 1000 × N)
function openQuickAmountPicker(targetInput, participantName){
  try{
    const old = document.getElementById('quickAmountModal');
    if (old && old.remove) old.remove();
  }catch{}
  const esc = (s)=> String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
  const bd = document.createElement('div');
  bd.className = 'modal-backdrop';
  bd.id = 'quickAmountModal';
  const gridButtons = Array.from({length:30}, (_,i)=>{
    const n = i+1;
    const val = n*1000;
    return `<button class=\"btn quickAmountBtn\" data-val=\"${val}\" style=\"width:100%;min-width:0;padding:16px 0;font-size:18px;\">${n}</button>`;
  }).join('');
  bd.innerHTML = `
    <div class="modal" style="max-height:65vh;overflow:auto;margin:0;width:100vw;max-width:100vw;padding:8px;">
      <h3>Быстрый ввод — ${esc(participantName)}</h3>
      <div class="row" style="flex-direction:column;gap:12px;align-items:stretch;width:100%;">
        <div class="grid-buttons" style="display:grid;grid-template-columns:repeat(5,1fr);gap:8px;width:100%;">
          ${gridButtons}
        </div>
        <div class="actions" style="margin-top:16px;">
          <button class="btn" id="qaClear" style="background:#eee;color:#444;border:1px solid #ccc;padding:4px 10px;font-size:13px;">Очистить</button>
          <button class="btn" id="qaClose" style="padding:4px 10px;font-size:13px;">Закрыть</button>
        </div>
      </div>
    </div>`;
  document.body.appendChild(bd);
  const close = ()=>{ try{ bd.remove(); }catch{} };
  const clear = ()=>{ try{ targetInput.value=''; targetInput.blur && targetInput.blur(); if (typeof saveBuyTempFields==='function') saveBuyTempFields(); if (typeof updateBuyCalc==='function') updateBuyCalc(); }catch{}; close(); };
  bd.addEventListener('click', (e)=>{ if (e.target === bd) close(); });
  try{ bd.querySelector('#qaClose').onclick = close; }catch{}
  try{ bd.querySelector('#qaClear').onclick = clear; }catch{}
  bd.querySelectorAll('.quickAmountBtn').forEach(btn=>{
    btn.onclick = ()=>{
      try{
        const v = btn.getAttribute('data-val');
        targetInput.value = v;
        if (typeof saveBuyTempFields==='function') saveBuyTempFields();
        if (typeof updateBuyCalc==='function') updateBuyCalc();
        close();
        try{ targetInput.blur && targetInput.blur(); }catch{}
      }catch{}
    };
  });
}
function renderBuyDeals(){
  let wrap = document.getElementById('buyDealsWrap');
  if(!wrap){wrap=document.createElement('div');wrap.id='buyDealsWrap';$('#buyTable').parentNode.appendChild(wrap);}
  wrap.innerHTML = buyDeals.length?'<h3 style="margin:12px 0 4px 0">Сохранённые сделки</h3>':'';
  buyDeals.forEach((deal,i)=>{
    // Получаем информацию о ходе покупки для этой акции
    const buyTurnInfo = (LS.load('cf_buyTurnBySymbol', {})||{})[deal.symbol] || '';
    const turnDisplay = buyTurnInfo ? ` <span style="color:#666;font-size:12px">(${buyTurnInfo})</span>` : '';
    
    let html = `<div style="border:1px solid #ccc;padding:8px;margin-bottom:8px;border-radius:6px;background:#fff">
      <b>${deal.symbol}</b> @ ${fmt(deal.price)}${turnDisplay}
      <button class="actBtn" onclick="delBuyDeal(${i})">✖️</button><br>`;
    participants.forEach(p=>{
      html += `${p}: <input type="number" min="0" style="width:80px" value="${deal.by[p]||''}" onchange="editBuyDeal(${i},'${p}',this.value)" onfocus="clearZeroOnFocus(this)"> `;
    });
    html += '</div>';
    wrap.innerHTML += html;
  });
}
function delBuyDeal(i){buyDeals.splice(i,1);LS.save('cf_buyDeals',buyDeals);renderBuyDeals();}
function editBuyDeal(i,p,v){buyDeals[i].by[p]=v;LS.save('cf_buyDeals',buyDeals);renderBuyDeals();}
// Удалено: старая версия renderSell со столбцом "Продать"
function togglePaidSell(checkbox) {
  const tr = checkbox.closest('tr');
  if (!tr) return;
  tr.classList.toggle('paid', checkbox.checked);
  // Сохраняем состояние галочки в localStorage
  const sym = tr.dataset.sym;
  const p = tr.dataset.p;
  let paidSells = JSON.parse(localStorage.getItem('cf_paidSells') || '{}');
  if (!paidSells[sym]) paidSells[sym] = {};
  const prevChecked = !!paidSells[sym][p];
  paidSells[sym][p] = checkbox.checked;
  localStorage.setItem('cf_paidSells', JSON.stringify(paidSells));
  // Пересчитать суммы
  updateSellCalc();
  // Увеличиваем баланс владельца при отметке строки владельца как выплачено
  try {
    const owner = localStorage.getItem('cf_owner') || (participants[0]||'');
    if (p === owner) {
      // Найдём сумму "к выдаче" по этой строке (нетто)
      const withSellCell = tr.querySelector('.sumWithSell');
      const raw = withSellCell ? (withSellCell.textContent||'').replace(/\s/g,'').replace(/[^0-9.]/g,'') : '';
      const amount = Math.round(parseFloat(raw)||0);
      if (amount>0) {
        // Фиксируем сумму, выданную по этой строке, чтобы корректно отменять
        window._sellGiven = window._sellGiven||{}; window._sellGiven[sym]=window._sellGiven[sym]||{};
        const prevGiven = Math.round(window._sellGiven[sym][p]||0);
        if (checkbox.checked && !prevChecked) {
          window._sellGiven[sym][p] = amount;
          applyBalanceDelta(amount, `Продажа (выплата владельцу) по ${sym}`);
        } else if (!checkbox.checked && prevChecked) {
          const back = Math.round(window._sellGiven[sym][p]||amount);
          window._sellGiven[sym][p] = 0;
          applyBalanceDelta(-back, `Продажа (отмена выплаты владельцу) по ${sym}`);
        }
      }
    }
    // Комиссия участника (Ком $) зачисляется владельцу при отметке любой строки (кроме владельца, у него 0%)
    if (p !== owner) {
      const commCell = tr.querySelector('.sumCommission');
      const commRaw = commCell ? (commCell.textContent||'').replace(/\s/g,'').replace(/[^0-9.]/g,'') : '';
      const commission = Math.round(parseFloat(commRaw)||0);
      if (commission>0) {
        window._sellCommGiven = window._sellCommGiven||{}; window._sellCommGiven[sym]=window._sellCommGiven[sym]||{};
        if (checkbox.checked && !prevChecked) {
          window._sellCommGiven[sym][p] = commission;
          applyBalanceDelta(commission, `Продажа (комиссия) по ${sym} (${p})`);
        } else if (!checkbox.checked && prevChecked) {
          const back = Math.round((window._sellCommGiven[sym][p]||commission));
          window._sellCommGiven[sym][p] = 0;
          applyBalanceDelta(-back, `Продажа (отмена комиссии) по ${sym} (${p})`);
        }
      }
    }
  } catch{}
}
function restorePaidSells() {
  let paidSells = JSON.parse(localStorage.getItem('cf_paidSells') || '{}');
  document.querySelectorAll('tr[data-sym][data-p]').forEach(tr => {
    const sym = tr.dataset.sym;
    const p = tr.dataset.p;
    const checked = paidSells[sym] && paidSells[sym][p];
    const checkbox = tr.querySelector('.paidChkSell');
    if (checkbox) {
      checkbox.checked = !!checked;
      tr.classList.toggle('paid', !!checked);
    }
  });
}
// Удалено: старая версия doSell, так как продажа вводом количества больше не используется
// 3. Шаблоны названий и цен в покупке
let buySymbolTpls=LS.load('cf_buySymbolTpls',[]);
let buyPriceTpls=LS.load('cf_buyPriceTpls',[]);
function renderBuyTemplates(){
  // Названия
  let wrap = document.getElementById('buySymbolTpls');
  if(!wrap){wrap=document.createElement('div');wrap.id='buySymbolTpls';$('#buySymbol').insertAdjacentElement('afterend',wrap);}
  wrap.style.display='inline-block';
  wrap.innerHTML = buySymbolTpls.map((s,i)=>`<span style="background:#e6f0ff;padding:4px 10px;border-radius:12px;margin:2px;display:inline-block;cursor:pointer;position:relative" onclick="$('#buySymbol').value='${s}';updateBuyCalc()">${s} <button tabindex="-1" onclick="event.stopPropagation();confirmDelBuySymbolTpl(${i})" style="background:none;border:none;color:#bbb;font-size:12px;margin-left:4px;opacity:0.5;vertical-align:middle;pointer-events:auto;border-radius:50%;width:20px;height:20px;line-height:16px;display:inline-flex;align-items:center;justify-content:center;outline:none;">✖</button></span>`).join('');
  // Цены
  let wrap2 = document.getElementById('buyPriceTpls');
  if(!wrap2){wrap2=document.createElement('div');wrap2.id='buyPriceTpls';$('#buyPrice').insertAdjacentElement('afterend',wrap2);}
  wrap2.style.display='inline-block';
  wrap2.innerHTML = buyPriceTpls.map((s,i)=>`<span style="background:#e6f0ff;padding:4px 10px;border-radius:12px;margin:2px;display:inline-block;cursor:pointer;position:relative" onclick="$('#buyPrice').value='${s}';updateBuyCalc()">${s} <button tabindex="-1" onclick="event.stopPropagation();confirmDelBuyPriceTpl(${i})" style="background:none;border:none;color:#bbb;font-size:12px;margin-left:4px;opacity:0.5;vertical-align:middle;pointer-events:auto;border-radius:50%;width:20px;height:20px;line-height:16px;display:inline-flex;align-items:center;justify-content:center;outline:none;">✖</button></span>`).join('');
}
function confirmDelBuySymbolTpl(i){if(confirm('Удалить этот шаблон?')) delBuySymbolTpl(i);}
function confirmDelBuyPriceTpl(i){if(confirm('Удалить этот шаблон?')) delBuyPriceTpl(i);}
$('#buySymbol').addEventListener('change',()=>{
  const val=$('#buySymbol').value.trim();
  if(val && !buySymbolTpls.includes(val)){
    buySymbolTpls.push(val);LS.save('cf_buySymbolTpls',buySymbolTpls);renderBuyTemplates();
  }
});
$('#buyPrice').addEventListener('change',()=>{
  const val=$('#buyPrice').value.trim();
  if(val && !buyPriceTpls.includes(val)){
    buyPriceTpls.push(val);LS.save('cf_buyPriceTpls',buyPriceTpls);renderBuyTemplates();
  }
});
// При старте отрисуем шаблоны покупки сразу, чтобы не пропадали после обновления
setTimeout(()=>{ try{ renderBuyTemplates(); }catch{} }, 0);
  // Управление видимостью полей в форме добавления дохода
  try {
    const catSel = document.getElementById('incomeCategory');
    const nameWrap = document.getElementById('incomeNameWrap');
    const investWrap = document.getElementById('incomeInvestWrap');
    const priceWrap = document.getElementById('incomePriceWrap');
    const amountInp = document.getElementById('incomeAmount');
    const syncIncomeFormVisibility = ()=>{
      const v = (catSel && catSel.value) || '';
      const hideName = (v==='Зарплата' || v==='Пенсия');
      // Для Другое и Дивиденды показываем Инвестировано, как и для Недвижимости/Бизнеса
      const showInvest = (v==='Недвижимость' || v==='Бизнес' || v==='Другое' || v==='Дивиденды');
      if (nameWrap) nameWrap.style.display = hideName ? 'none' : '';
      if (investWrap) investWrap.style.display = showInvest ? '' : 'none';
      if (priceWrap) priceWrap.style.display = (v==='Дивиденды') ? '' : 'none';
      if (amountInp) amountInp.setAttribute('placeholder', (v==='Дивиденды') ? 'Ежемес за шт.' : 'Ежемесячно $');
    };
    if (catSel) {
      catSel.removeEventListener('change', syncIncomeFormVisibility);
      catSel.addEventListener('change', syncIncomeFormVisibility);
      // начальная синхронизация
      syncIncomeFormVisibility();
    }
  } catch{}
function updateBuyCalc(){
  const price=parseFloat($('#buyPrice').value)||0;
  let totalQty=0,totalSum=0;
  const auto000 = document.getElementById('buyAuto000')?.checked;
  document.querySelectorAll('.buySum').forEach(inp=>{
    const p=inp.dataset.p;
    let raw = inp.value.trim();
    let sum = parseFloat(raw)||0;
    if (auto000 && /^\d+$/.test(raw)) {
      sum = sum * 1000;
    }
    const qty=price?sum/price:0;
    inp.closest('tr').querySelector('.buyQty').textContent=fmt(qty);
    totalQty+=qty;totalSum+=sum;lastBuy.by[p]=inp.value;
  });
  let summary = totalSum > 0 ? `Сумма: ${fmtPretty(totalSum, 0)}$` : '';
  if (price && totalSum > 0) {
    summary += ` • Акций: ${Math.floor(totalQty)} шт.`;
  }
  let details = '';
  if(price && $('#buySymbol').value.trim()){
    details = `<div style="margin-top:6px;font-size:15px;color:#444">${$('#buySymbol').value.trim().toUpperCase()} • ${Math.floor(totalQty)} • ${Math.round(price)} / ${fmtPretty(totalSum, 0)}</div>`;
  }
  $('#buySummary').innerHTML = summary + (details?'<br>'+details:'');
  lastBuy.symbol=$('#buySymbol').value;lastBuy.price=$('#buyPrice').value;
  
  // Обновляем заголовки при изменении данных
  updateBuyHeaders();
}
// Полная очистка полей покупки (участники, название, курс)
function clearBuyFields(){
  try{
    const symEl = document.getElementById('buySymbol');
    const priceEl = document.getElementById('buyPrice');
    if (symEl) symEl.value = '';
    if (priceEl) priceEl.value = '';
    document.querySelectorAll('.buySum').forEach(inp=>{ inp.value=''; });
    localStorage.removeItem('cf_buyTemp');
    updateBuyCalc();
  }catch{}
}
function saveBuy(){pushUndo();
  let symbol=$('#buySymbol').value.trim().toUpperCase();
  const price=parseFloat($('#buyPrice').value);
  if(!symbol||!price)return showToast('Укажите акцию и цену');
  // Ход покупки (для сортировки и отображения)
  let buyTurnLabel = (document.getElementById('buyTurnInput')?.value||'').trim();
  if (!buyTurnLabel){
    const t = parseInt(localStorage.getItem('cf_turn_number')||'1',10)||1;
    buyTurnLabel = 'Ход ' + t;
  }
  
  // Генерируем номер покупки
  let buyNumber = 1;
  try {
    const existingNumbers = new Set();
    Object.values(holdings).forEach(ph => {
      Object.keys(ph).forEach(s => {
        const turnInfo = LS.load('cf_buyTurnBySymbol', {})[s] || '';
        const match = turnInfo.match(/№(\d+)/);
        if (match) {
          existingNumbers.add(parseInt(match[1]));
        }
      });
    });
    
    // Находим следующий доступный номер
    while (existingNumbers.has(buyNumber)) {
      buyNumber++;
    }
  } catch {}
  
  // Формируем полную метку с номером покупки и ходом
  const fullBuyLabel = `№${buyNumber}, ${buyTurnLabel}`;
  // Проверка на уникальность названия акции
  let baseSymbol = symbol;
  let idx = 2;
  let allSymbols = new Set();
  Object.values(holdings).forEach(ph=>{Object.keys(ph).forEach(s=>allSymbols.add(s));});
  while(allSymbols.has(symbol)) {
    symbol = baseSymbol + idx;
    idx++;
  }
  let any=false;
  let symbolTotalBuy = 0;
  const auto000 = document.getElementById('buyAuto000')?.checked;
  document.querySelectorAll('.buySum').forEach(inp=>{
    const p=inp.dataset.p;
    let raw = inp.value.trim();
    let sum = parseFloat(raw)||0;
    if (auto000 && /^\d+$/.test(raw)) sum = sum * 1000;
    if(sum<=0)return;any=true;symbolTotalBuy+=sum;const qty=sum/price;if(!holdings[p])holdings[p]={};if(!holdings[p][symbol])holdings[p][symbol]={qty:0,avgCost:0};const h=holdings[p][symbol];const totalCost=h.avgCost*h.qty+sum;h.qty+=qty;h.avgCost=totalCost/h.qty;
  });
  if(!any)return showToast('Нет сумм');
  
  // Сохраняем оригинальную сумму покупки по символу (не меняется при коэффициентах)
  if (!(symbol in buySumOriginal)) buySumOriginal[symbol] = 0;
  buySumOriginal[symbol] += symbolTotalBuy;
  LS.save('cf_buySumOriginal', buySumOriginal);
  
  // Списываем только сумму владельца с баланса
  const ownerName = localStorage.getItem('cf_owner') || (participants[0]||'');
  let ownerSum = 0;
  document.querySelectorAll('.buySum').forEach(inp=>{
    const p=inp.dataset.p;
    if (p === ownerName) {
      let raw = inp.value.trim();
      let sum = parseFloat(raw)||0;
      if (auto000 && /^\d+$/.test(raw)) sum = sum * 1000;
      ownerSum += sum;
    }
  });
  
  const spend = Math.round(ownerSum)||0;
  if (spend > 0) {
    const st = getMoveState();
    const balNow = Math.round(st.balance||0);
    if (balNow < spend) {
      // Показываем диалог подтверждения
      if (confirm(`Не хватает денег. Все равно купить?\n\nТребуется: ${fmtPretty(spend,0)}$\nДоступно: ${fmtPretty(balNow,0)}$\nНедостает: ${fmtPretty(spend - balNow,0)}$`)) {
        // Пользователь подтвердил - продолжаем
      } else {
        // Пользователь отменил
        return;
      }
    }
    
    // Списываем сумму покупки с баланса владельца
    try{
      const st = getMoveState();
      st.balance = Math.round((st.balance||0) - spend);
      setMoveState(st);
      updateTopBalance();
      
      // Проверяем, стал ли баланс отрицательным
      if (st.balance < 0) {
        showToast('Баланс отрицательный', 2000);
      }
      
      addHistory('Баланс', `Покупка акций ${symbol} (${ownerName}): -${fmtPretty(spend,0)}$`);
      try{ addTurnEventForCurrentTurn(-spend, `Покупка акций ${symbol} (${ownerName})`); }catch{}
      try{ renderTurnsHistory(); }catch{}
    }catch{}
  }
  // Копим по участникам
  if (!buySumByParticipant[symbol]) buySumByParticipant[symbol] = {};
  document.querySelectorAll('.buySum').forEach(inp=>{
    const p=inp.dataset.p;
    let raw = inp.value.trim();
    let sum = parseFloat(raw)||0;
    if (auto000 && /^\d+$/.test(raw)) sum = sum * 1000;
    if(sum>0){buySumByParticipant[symbol][p]=(buySumByParticipant[symbol][p]||0)+sum;}
  });
  LS.save('cf_buySumByParticipant', buySumByParticipant);
  // Сохраняем метку хода покупки с номером
  try{
    const key = 'cf_buyTurnBySymbol';
    const map = LS.load(key, {});
    map[symbol] = fullBuyLabel;
    LS.save(key, map);
  }catch{}
  saveAll();showToast('Сделка сохранена');
  addHistory('Покупка', `${symbol} @ ${Math.round(price)} — <span style='color:#888'>${new Date().toLocaleTimeString()}</span>`);
  $('#buySymbol').value='';
  $('#buyPrice').value='';
  document.querySelectorAll('.buySum').forEach(inp=>inp.value='');
  localStorage.removeItem('cf_buyTemp');
  renderBuy();
  renderSell();
  
  // Обновляем заголовки после сохранения сделки
  setTimeout(() => updateBuyHeaders(), 0);
}
// Продажа
function renderSell(){
  const tbl=$('#sellTable');tbl.innerHTML='';
  let symbols=new Set();
  Object.values(holdings).forEach(ph=>{Object.entries(ph).forEach(([s,obj])=>{if(obj.qty>0)symbols.add(s);});});
  symbols=[...symbols];
  // Сортируем символы по номеру покупки (чем раньше купили, тем выше)
  try{
    const turnMap = LS.load('cf_buyTurnBySymbol', {});
    const extractBuyNum = (lbl)=>{ 
      const m=String(lbl||'').match(/№(\d+)/); 
      return m?parseInt(m[1],10):999; // Если нет номера, ставим в конец
    };
    symbols.sort((a,b)=> extractBuyNum(turnMap[a]) - extractBuyNum(turnMap[b]));
  }catch{}
  if(!symbols.length){tbl.innerHTML='<tr><td style="padding:24px;color:#888">Нет акций для продажи</td></tr>';$('#sellSummary').textContent='';return;}
  let sellTotals = {};
  // Сохраняем значения цен продажи для каждой акции между рендерами
  let sellPrices = loadSellPrices();
  const ownerName = localStorage.getItem('cf_owner') || (participants[0]||'');
    symbols.forEach(sym=>{
    // Считаем общее количество акций по символу
    let totalQty = 0;
    participants.forEach(p=>{
      const hld=holdings[p]?.[sym];
      if(hld) totalQty += hld.qty;
    });
    // Найти первую цену покупки для этой акции среди участников
    let buyPrice = null;
    for (const p of participants) {
      if (holdings[p] && holdings[p][sym] && holdings[p][sym].avgCost) {
        buyPrice = holdings[p][sym].avgCost;
        break;
      }
    }
    // Сумма покупки: используем сохранённую оригинальную сумму (если есть), иначе считаем по текущей средней
    let buySum = null;
    if (buySumOriginal[sym] !== undefined) {
      buySum = Math.round(buySumOriginal[sym]);
    } else if (buyPrice !== null) {
      buySum = Math.round(totalQty * buyPrice);
    }
    const factors = Array.isArray(sellFactors[sym]) ? sellFactors[sym] : [];
    const factorTag = factors.length ? ` <span style="margin-left:12px;color:#888;font-size:12px">× ${factors.join(' → ')}</span>` : '';
    const isBurned = !!burnedSymbols[sym];
    const titleTr=document.createElement('tr');
    const priceVal = parseFloat(sellPrices[sym]) || 0;
    const sellSumVal = (priceVal>0 && totalQty>0) ? Math.round(totalQty * priceVal) : 0;
    const defaultRecipientOptions = ['<option value="">— выбрать —</option>']
      .concat((participants||[]).map(name=>`<option value="${name}">${name}</option>`))
      .join('');
    const buyTurnLbl = (LS.load('cf_buyTurnBySymbol', {})||{})[sym] || '';
    titleTr.innerHTML=`<th colspan="13" style="background:#f1f8ff;text-align:left;${isBurned?'text-decoration:line-through;color:#aaa':''}" class="sell-header-summary">${sym}${buyTurnLbl?` <span style='margin-left:12px;color:#666;font-size:12px'>(${buyTurnLbl})</span>`:''}${factorTag} <span class="sumTotalSharesLabel" style="margin-left:24px;color:#444">Акций: <b>${fmtPretty(Math.round(totalQty), 0)}</b></span>`
      + (buyPrice !== null ? `<span class="buyPriceNowrap" style="margin-left:24px;color:#888">Цена покупки: <b>${fmt(buyPrice)}</b></span>` : '')
      + (buySum !== null ? `<span class="buyPriceNowrap" style="margin-left:24px;color:#888">Сумма покупки: <b>${fmtPretty(buySum, 0)}</b></span>` : '')
      + `<span class="sellTotalSumLabel" data-sym="${sym}" style="margin-left:24px;color:#444">Сумма продажи: <b class="sellTotalSum" data-sym="${sym}">${sellSumVal?fmtPretty(sellSumVal,0):''}</b></span>`
      + `<button class="btn" style="margin-left:18px;padding:2px 10px;font-size:13px;background:#e6e6ff;color:#333;border:1px solid #b3b3f6;vertical-align:middle;" onclick="adjustSharesPrompt('${sym}')">× / ÷</button>`
      + `<button class="btn" style="margin-left:8px;padding:2px 10px;font-size:13px;background:#ffe6e6;color:#333;border:1px solid #f6b3b3;vertical-align:middle;" onclick="burnSymbol('${sym}')">🔥 Сгорело</button>`
      + `<br><span class="nowrapLabel" style="margin-left:0;">Цена продажи: <input type="number" step="0.01" placeholder="Цена продажи" class="sellPriceForSymbol" data-sym="${sym}" style="width:120px;" value="${sellPrices[sym]||''}" onfocus="clearZeroOnFocus(this)"></span>`
      + `<span class="nowrapLabel" style="margin-left:16px;">Посредник: <select class="sellDefaultRecipient" data-sym="${sym}" style="min-width:120px">${defaultRecipientOptions}</select></span>`
      + `<span class="nowrapLabel" style="margin-left:12px;">% <input type="number" step="1" class="sellDefaultCardCom" data-sym="${sym}" style="width:60px" value="${sellCardDefaultCom[sym]||''}" onfocus="clearZeroOnFocus(this)"></span>`
      + `<button class="btn" style="margin-left:8px;padding:2px 10px;font-size:13px;background:#e6ffe6;color:#333;border:1px solid #b3f6b3;vertical-align:middle;" onclick="applyDefaultMediator('${sym}')">Применить посредника</button>`
      + `</th>`;
    tbl.appendChild(titleTr);
    const trh=document.createElement('tr');
    trh.innerHTML='<th>✔</th><th>Участник</th><th>К выдаче</th><th>Без комис.</th><th>Ком<br>%</th><th>Ком<br>$</th><th>Сумма $</th><th>Чистыми<br>$</th><th>Участник</th><th>Акций</th><th>Акций<br>чистых</th><th>Посредник %</th><th>Посредник</th><th>Посредник $</th>';
    tbl.appendChild(trh);
    participants.forEach((p)=>{
      const hld=holdings[p]?.[sym];
      const isOwner = p === ownerName;
      let qty = hld ? hld.qty : 0;
      const isSoldOut = hld && qty <= 0;
      const tr=document.createElement('tr');tr.dataset.p=p;tr.dataset.sym=sym;
      const com=isOwner?0:(participantCom[p]!==undefined?participantCom[p]:20);
      const cardComVal = (sellCardCom[sym] && sellCardCom[sym][p] !== undefined) ? sellCardCom[sym][p] : 0;
      if(!window._sellGiven) window._sellGiven={};
      if(!window._sellGiven[sym]) window._sellGiven[sym]={};
      if(isSoldOut){
        tr.style.background='#f6f6f6';
        tr.style.textDecoration='line-through';
        let given = window._sellGiven[sym][p]!==undefined ? window._sellGiven[sym][p] : '';
        tr.innerHTML = `<td><input type=\"checkbox\" class=\"paidChkSell\" onchange=\"togglePaidSell(this)\"></td>`+
          `<td>${p}${isOwner?' <span style=\\"color:#888;font-size:13px\\">(владелец)</span>':''}</td>`+
          `<td>${given?fmtPretty(Math.round(given),0):''}</td>`+
          `<td></td>`+
          `<td></td>`+
          `<td></td>`+
          `<td></td>`+
          `<td></td>`+
          `<td>${p}${isOwner?' <span style=\\"color:#888;font-size:13px\\">(владелец)</span>':''}</td>`+
          `<td></td>`+
          `<td></td>`+
          `<td></td>`+
          `<td></td>`+
          `<td>0</td>`;
      } else if(hld && qty>0) {
        const recipientSel = (participants||[]).map(name=>`<option value="${name}">${name}</option>`).join('');
        const currentRecipient = sellCardRecipient[sym]?.[p] || '';
        const investedVal = (buySumByParticipant[sym] && buySumByParticipant[sym][p]) ? Math.round(buySumByParticipant[sym][p]) : '';
        tr.innerHTML=`<td><input type=\"checkbox\" class=\"paidChkSell\" onchange=\"togglePaidSell(this)\"></td>`+
          `<td>${p}${isOwner?' <span style=\\"color:#888;font-size:13px\\">(владелец)</span>':''}</td>`+
          `<td class=\"sumWithSell\">0</td>`+
          `<td class=\"sumNoSell\">0</td>`+
          `<td><input type=\"number\" step=\"1\" value=\"${com}\" class=\"sellCommSell\" style=\"width:63px;${isOwner?'background:#eee;color:#888':''}\" ${isOwner?'readonly':''} onfocus=\"clearZeroOnFocus(this)\"></td>`+
          `<td class=\"sumCommission\">0</td>`+
          `<td class=\"investedCell\">${investedVal?fmtPretty(investedVal,0):''}</td>`+
          `<td class=\"netProfitCell\">0</td>`+
          `<td>${p}${isOwner?' <span style=\\"color:#888;font-size:13px\\">(владелец)</span>':''}</td>`+
          `<td class=\"buyQtySell\" style=\"width:90px;\">${fmt(hld.qty)}</td>`+
          `<td class=\"sharesAfterAllCommissions\">0</td>`+
          `<td><input type=\"number\" step=\"1\" value=\"${cardComVal}\" class=\"sellCardCommSell\" style=\"width:63px;\" onfocus=\"clearZeroOnFocus(this)\"></td>`+
          `<td><select class=\"sellCardRecipientSel\" data-sym=\"${sym}\" data-p=\"${p}\" style=\"min-width:120px\"><option value=\"\">— выбрать —</option>${recipientSel}</select></td>`+
          `<td class=\"sumCardCell\">0</td>`;
        setTimeout(()=>{ const sel=tr.querySelector('.sellCardRecipientSel'); if(sel) sel.value=currentRecipient; },0);
        if(isOwner) tr.style.background='#f6f6f6';
        setTimeout(()=>{
          // Комиссия участия редактируется только для не-владельца
          if(!isOwner){
            const commInput = tr.querySelector('.sellCommSell');
            commInput.oninput = function(e) {
              const val = parseFloat(e.target.value)||0;
              if(!sellDealCom[sym]) sellDealCom[sym] = {};
              sellDealCom[sym][p] = val;
              LS.save('cf_sellDealCom', sellDealCom);
              updateSellCalc();
            };
            commInput.onchange = commInput.oninput;
            tr.querySelector('.sellCommSell').oninput=updateSellCalc;
          }
          // Процент карточки редактируется и для владельца, и для остальных
          const cardInput = tr.querySelector('.sellCardCommSell');
          cardInput.oninput = function(e){
            const v = parseFloat(e.target.value)||0;
            if(!sellCardCom[sym]) sellCardCom[sym] = {};
            sellCardCom[sym][p] = v;
            LS.save('cf_sellCardCom', sellCardCom);
            updateSellCalc();
          };
          cardInput.onchange = cardInput.oninput;
          const recSel = tr.querySelector('.sellCardRecipientSel');
          recSel.onchange = function(e){
            if(!sellCardRecipient[sym]) sellCardRecipient[sym] = {};
            sellCardRecipient[sym][p] = e.target.value;
            LS.save('cf_sellCardRecipient', sellCardRecipient);
            updateSellCalc();
          };
        },0);
      }
      tbl.appendChild(tr);
    });
    // Итоги по символу будут добавляться внутри updateSellCalc
  });
  setTimeout(()=>{
    document.querySelectorAll('.sellPriceForSymbol').forEach(inp=>{
      inp.oninput=()=>{saveSellPrices();updateSellCalc();updateSellTotalSum(inp.dataset.sym);};
      inp.onchange=()=>{saveSellPrices();updateSellCalc();updateSellTotalSum(inp.dataset.sym);};
    });
    // Инициализация селектов и процентов посредника по умолчанию
    document.querySelectorAll('.sellDefaultRecipient').forEach(sel=>{
      const sym = sel.dataset.sym;
      sel.value = sellCardDefaultRecipient[sym] || '';
      sel.onchange = (e)=>{
        sellCardDefaultRecipient[sym] = e.target.value;
        LS.save('cf_sellCardDefaultRecipient', sellCardDefaultRecipient);
      };
    });
    document.querySelectorAll('.sellDefaultCardCom').forEach(inp=>{
      const sym = inp.dataset.sym;
      inp.oninput = (e)=>{
        const v = parseFloat(e.target.value)||0;
        sellCardDefaultCom[sym] = v;
        LS.save('cf_sellCardDefaultCom', sellCardDefaultCom);
      };
      inp.onchange = inp.oninput;
    });
    restorePaidSells(); // Восстановить состояние галочек после рендера
    updateSellCalc();
  },0);
  // Все итоги пересчитываются внутри updateSellCalc
}
// Применить посредника по умолчанию для всех строк символа
function applyDefaultMediator(sym){
  try {
    const recipient = (sellCardDefaultRecipient && sellCardDefaultRecipient[sym]) ? sellCardDefaultRecipient[sym] : '';
    const percent = (sellCardDefaultCom && !isNaN(parseFloat(sellCardDefaultCom[sym]))) ? parseFloat(sellCardDefaultCom[sym]) : 0;
    if (!recipient) { showToast('Выберите посредника'); return; }
    if (!sellCardCom[sym]) sellCardCom[sym] = {};
    if (!sellCardRecipient[sym]) sellCardRecipient[sym] = {};
    (participants||[]).forEach(pName => {
      const have = holdings[pName] && holdings[pName][sym] && holdings[pName][sym].qty>0;
      if (have){
        sellCardCom[sym][pName] = percent;
        sellCardRecipient[sym][pName] = recipient;
      }
    });
    LS.save('cf_sellCardCom', sellCardCom);
    LS.save('cf_sellCardRecipient', sellCardRecipient);
    renderSell();
    showToast('Посредник применён к строкам');
  } catch(e){
    console.error('applyDefaultMediator error', e);
    showToast('Ошибка применения посредника');
  }
}
function doSell(p,sym,btn){pushUndo();
  const tr=btn.closest('tr');
  const qty=parseFloat(tr.querySelector('.sellQtySell').value)||0;
  const maxQty=parseFloat(tr.querySelector('.buyQtySell')?.textContent)||0;
  if(qty>maxQty||qty<=0)return showToast('Некорректное количество');
  // Сохраняем сумму к выдаче для этого участника и акции
  const priceInput = document.querySelector(`.sellPriceForSymbol[data-sym='${sym}']`);
  const price = priceInput ? parseFloat(priceInput.value)||0 : 0;
  const comInput = tr.querySelector('.sellCommSell');
  const com = comInput ? parseFloat(comInput.value)||0 : 0;
  const net = price && qty ? qty*price*(1-com/100) : 0;
  if(!window._sellGiven) window._sellGiven={};
  if(!window._sellGiven[sym]) window._sellGiven[sym]={};
  window._sellGiven[sym][p] = (window._sellGiven[sym][p]||0) + net;
  holdings[p][sym].qty-=qty;
  
  // Записываем в историю ходов продажу акций
  try{ addTurnEventForCurrentTurn(net, `Продажа акций ${sym}: ${qty} шт. по ${price}$ (${p})`); }catch{}
  try{ renderTurnsHistory(); }catch{}
  
  addHistory('Продажа', `${sym}: <b>${Math.floor(qty)}</b> по <b>${Math.round(price)}</b> (${p})`);
  if(holdings[p][sym].qty>0){
    setTimeout(()=>{renderSell();
      const rows = document.querySelectorAll(`tr[data-p='${p}'][data-sym='${sym}']`);
      if(rows.length){
        const last = rows[rows.length-1];
        const inp = last.querySelector('.sellQtySell');
        if(inp) inp.focus();
      }
    }, 50);
  } else {
    saveAll();renderSell();
  }
}
// 4. Шаблоны названий и цен в продаже
let sellSymbolTpls=LS.load('cf_sellSymbolTpls',[]);
let sellPriceTpls=LS.load('cf_sellPriceTpls',[]);
function renderSellTemplates(){
  // Названия
  const partnerSymbolEl = document.getElementById('partnerSymbol');
  const partnerSellEl = document.getElementById('partnerSell');
  if(!partnerSymbolEl || !partnerSellEl){
    return; // базовые поля партнёров отсутствуют (например, при динамическом UI) — выходим безопасно
  }
  let wrap = document.getElementById('sellSymbolTpls');
  if(!wrap){wrap=document.createElement('div');wrap.id='sellSymbolTpls';partnerSymbolEl.insertAdjacentElement('afterend',wrap);} 
  wrap.style.display='inline-block';
  wrap.innerHTML = sellSymbolTpls.map((s,i)=>`<span style="background:#e6f0ff;padding:4px 10px;border-radius:12px;margin:2px;display:inline-block;cursor:pointer;position:relative" onclick="$('#partnerSymbol').value='${s}';updateSellCalc()">${s} <button tabindex="-1" onclick="event.stopPropagation();confirmDelSellSymbolTpl(${i})" style="background:none;border:none;color:#bbb;font-size:12px;margin-left:4px;opacity:0.5;vertical-align:middle;pointer-events:auto;border-radius:50%;width:20px;height:20px;line-height:16px;display:inline-flex;align-items:center;justify-content:center;outline:none;">✖</button></span>`).join('');
  // Цены
  let wrap2 = document.getElementById('sellPriceTpls');
  if(!wrap2){wrap2=document.createElement('div');wrap2.id='sellPriceTpls';partnerSellEl.insertAdjacentElement('afterend',wrap2);} 
  wrap2.style.display='inline-block';
  wrap2.innerHTML = sellPriceTpls.map((s,i)=>`<span style="background:#e6f0ff;padding:4px 10px;border-radius:12px;margin:2px;display:inline-block;cursor:pointer;position:relative" onclick="$('#partnerSell').value='${s}';updateSellCalc()">${s} <button tabindex="-1" onclick="event.stopPropagation();confirmDelSellPriceTpl(${i})" style="background:none;border:none;color:#bbb;font-size:12px;margin-left:4px;opacity:0.5;vertical-align:middle;pointer-events:auto;border-radius:50%;width:20px;height:20px;line-height:16px;display:inline-flex;align-items:center;justify-content:center;outline:none;">✖</button></span>`).join('');
}
function confirmDelSellSymbolTpl(i){if(confirm('Удалить этот шаблон?')) delSellSymbolTpl(i);}
function confirmDelSellPriceTpl(i){if(confirm('Удалить этот шаблон?')) delSellPriceTpl(i);}
// Закомментировано, так как элементы партнеров теперь создаются динамически
/*
$('#partnerSymbol').addEventListener('change',()=>{
  const val=$('#partnerSymbol').value.trim();
  if(val && !sellSymbolTpls.includes(val)){
    sellSymbolTpls.push(val);LS.save('cf_sellSymbolTpls',sellSymbolTpls);renderSellTemplates();
  }
});
$('#partnerSell').addEventListener('change',()=>{
  const val=$('#partnerSell').value.trim();
  if(val && !sellPriceTpls.includes(val)){
    sellPriceTpls.push(val);LS.save('cf_sellPriceTpls',sellPriceTpls);renderSellTemplates();
  }
});
*/
function updateSellCalc(){
  let totals = {};
  let paidTotals = {};
  let paidInvest = {};
  const ownerName = localStorage.getItem('cf_owner') || (participants[0]||'');
  let summaryRows = [];
  const tbl = document.getElementById('sellTable');
  // Удаляем предыдущие итоговые строки перед пересчетом
  Array.from(tbl.querySelectorAll('tr')).forEach(tr => {
    if (tr.innerHTML && (tr.innerHTML.includes('Всего (со мной)') || tr.innerHTML.includes('Всего (без меня)'))) tr.remove();
  });
  let totalCommissionAll = 0;
  let perRecipientAll = {}; // суммарно по посредникам (всех символов)
  let perRecipientPaid = {}; // выплачено посредникам по отмеченным строкам

  document.querySelectorAll('.sellPriceForSymbol').forEach(inp => {
    const sym = inp.dataset.sym;
    const price = parseFloat(inp.value) || 0;
    let totalQty = 0;

    const rows = Array.from(tbl.querySelectorAll(`tr[data-sym='${sym}']`));
    let sumWith = {withSell:0, noSell:0, commission:0, qty:0, remain:0, card:0, invested:0};
    let sumWithout = {withSell:0, noSell:0, commission:0, qty:0, remain:0, card:0, invested:0};
    let cardDueSym = 0; // сколько посреднику по этому символу (по невыплаченным строкам)

    rows.forEach(tr => {
      const commInput = tr.querySelector('.sellCommSell');
      const com = parseFloat(commInput?.value) || 0;
      const cardInput = tr.querySelector('.sellCardCommSell');
      const cardCom = parseFloat(cardInput?.value) || 0;
      const paid = tr.classList.contains('paid');
      const haveQty = parseFloat(tr.querySelector('.buyQtySell')?.textContent.replace(/\s/g,'')||'0');
      const qty = haveQty; // продаем весь доступный объём, поля ввода количества больше нет

      let gross = 0, net = 0, cardAmount = 0, participantCommission = 0;
      if (price && qty > 0) {
        gross = qty * price;
        const totalPercent = Math.max(com,0) + Math.max(cardCom,0);
        net = gross * (1 - totalPercent/100);
        cardAmount = gross * (Math.max(cardCom,0)/100);
        participantCommission = gross * (Math.max(com,0)/100);
      }

      const p = tr.dataset.p;
      const sumNoSell = tr.querySelector('.sumNoSell');
      const sumWithSell = tr.querySelector('.sumWithSell');
      const sumCommission = tr.querySelector('.sumCommission');
      const sumCardCell = tr.querySelector('.sumCardCell');
      const netProfitCell = tr.querySelector('.netProfitCell');
      const remainCell = tr.querySelector('.remainSell');
      const noSellVal = gross ? Math.round(gross) : 0;
      const withSellVal = net ? Math.round(net) : 0;
      if (sumNoSell) sumNoSell.textContent = noSellVal ? fmtPretty(noSellVal, 0) : '';
      if (sumWithSell) sumWithSell.textContent = withSellVal ? fmtPretty(withSellVal, 0) : '';
      // Комиссионные: только обычная комиссия участника, без посредника
      const commVal = participantCommission ? Math.round(participantCommission) : 0;
      if (sumCommission) sumCommission.textContent = commVal > 0 ? fmtPretty(commVal, 0) : '';
      if (sumCardCell) sumCardCell.textContent = cardAmount > 0 ? fmtPretty(Math.round(cardAmount), 0) : '';
      
      // Расчет "Чистыми" = К выдаче - Сумма инвестиций
      if (netProfitCell) {
        const investedVal = (buySumByParticipant[sym] && buySumByParticipant[sym][p]) ? Math.round(buySumByParticipant[sym][p]) : 0;
        const netProfit = withSellVal - investedVal;
        if (withSellVal > 0 && investedVal > 0) {
          const profitRatio = investedVal > 0 ? (withSellVal / investedVal).toFixed(2) : '0.00';
          netProfitCell.textContent = `+${fmtPretty(netProfit, 0)}, x${profitRatio}`;
        } else if (withSellVal > 0) {
          netProfitCell.textContent = `+${fmtPretty(netProfit, 0)}`;
        } else {
          netProfitCell.textContent = '';
        }
      }
      
      // Расчет "Акций чистых" (после вычета всех комиссий)
      const sharesAfterAllCommissionsCell = tr.querySelector('.sharesAfterAllCommissions');
      if (sharesAfterAllCommissionsCell && price > 0 && qty > 0) {
        const totalCommissionPercent = Math.max(com, 0) + Math.max(cardCom, 0);
        const sharesAfterAllCommissions = qty * (1 - totalCommissionPercent / 100);
        sharesAfterAllCommissionsCell.textContent = sharesAfterAllCommissions > 0 ? fmt(sharesAfterAllCommissions) : '';
      }
      
      if (remainCell) {
        remainCell.textContent = '';
      }
      const rec = (sellCardRecipient[sym] && sellCardRecipient[sym][p]) ? sellCardRecipient[sym][p] : '';
      const isOwner = p === ownerName;
      if (!isOwner && price) {
        if (!paid) totals[p] = (totals[p]||0) + net;
        else paidTotals[p] = (paidTotals[p]||0) + net;
      }
      if (paid) {
        const avgCost = (holdings[p] && holdings[p][sym] && holdings[p][sym].avgCost) ? holdings[p][sym].avgCost : 0;
        paidInvest[p] = (paidInvest[p]||0) + (avgCost * haveQty);
      }
      if (rec && cardAmount>0) {
        perRecipientAll[rec] = (perRecipientAll[rec]||0) + cardAmount;
        if (paid) perRecipientPaid[rec] = (perRecipientPaid[rec]||0) + cardAmount;
      }
      if (!paid && qty > 0) {
        totalQty += qty;
        cardDueSym += cardAmount;
      }

      // Копим итоги по символу
      const remainNum = 0;
      sumWith.withSell += withSellVal;
      sumWith.noSell += noSellVal;
      sumWith.commission += commVal;
      sumWith.qty += haveQty;
      sumWith.remain += remainNum;
      sumWith.card += Math.round(cardAmount)||0;
      // Инвестировано по участнику и символу (если есть сохранённые данные)
      const investedVal = (buySumByParticipant[sym] && buySumByParticipant[sym][p]) ? Math.round(buySumByParticipant[sym][p]) : 0;
      sumWith.invested += investedVal;
      if (!isOwner) {
        sumWithout.withSell += withSellVal;
        sumWithout.noSell += noSellVal;
        sumWithout.commission += commVal;
        sumWithout.qty += haveQty;
        sumWithout.remain += remainNum;
        sumWithout.card += Math.round(cardAmount)||0;
        sumWithout.invested += investedVal;
      }
      totalCommissionAll += commVal > 0 ? commVal : 0;
    });

    // Вставляем строки итогов прямо под группой символа
    if (rows.length) {
      const lastRow = rows[rows.length - 1];
      const totalTrWith = document.createElement('tr');
      totalTrWith.innerHTML = `<td colspan=\"2\" style=\"text-align:center;font-size:14px;color:#888;background:#f8f8f8;border-top:2px solid #e0e0e0;\">Всего (со мной):</td>`+
        // К выдаче
        `<td style=\\\"text-align:center;font-size:15px;color:#226;background:#f8f8f8;border-top:2px solid #e0e0e0;\\\">${fmtPretty(sumWith.withSell,0)}</td>`+
        // Без комис.
        `<td style=\\\"text-align:center;font-size:15px;color:#226;background:#f8f8f8;border-top:2px solid #e0e0e0;\\\">${fmtPretty(sumWith.noSell,0)}</td>`+
        // Ком % (пусто)
        `<td style=\\\"background:#f8f8f8;border-top:2px solid #e0e0e0;\\\"></td>`+
        // Ком $ (только участника)
        `<td style=\\\"text-align:center;font-size:15px;color:#226;background:#f8f8f8;border-top:2px solid #e0e0e0;\\\">${fmtPretty(sumWith.commission,0)}</td>`+
        // Сумма $
        `<td style=\\\"text-align:center;font-size:15px;color:#226;background:#f8f8f8;border-top:2px solid #e0e0e0;\\\">${fmtPretty(sumWith.invested,0)}</td>`+
        // Чистыми
        `<td style=\\\"text-align:center;font-size:15px;color:#226;background:#f8f8f8;border-top:2px solid #e0e0e0;\\\">+${fmtPretty(sumWith.withSell - sumWith.invested,0)}</td>`+
        // Участник (дубликат)
        `<td style=\\\"background:#f8f8f8;border-top:2px solid #e0e0e0;\\\"></td>`+
        // Акций
        `<td style=\\\"text-align:center;font-size:15px;color:#226;background:#f8f8f8;border-top:2px solid #e0e0e0;\\\">${Math.floor(sumWith.qty)}</td>`+
        // Акций чистых (после всех комиссий)
        `<td style=\\\"text-align:center;font-size:15px;color:#226;background:#f8f8f8;border-top:2px solid #e0e0e0;\\\">${Math.floor(sumWith.qty * (1 - ((sumWith.commission / (sumWith.noSell || 1) * 100) + (sumWith.card / (sumWith.noSell || 1) * 100)) / 100))}</td>`+
        // Посредник % (пусто)
        `<td style=\\\"background:#f8f8f8;border-top:2px solid #e0e0e0;\\\"></td>`+
        // Посредник (пусто)
        `<td style=\\\"background:#f8f8f8;border-top:2px solid #e0e0e0;\\\"></td>`+
        // Посредник $
        `<td style=\\\"text-align:center;font-size:15px;color:#226;background:#f8f8f8;border-top:2px solid #e0e0e0;\\\">${fmtPretty(sumWith.card,0)}</td>`;
      lastRow.parentNode.insertBefore(totalTrWith, lastRow.nextSibling);

      const totalTrWithout = document.createElement('tr');
      totalTrWithout.innerHTML = `<td colspan=\"2\" style=\"text-align:center;font-size:14px;color:#888;background:#f8f8f8;\">Всего (без меня):</td>`+
        // К выдаче
        `<td style=\\\"text-align:center;font-size:15px;color:#c33;background:#f8f8f8;\\\">${fmtPretty(sumWithout.withSell,0)}</td>`+
        // Без комис.
        `<td style=\\\"text-align:center;font-size:15px;color:#c33;background:#f8f8f8;\\\">${fmtPretty(sumWithout.noSell,0)}</td>`+
        // Ком % (пусто)
        `<td style=\\\"background:#f8f8f8;\\\"></td>`+
        // Ком $
        `<td style=\\\"text-align:center;font-size:15px;color:#c33;background:#f8f8f8;\\\">${fmtPretty(sumWithout.commission,0)}</td>`+
        // Сумма $
        `<td style=\\\"text-align:center;font-size:15px;color:#c33;background:#f8f8f8;\\\">${fmtPretty(sumWithout.invested,0)}</td>`+
        // Чистыми
        `<td style=\\\"text-align:center;font-size:15px;color:#c33;background:#f8f8f8;\\\">+${fmtPretty(sumWithout.withSell - sumWithout.invested,0)}</td>`+
        // Участник (дубликат)
        `<td style=\\\"background:#f8f8f8;\\\"></td>`+
        // Акций
        `<td style=\\\"text-align:center;font-size:15px;color:#c33;background:#f8f8f8;\\\">${Math.floor(sumWithout.qty)}</td>`+
        // Акций чистых (после всех комиссий)
        `<td style=\\\"text-align:center;font-size:15px;color:#c33;background:#f8f8f8;\\\">${Math.floor(sumWithout.qty * (1 - ((sumWithout.commission / (sumWithout.noSell || 1) * 100) + (sumWithout.card / (sumWithout.noSell || 1) * 100)) / 100))}</td>`+
        // Посредник % (пусто)
        `<td style=\\\"background:#f8f8f8;\\\"></td>`+
        // Посредник (пусто)
        `<td style=\\\"background:#f8f8f8;\\\"></td>`+
        // Посредник $
        `<td style=\\\"text-align:center;font-size:15px;color:#c33;background:#f8f8f8;\\\">${fmtPretty(sumWithout.card,0)}</td>`;
      totalTrWith.parentNode.insertBefore(totalTrWithout, totalTrWith.nextSibling);
    }

    if (totalQty > 0 && price > 0) {
      const sum = Math.round(totalQty * price);
      summaryRows.push({sym, qty: Math.floor(totalQty), price: Math.round(price), sum: fmtPretty(sum, 0), cardDue: Math.round(cardDueSym)});
    } else if (totalQty > 0) {
      summaryRows.push({sym, qty: Math.floor(totalQty), price: '', sum: '', cardDue: 0});
    }
  });

  // Итоговая строка К выдаче
  let sums = Object.entries(totals).filter(([_,v])=>v>0).map(([k,v])=>`${k}: ${fmtPretty(Math.round(v), 0)}`).join('<br>');
  // Формат таблицы по всем символам
  let tableBlock = '';
  if (summaryRows.length) {
    const tableStr = `<div style="overflow-x:auto;"><table style="border-collapse:collapse;width:100%;max-width:700px;margin:0 auto;font-size:15px;text-align:center;">
      <tr style="background:#f6f6f6;color:#444;font-weight:500;">
        <th style="padding:4px 8px;border:1px solid #ddd;text-align:center;">Акция</th>
        <th style="padding:4px 8px;border:1px solid #ddd;text-align:center;">Кол-во</th>
        <th style="padding:4px 8px;border:1px solid #ddd;text-align:center;">Цена</th>
        <th style="padding:4px 8px;border:1px solid #ddd;text-align:center;">Сумма</th>
      </tr>` + summaryRows.map(r=>`<tr>
        <td style="padding:4px 8px;border:1px solid #eee;text-align:center;">${r.sym}</td>
        <td style="padding:4px 8px;border:1px solid #eee;text-align:center;">${r.qty}</td>
        <td style="padding:4px 8px;border:1px solid #eee;text-align:center;">${r.price}</td>
        <td style="padding:4px 8px;border:1px solid #eee;text-align:center;">${r.sum}</td>
      </tr>`).join('') + '</table></div>';
    tableBlock = `<div style='font-weight:600;margin:8px 0 6px 0;color:#444;text-align:center;'>Записи в бланке</div>` + tableStr;
  }
  // Суммарно сколько всего денег должен отдать владелец (owner) другим
  let totalToPay = Object.values(totals).reduce((a, b) => a + b, 0);
  let totalToPayStr = totalToPay > 0 ? `<div style='margin:18px 0 0 0;font-size:17px;color:#c33;font-weight:500;'>Всего к выдаче: <b>${fmtPretty(totalToPay, 0)} $</b></div>` : '';
  // Сумма всех комиссионных по всем акциям и участникам
  let totalCommissionStr = `<div style='margin:8px 0 0 0;font-size:16px;color:#226;font-weight:500;'>Заработок с комиссий: <b>${fmtPretty(totalCommissionAll, 0)} $</b></div>`;
  // Суммарно сколько всего уже выплачено по отмеченным строкам
  let paidStr = '';
  const paidLinesArr = Object.entries(paidTotals).filter(([_,v])=>v>0).map(([k,v])=>{
    const got = Math.round(v);
    const inv = Math.round(paidInvest[k]||0);
    const profit = got - inv;
    const mult = inv>0 ? (got/inv) : null;
    const multStr = mult!==null ? `, x${(mult).toFixed(2)}` : '';
    return `${k}: ${fmtPretty(got,0)} $ (${profit>=0?'+':''}${fmtPretty(Math.abs(profit),0)}$${multStr})`;
  });
  const paidLines = paidLinesArr.join('<br>');
  if (paidLines) paidStr += `<div style='margin:12px 0 0 0;font-size:16px;color:#226;font-weight:500;'>Заработано игроками:<br>${paidLines}</div>`;

  // В самом низу: заработано посредниками (каждый с новой строки)
  const mediatorLines = Object.entries(perRecipientAll)
    .filter(([_,v])=>v>0)
    .map(([k,v])=>`${k}: ${fmtPretty(Math.round(v),0)}`)
    .join('<br>');
  const mediatorEarnStr = mediatorLines ? `<div style='margin:12px 0 0 0;font-size:16px;color:#226;font-weight:600;'>Заработано посредниками:<br>${mediatorLines}</div>` : '';

  $('#sellSummary').innerHTML = (tableBlock ? tableBlock + '<br>' : '') + (sums ? `К выдаче:<br>${sums}` : '') + totalToPayStr + totalCommissionStr + paidStr + mediatorEarnStr;
}
function saveAll(){
  LS.save('cf_participants',participants);
  LS.save('cf_holdings',holdings);
  LS.save('cf_participantCom',participantCom);
  
  // Записываем в историю ходов сохранение данных
  try{ addTurnEventForCurrentTurn(0, 'Сохранение данных'); }catch{}
  try{ renderTurnsHistory(); }catch{}
}
// Партнеры: динамические строки, профит на новой строке, чекбокс выплачено
function renderPartners(){
  try {
    const wrap=$('#partnersContent');
    
    // Инициализируем _prevPaidAmount для существующих строк
    partnerRows.forEach(row => {
      if (row.paidAmount !== undefined && row._prevPaidAmount === undefined) {
        row._prevPaidAmount = parseFloat(row.paidAmount) || 0;
      }
    });
    
  let html = '<h2>Партнерские сделки</h2>';
    partnerRows.forEach((row,i)=>{
      const isPaid = !!row.paid;
      const disabledAttr = isPaid ? 'disabled' : '';
      const disabledStyle = isPaid ? 'background:#f5f5f5;color:#888;cursor:not-allowed;' : '';
      
      html += `<div style="margin-bottom:12px;padding:8px;${row.paid?'background:#e6ffe6':''}">`
        // Первая строка: Участник и Название
        + `<div style="margin-bottom:8px;display:flex !important;gap:8px !important;flex-wrap:nowrap !important;">`
        + `<div style="flex:1 !important;"><select onchange="editPartner(${i},'participant',this.value)" ${disabledAttr} style="width:100%;${disabledStyle}">`
        + `<option value="">Участник</option>`
        + participants.map(p=>`<option value="${p}"${row.participant===p?' selected':''}>${p}</option>`).join('')
        + `</select></div>`
        + `<div style="flex:1 !important;"><input placeholder="Название акции" value="${row.symbol||''}" onchange="editPartner(${i},'symbol',this.value)" ${disabledAttr} style="width:100%;${disabledStyle}"></div>`
        + `</div>`
        
        // Вторая строка: Сумма и Курс покупки
        + `<div style="margin-bottom:8px;display:flex !important;gap:8px !important;flex-wrap:nowrap !important;">`
        + `<div style="flex:1 !important;"><input type="number" step="0.01" placeholder="Сумма покупки" value="${row.sum||''}" onchange="editPartner(${i},'sum',this.value)" onfocus="clearZeroOnFocus(this)" ${disabledAttr} style="width:100%;${disabledStyle}"></div>`
        + `<div style="flex:1 !important;"><input type="number" step="0.01" placeholder="Курс покупки" value="${row.buy||''}" onchange="editPartner(${i},'buy',this.value)" onfocus="clearZeroOnFocus(this)" ${disabledAttr} style="width:100%;${disabledStyle}"></div>`
        + `</div>`
        
        // Третья строка: Курс продажи и Процент
        + `<div style="margin-bottom:8px;display:flex !important;gap:8px !important;flex-wrap:nowrap !important;">`
        + `<div style="flex:1 !important;"><input type="number" step="0.01" placeholder="Курс продажи" value="${row.sell||''}" onchange="editPartner(${i},'sell',this.value)" onfocus="clearZeroOnFocus(this)" ${disabledAttr} style="width:100%;${disabledStyle}"></div>`
        + `<div style="flex:1 !important;"><input type="number" step="1" placeholder="Комиссия %" value="${row.com!==undefined&&row.com!==''?row.com:20}" onchange="editPartner(${i},'com',this.value)" onfocus="clearZeroOnFocus(this)" ${disabledAttr} style="width:100%;${disabledStyle}"></div>`
        + `</div>`
        
        // Четвертая строка: Выплачено $ и чекбокс
        + `<div style="margin-bottom:8px;display:flex !important;gap:8px !important;flex-wrap:nowrap !important;">`
        + `<div style="flex:1 !important;"><input type="number" step="0.01" placeholder="Выплачено $" value="${row.paidAmount||''}" onchange="editPartner(${i},'paidAmount',this.value)" onfocus="clearZeroOnFocus(this)" ${disabledAttr} style="width:100%;${disabledStyle}"></div>`
        + `<div style="flex:1 !important;display:flex;align-items:center;">`
        + `<input type="checkbox" ${row.paid?'checked':''} onchange="editPartner(${i},'paid',this.checked)"> Выплачено`
        + `</div></div>`
        
        // Пятая строка: кнопки управления
        + `<div style="margin-bottom:8px;display:flex !important;gap:8px !important;justify-content:flex-end !important;">`
        + `<button class="btn" style="background:#eee;color:#c33;padding:4px 8px;" onclick="delPartner(${i})">✖</button>`
        + `<button class="btn" style="padding:4px 8px;font-size:12px;background:#e6e6ff;color:#333;border:1px solid #b3b3f6;" onclick="adjustPartnerQtyPrompt(${i})" ${disabledAttr}>× / ÷</button>`
        + `</div>`;
      html += '</div>';
      // расчет
      const sum=parseFloat(row.sum)||0, buy=parseFloat(row.buy)||0, sell=parseFloat(row.sell)||0, com=row.com!==undefined&&row.com!==''?parseFloat(row.com):20;
      const factorsArr = Array.isArray(row.factors) ? row.factors : [];
      const effFactor = factorsArr.length ? factorsArr.reduce((a,b)=>a*(parseFloat(b)||1),1) : 1;
      const factorsLabel = factorsArr.length ? `× ${factorsArr.join(' → ')}` : '';
      const qty = (buy>0) ? (sum/buy) * effFactor : 0;
      // Показываем расчеты поэтапно
      if(sum && buy){
        const sumBuy = sum;
        let calcHtml = '';
        
        // Всегда показываем количество акций и инвестируемую сумму
        calcHtml += `Акций: ${fmtPretty(qty, 0)}<br>`;
        
        // Если есть процент комиссии, показываем акции с учетом комиссии
        if(com > 0){
          const qtyWithCommission = Math.floor((sumBuy * (1 - com/100)) / buy);
          calcHtml += `(${fmtPretty(qtyWithCommission, 0)} с учетом %)<br>`;
        }
        
        calcHtml += `<br>Инвестируем: ${fmtPretty(sumBuy, 0)}<br>`;
        
        // Если есть курс продажи, показываем полные расчеты
        if(sell){
          const sumSell = qty * sell;
          const sumNet = sumSell * (1 - com/100);
          const profit = sumNet - sumBuy;
          const mult = sumBuy > 0 ? (sumNet/sumBuy) : null;
          const multStr = mult !== null ? ` <span style="color:#080">(x${mult.toFixed(1)})</span>` : '';
          
          calcHtml += `Сумма продажи: ${fmtPretty(sumSell, 0)}${factorsLabel?` <span style="color:#888;font-size:12px">(${factorsLabel})</span>`:''}<br><br>
Комиссия партнеру: <span style="color:#c33">${fmtPretty(sumSell - sumNet, 0)}</span><br>
Получу на руки: <span style="color:#226">${fmtPretty(sumNet, 0)}</span><br><br>
Чистая прибыль: <span style="color:#080;font-weight:600">${fmtPretty(profit, 0)}</span>${multStr}`;
        }
        
        html += `<div class="partner-calc" style="margin:0 0 12px 0;font-size:15px;color:#444;padding-left:8px;word-break:break-word;white-space:normal">${calcHtml}</div>`;

        // Добавляем кнопку "Показать текст/Скрыть текст" и тумблер "Ком%"
        const owner = (localStorage.getItem('cf_owner') || (participants[0]||'') || '').trim();
        const qtyInt = Math.floor(sumBuy / buy);
        const myQty = qtyInt; // В партнерских сделках все акции считаются "моими"
        
        html += `<div style=\"margin:8px 0 12px 0;\">`;
        html += `<button class=\"subtle-btn\" onclick=\"togglePartnerText(${i})\" id=\"partnerToggleTextBtn${i}\">Показать текст</button>`;
        html += `<div style=\"display:inline-block;margin-left:12px;vertical-align:middle;\">`;
        html += `<label style=\"font-size:13px;color:#666;margin-right:6px;\">Ком%</label>`;
        html += `<label class=\"switch\" style=\"transform:scale(0.8);\">`;
        html += `<input type=\"checkbox\" id=\"partnerCommissionToggle${i}\" onchange=\"updatePartnerText(${i})\">`;
        html += `<span class=\"slider\"></span>`;
        html += `</label>`;
        html += `</div>`;
        html += `</div>`;
        
        // Скрытый блок с текстом
        html += `<div id=\"partnerTextWrap${i}\" style=\"display:none;margin:8px 0 16px 0;\">`;
        html += `<div id=\"partnerTextContent${i}\" style=\"margin-top:320px;margin-bottom:320px;font-size:15px;line-height:1.5;text-align:center;\">`;
        // Текст будет заполнен JavaScript'ом
        html += `</div>`;
        html += `</div>`;
      }
    });
    html += `<button class="btn" style="margin-top:8px" onclick="addPartnerRow()">+ Добавить сделку</button>`;
    
    // Статистика заработка партнеров
    const partnerStats = {};
    partnerRows.forEach(row => {
      if (row.participant && row.sum && row.buy && row.sell) {
        const sum = parseFloat(row.sum) || 0;
        const buy = parseFloat(row.buy) || 0;
        const sell = parseFloat(row.sell) || 0;
        const com = row.com !== undefined && row.com !== '' ? parseFloat(row.com) : 20;
        const effFactor = Array.isArray(row.factors) ? row.factors.reduce((a,b) => a*(parseFloat(b)||1), 1) : 1;
        const qty = (buy > 0) ? (sum/buy) * effFactor : 0;
        const sumSell = qty * sell;
        const commission = sumSell * (com/100);
        
        if (!partnerStats[row.participant]) {
          partnerStats[row.participant] = 0;
        }
        partnerStats[row.participant] += commission;
      }
    });
    
    if (Object.keys(partnerStats).length > 0) {
      html += `<div style="margin-top:16px;padding:12px;background:#f0f8ff;border:1px solid #b3d6f6;border-radius:6px;">`;
      html += `<h4 style="margin:0 0 8px 0;color:#226;">Заработок партнеров на комиссии:</h4>`;
      Object.entries(partnerStats).forEach(([partner, commission]) => {
        html += `<div style="margin:4px 0;color:#444;">`;
        html += `<strong>${partner}</strong>: ${fmtPretty(Math.round(commission), 0)}$`;
        html += `</div>`;
      });
      html += `</div>`;
    }
    
    wrap.innerHTML = html;
    
    // Инициализируем текст для всех партнерских сделок
    partnerRows.forEach((row, index) => {
      if (row.sum && row.buy) {
        updatePartnerText(index);
      }
    });
  } catch(e) {
    console.error('Ошибка в renderPartners', e);
    showToast('Ошибка в партнерской вкладке, см. консоль');
  }
}

// Функция для показа/скрытия текста в партнерских сделках
function togglePartnerText(index) {
  try {
    const wrap = document.getElementById(`partnerTextWrap${index}`);
    const btn = document.getElementById(`partnerToggleTextBtn${index}`);
    if (!wrap || !btn) return;
    
    const hidden = (wrap.style.display === 'none' || wrap.style.display === '');
    wrap.style.display = hidden ? 'block' : 'none';
    btn.textContent = hidden ? 'Скрыть текст' : 'Показать текст';
  } catch(e) {
    console.error('Ошибка в togglePartnerText', e);
  }
}

// Функция для обновления текста в партнерских сделках
function updatePartnerText(index) {
  try {
    const row = partnerRows[index];
    if (!row) return;
    
    const contentEl = document.getElementById(`partnerTextContent${index}`);
    const toggleEl = document.getElementById(`partnerCommissionToggle${index}`);
    if (!contentEl || !toggleEl) return;
    
    const sum = parseFloat(row.sum) || 0;
    const buy = parseFloat(row.buy) || 0;
    const com = row.com !== undefined && row.com !== '' ? parseFloat(row.com) : 20;
    const hasCommission = com > 0;
    const owner = (localStorage.getItem('cf_owner') || (participants[0]||'') || '').trim();
    
    if (sum > 0 && buy > 0 && owner) {
      const qtyInt = Math.floor(sum / buy);
      
      let text = '';
      if (toggleEl.checked) {
        // Если галочка "Ком%" стоит - показываем количество с учетом комиссии
        const qtyWithCommission = hasCommission ? Math.floor((sum * (1 - com/100)) / buy) : qtyInt;
        text = `<div style="border:2px solid #4a90e2;border-radius:8px;padding:12px;background:#fff;display:inline-block;">Уважаемый банк перечислите ${fmtPretty(qtyWithCommission, 0)} акции на счёт ${escapeHtml(owner)}</div>`;
        if (hasCommission) {
          text += `<div style="margin-top:8px;font-size:14px;color:#666;">(Комиссия ${com}% учтена)</div>`;
        } else {
          text += `<div style="margin-top:8px;font-size:14px;color:#666;">(Без комиссии)</div>`;
        }
      } else {
        // Если галочка "Ком%" не стоит - показываем полное количество акций
        text = `<div style="border:2px solid #4a90e2;border-radius:8px;padding:12px;background:#fff;display:inline-block;">Уважаемый банк перечислите ${fmtPretty(qtyInt, 0)} акции на счёт ${escapeHtml(owner)}</div>`;
      }
      
      contentEl.innerHTML = text;
    } else {
      contentEl.innerHTML = '';
    }
  } catch(e) {
    console.error('Ошибка в updatePartnerText', e);
  }
}
function editPartner(i,key,val){
  // Проверяем, что строка существует
  if (!partnerRows[i]) {
    console.error('editPartner: строка не найдена, индекс:', i);
    return;
  }
  
  const row = partnerRows[i]; // Определяем row в начале функции
  
  // Блокируем редактирование полей, если стоит галочка "выплачено" (кроме самой галочки)
  if (row.paid && key !== 'paid') {
    showToast('Нельзя редактировать выплаченную сделку. Снимите галочку "Выплачено"', 2000);
    renderPartners(); // Обновляем отображение
    return;
  }
  
  // Захватываем предыдущее значение paid до изменения, чтобы корректно скорректировать баланс
  const prevPaid = (key==='paid') ? !!row.paid : null;
  if(key==='paid') row[key]=!!val;
  else if(key==='com') {
    // Для комиссии: если значение пустое, сохраняем как пустую строку
    row[key] = val === '' ? '' : val;
  } else row[key]=val;
  LS.save('cf_partnerRows',partnerRows);
  renderPartners();
  
  // Обновляем текст партнерской сделки при изменении данных
  if (['sum', 'buy', 'com'].includes(key)) {
    setTimeout(() => {
      updatePartnerText(i);
    }, 100);
  }
  // Корректировка баланса при изменении суммы/цен у партнёров: списываем разницу сумм покупки
  try{
    if (['sum','buy','sell'].includes(key)){
      // Рассчитываем текущее значение суммы покупки
      const newSum = Math.round(parseFloat(row.sum)||0);
      // Храним предыдущую сумму покупки в строке, чтобы посчитать дельту
      row._prevSumBuy = row._prevSumBuy || 0;
      const prevSum = Math.round(parseFloat(row._prevSumBuy)||0);
      const diff = newSum - prevSum;
      
      if (diff !== 0){
        // Проверяем, достаточно ли денег для увеличения суммы покупки
        if (diff > 0) {
          const stb = getMoveState();
          const balNow = Math.round(stb.balance||0);
          if (balNow < diff) {
            // Показываем диалог подтверждения
            if (confirm(`Не хватает денег. Все равно купить?\n\nТребуется: ${fmtPretty(diff,0)}$\nДоступно: ${fmtPretty(balNow,0)}$\nНедостает: ${fmtPretty(diff - balNow,0)}$`)) {
              // Пользователь подтвердил - продолжаем
            } else {
              // Пользователь отменил - откатываем изменение
              row.sum = row._prevSumBuy;
              LS.save('cf_partnerRows', partnerRows);
              renderPartners();
              return;
            }
          }
        }
        
        // Корректируем баланс на разницу сумм покупки
        const stb = getMoveState();
        stb.balance = Math.round((stb.balance||0) - diff);
        setMoveState(stb);
        updateTopBalance();
        
        // Проверяем, стал ли баланс отрицательным
        if (stb.balance < 0) {
          showToast('Баланс отрицательный', 2000);
        }
        
        addHistory('Баланс', `${diff>0?'Партнёры — покупка':'Партнёры — уменьшение суммы'}: ${diff>0?'-':'+'}${fmtPretty(Math.abs(diff),0)}$ (${row.symbol||''})`);
        try{ addTurnEventForCurrentTurn(-diff, diff>0?`Партнёры — покупка ${row.symbol||''}`:`Партнёры — уменьшение суммы ${row.symbol||''}`); }catch{}
        try{ renderTurnsHistory(); }catch{}
        
        // Если есть выплата, пересчитываем её пропорционально изменению суммы
        if (row.paidAmount && row.paidAmount > 0) {
          const sum = parseFloat(row.sum)||0, buy=parseFloat(row.buy)||0, sell=parseFloat(row.sell)||0;
          const com = row.com!==undefined&&row.com!==''?parseFloat(row.com):20;
          const effFactor = Array.isArray(row.factors) ? row.factors.reduce((a,b)=>a*(parseFloat(b)||1),1) : 1;
          const qty = (buy>0) ? (sum/buy) * effFactor : 0;
          const sumSell = qty*sell;
          const newMaxAmount = sumSell*(1 - com/100);
          
          // Рассчитываем старую максимальную выплату на основе предыдущей суммы
          const oldSum = parseFloat(row._prevSumBuy)||0;
          const oldQty = (buy>0) ? (oldSum/buy) * effFactor : 0;
          const oldSumSell = oldQty*sell;
          const oldMaxAmount = oldSumSell*(1 - com/100);
          
          // Если старая максимальная выплата была больше 0, пересчитываем текущую выплату пропорционально
          if (oldMaxAmount > 0) {
            const oldPaidAmount = row.paidAmount;
            // Пропорционально пересчитываем выплату
            const ratio = newMaxAmount / oldMaxAmount;
            row.paidAmount = Math.round(oldPaidAmount * ratio);
            
            // Корректируем баланс на разницу выплат
            const paidDiff = row.paidAmount - oldPaidAmount;
            if (Math.abs(paidDiff) > 0.01) {
              stb.balance = Math.round((stb.balance||0) + paidDiff);
              setMoveState(stb);
              updateTopBalance();
              
              addHistory('Баланс', `Партнёр — пересчет выплаты: ${paidDiff>0?'+':''}${fmtPretty(paidDiff,0)}$ (${row.symbol||''})`);
              try{ addTurnEventForCurrentTurn(paidDiff, `Партнёр — пересчет выплаты ${row.symbol||''}`); }catch{}
              try{ renderTurnsHistory(); }catch{}
            }
            
            showToast(`Выплата пересчитана: ${fmtPretty(Math.round(row.paidAmount), 0)}$ (было ${fmtPretty(Math.round(oldPaidAmount), 0)}$)`);
            // Принудительно обновляем отображение таблицы
            renderPartners();
          } else if (row.paidAmount > newMaxAmount) {
            // Если старая максимальная выплата была 0, но текущая выплата больше нового максимума
            const oldPaidAmount = row.paidAmount;
            row.paidAmount = Math.round(newMaxAmount);
            
            // Корректируем баланс на разницу выплат
            const paidDiff = row.paidAmount - oldPaidAmount;
            if (Math.abs(paidDiff) > 0.01) {
              stb.balance = Math.round((stb.balance||0) + paidDiff);
              setMoveState(stb);
              updateTopBalance();
              
              addHistory('Баланс', `Партнёр — корректировка выплаты: ${paidDiff>0?'+':''}${fmtPretty(paidDiff,0)}$ (${row.symbol||''})`);
              try{ addTurnEventForCurrentTurn(paidDiff, `Партнёр — корректировка выплаты ${row.symbol||''}`); }catch{}
              try{ renderTurnsHistory(); }catch{}
            }
            
            showToast(`Максимальная сумма выплаты обновлена: ${fmtPretty(Math.round(newMaxAmount), 0)}$`);
            // Принудительно обновляем отображение таблицы
            renderPartners();
          }
          
          // Обновляем _prevPaidAmount
          row._prevPaidAmount = row.paidAmount;
        }
        
        row._prevSumBuy = newSum;
        LS.save('cf_partnerRows', partnerRows);
      }
    }
  }catch{}
                // Обработка галочки "выплачено" - только заполнение поля максимальной суммой
        try{
          if (key==='paid') {
            // Если отмечаем как выплаченное, автоматически заполняем сумму выплаты максимальной
            if (val && !prevPaid) {
              const sum = parseFloat(row.sum)||0, buy=parseFloat(row.buy)||0, sell=parseFloat(row.sell)||0;
              const com = row.com!==undefined&&row.com!==''?parseFloat(row.com):20;
              const effFactor = Array.isArray(row.factors) ? row.factors.reduce((a,b)=>a*(parseFloat(b)||1),1) : 1;
              const qty = (buy>0) ? (sum/buy) * effFactor : 0;
              const sumSell = qty*sell;
              const net = sumSell*(1 - com/100);
              if (!isNaN(net) && isFinite(net)) {
                const newAmount = Math.round(net);
                const oldAmount = parseFloat(row._prevPaidAmount || 0);
                
                // Устанавливаем новую сумму выплаты
                row.paidAmount = newAmount;
                
                // Инициализируем _prevPaidAmount если его нет
                if (!row._prevPaidAmount) {
                  row._prevPaidAmount = 0;
                }
                
                // Корректируем баланс на разницу сумм
                if (Math.abs(newAmount - oldAmount) > 0.01) {
                  const delta = newAmount - oldAmount;
                  const st = getMoveState();
                  // Если увеличиваем выплату - баланс увеличивается (деньги возвращаются к владельцу)
                  st.balance = Math.round((st.balance||0) + delta);
                  setMoveState(st);
                  updateTopBalance();
                  
                  // Проверяем, стал ли баланс отрицательным
                  if (st.balance < 0) {
                    showToast('Баланс отрицательный', 2000);
                  }
                  
                  addHistory('Баланс', `Партнёр — увеличение выплаты: +${fmtPretty(delta,0)}$ (${row.symbol||''})`);
                  try{ addTurnEventForCurrentTurn(delta, `Партнёр — увеличение выплаты ${row.symbol||''}`); }catch{}
                  try{ renderTurnsHistory(); }catch{}
                }
                
                // Сохраняем предыдущее значение для следующего сравнения
                row._prevPaidAmount = newAmount;
                
                // Принудительно обновляем отображение таблицы
                renderPartners();
              }
            }
            
            // При снятии галочки НЕ изменяем баланс - он изменяется только от поля "выплачено"
          }
        }catch{}
        // Корректируем баланс при изменении суммы выплаты
        try{
          if (key==='paidAmount') {
            const newAmount = parseFloat(val) || 0;
            const oldAmount = parseFloat(row._prevPaidAmount || 0);
            
            // Проверяем, что сумма выплаты не превышает максимально возможную
            const sum = parseFloat(row.sum)||0, buy=parseFloat(row.buy)||0, sell=parseFloat(row.sell)||0;
            const com = row.com!==undefined&&row.com!==''?parseFloat(row.com):20;
            const effFactor = Array.isArray(row.factors) ? row.factors.reduce((a,b)=>a*(parseFloat(b)||1),1) : 1;
            const qty = (buy>0) ? (sum/buy) * effFactor : 0;
            const sumSell = qty*sell;
            const maxAmount = sumSell*(1 - com/100);
            
            // Определяем фактическую сумму, которая будет установлена
            let actualAmount = newAmount;
            if (newAmount > maxAmount) {
              actualAmount = Math.round(maxAmount);
              row.paidAmount = actualAmount;
              showToast(`Максимальная сумма выплаты: ${fmtPretty(Math.round(maxAmount), 0)}$`);
              // Принудительно обновляем отображение таблицы
              renderPartners();
            }
            
            // Корректируем баланс на разницу сумм (всегда, независимо от галочки)
            if (Math.abs(actualAmount - oldAmount) > 0.01) {
              const delta = actualAmount - oldAmount;
              const st = getMoveState();
              // Если увеличиваем выплату - баланс увеличивается (деньги возвращаются к владельцу)
              // Если уменьшаем выплату - баланс уменьшается (деньги уходят от владельца)
              st.balance = Math.round((st.balance||0) + delta);
              setMoveState(st);
              updateTopBalance();
              
              // Проверяем, стал ли баланс отрицательным
              if (st.balance < 0) {
                showToast('Баланс отрицательный', 2000);
              }
              
              addHistory('Баланс', `${delta>0?'Партнёр — увеличение выплаты':'Партнёр — уменьшение выплаты'}: ${delta>0?'+':'-'}${fmtPretty(Math.abs(delta),0)}$ (${row.symbol||''})`);
              try{ addTurnEventForCurrentTurn(delta, delta>0?`Партнёр — увеличение выплаты ${row.symbol||''}`:`Партнёр — уменьшение выплаты ${row.symbol||''}`); }catch{}
              try{ renderTurnsHistory(); }catch{}
            }
            
            // Сохраняем предыдущее значение для следующего сравнения
            row._prevPaidAmount = actualAmount;
          }
        }catch{}
        
        // Инициализируем _prevPaidAmount для новых строк
        if (key === 'paidAmount' && !row._prevPaidAmount) {
          row._prevPaidAmount = parseFloat(val) || 0;
        }
        
        // Инициализируем _prevSumBuy для новых строк
        if (key === 'sum' && !row._prevSumBuy) {
          row._prevSumBuy = parseFloat(val) || 0;
        }
}
function addPartnerRow(){
  const newRow = {id:Date.now()+Math.random(),symbol:'',qty:'',buy:'',sell:'',com:20,paid:false,paidAmount:0,_prevPaidAmount:0,_prevSumBuy:0};
  partnerRows.push(newRow);
  LS.save('cf_partnerRows',partnerRows);
  
  // Если у новой сделки есть сумма покупки, списываем её с баланса
  if (newRow.sum && parseFloat(newRow.sum) > 0) {
    try {
      const sum = Math.round(parseFloat(newRow.sum)||0);
      const st = getMoveState();
      const balNow = Math.round(st.balance||0);
      
      // Проверяем, достаточно ли денег
      if (balNow < sum) {
        // Показываем диалог подтверждения
        if (confirm(`Не хватает денег. Все равно купить?\n\nТребуется: ${fmtPretty(sum,0)}$\nДоступно: ${fmtPretty(balNow,0)}$\nНедостает: ${fmtPretty(sum - balNow,0)}$`)) {
          // Пользователь подтвердил - продолжаем
        } else {
          // Пользователь отменил - удаляем строку
          partnerRows.pop();
          LS.save('cf_partnerRows',partnerRows);
          renderPartners();
          return;
        }
      }
      
      st.balance = Math.round((st.balance||0) - sum);
      setMoveState(st);
      updateTopBalance();
      
      // Проверяем, стал ли баланс отрицательным
      if (st.balance < 0) {
        showToast('Баланс отрицательный', 2000);
      }
      
      addHistory('Баланс', `Партнёры — покупка: -${fmtPretty(sum,0)}$ (${newRow.symbol||'Новая сделка'})`);
      try{ addTurnEventForCurrentTurn(-sum, `Партнёры — покупка (${newRow.symbol||'Новая сделка'})`); }catch{}
      try{ renderTurnsHistory(); }catch{}
    } catch(e) {
      console.warn('Ошибка при изменении баланса в addPartnerRow:', e);
    }
  }
  
  renderPartners();
}
function delPartner(i){
  if(!partnerRows[i]) return;
  
  const row = partnerRows[i];
  const sum = parseFloat(row.sum)||0;
  
  // Если у удаляемой сделки есть сумма покупки, возвращаем её на баланс
  if (sum > 0) {
    try {
      const st = getMoveState();
      st.balance = Math.round((st.balance||0) + sum);
      setMoveState(st);
      updateTopBalance();
      addHistory('Баланс', `Партнёры — возврат: +${fmtPretty(sum,0)}$ (${row.symbol||'Удалённая сделка'})`);
      try{ addTurnEventForCurrentTurn(sum, `Партнёры — возврат (${row.symbol||'Удалённая сделка'})`); }catch{}
      try{ renderTurnsHistory(); }catch{}
    } catch(e) {
      console.warn('Ошибка при изменении баланса в delPartner:', e);
    }
  }
  
  partnerRows.splice(i,1);
  LS.save('cf_partnerRows',partnerRows);
  renderPartners();
}

// Изменение количества (через сумму) в партнерских сделках по коэффициенту
function adjustPartnerQtyPrompt(i){
  openFactorModal({
    title: 'Изменить количество (коэффициент)',
    onSubmit: (factor)=>{ adjustPartnerQty(i, factor); }
  });
}
function adjustPartnerQty(i, factor){
  if(!partnerRows[i]){ showToast('Строка не найдена'); return; }
  pushUndo();
  const row = partnerRows[i];
  
  // Рассчитываем предыдущую и новую сумму продажи для корректировки баланса
  const sum = parseFloat(row.sum)||0;
  const buy = parseFloat(row.buy)||0;
  const sell = parseFloat(row.sell)||0;
  const com = row.com!==undefined&&row.com!==''?parseFloat(row.com):20;
  
  // Предыдущее количество и сумма продажи
  const prevFactors = Array.isArray(row.factors) ? row.factors : [];
  const prevEffFactor = prevFactors.length ? prevFactors.reduce((a,b)=>a*(parseFloat(b)||1),1) : 1;
  const prevQty = (buy>0) ? (sum/buy) * prevEffFactor : 0;
  const prevSumSell = prevQty * sell;
  const prevNet = prevSumSell * (1 - com/100);
  
  // Сумму покупки НЕ меняем, меняем только виртуальный множитель количества
  if (!Array.isArray(row.factors)) row.factors = [];
  row.factors.push(factor);
  row.factors = row.factors.slice(-4);
  
  // Новое количество и сумма продажи
  const newEffFactor = row.factors.reduce((a,b)=>a*(parseFloat(b)||1),1);
  const newQty = (buy>0) ? (sum/buy) * newEffFactor : 0;
  const newSumSell = newQty * sell;
  const newNet = newSumSell * (1 - com/100);
  
  // Корректируем баланс на разницу в чистой прибыли
  if (sell > 0 && buy > 0) {
    try {
      const delta = newNet - prevNet;
      if (Math.abs(delta) > 0.01) { // учитываем погрешность округления
        // Проверяем, достаточно ли денег для убытка
        if (delta < 0) {
          const st = getMoveState();
          const balNow = Math.round(st.balance||0);
          const absDelta = Math.abs(delta);
          if (balNow < absDelta) {
            // Показываем диалог подтверждения
            if (confirm(`Не хватает денег. Все равно применить убыток?\n\nТребуется: ${fmtPretty(absDelta,0)}$\nДоступно: ${fmtPretty(balNow,0)}$\nНедостает: ${fmtPretty(absDelta - balNow,0)}$`)) {
              // Пользователь подтвердил - продолжаем
            } else {
              // Пользователь отменил - откатываем изменение
              row.factors.pop();
              LS.save('cf_partnerRows', partnerRows);
              renderPartners();
              return;
            }
          }
        }
        
        const st = getMoveState();
        st.balance = Math.round((st.balance||0) + delta);
        setMoveState(st);
        updateTopBalance();
        
        // Проверяем, стал ли баланс отрицательным
        if (st.balance < 0) {
          showToast('Баланс отрицательный', 2000);
        }
        
        const label = `${row.symbol||'Сделка'}`;
        if (delta > 0) {
          addHistory('Баланс', `Партнёры — прибыль: +${fmtPretty(delta,0)}$ (${label})`);
          try{ addTurnEventForCurrentTurn(delta, `Партнёры — прибыль (${label})`); }catch{}
        } else {
          addHistory('Баланс', `Партнёры — убыток: ${fmtPretty(delta,0)}$ (${label})`);
          try{ addTurnEventForCurrentTurn(delta, `Партнёры — убыток (${label})`); }catch{}
        }
        try{ renderTurnsHistory(); }catch{}
      }
    } catch(e) {
      console.warn('Ошибка при изменении баланса в adjustPartnerQty:', e);
    }
  }
  
  LS.save('cf_partnerRows', partnerRows);
  addHistory('Партнеры', `${row.symbol||'Сделка'}: × <b>${factor}</b>`);
  renderPartners();
  showToast('Количество изменено');
}
['#partnerQty','#partnerBuy','#partnerSell','#partnerCom'].forEach(id=>{
  document.addEventListener('input',e=>{if(e.target&&e.target.matches(id))renderPartners();});
});
// Добавить обработчики для калькулятора КПД
function updateKPD(){
  const baseTotals = (typeof computeTotals==='function') ? computeTotals() : {totalExpense:0};
  document.querySelectorAll('.kpdBlock').forEach(block=>{
    let totalInvest = 0;
    let totalPassive = 0;
    let anyChecked = false;
    const rowEls = Array.from(block.querySelectorAll('.kpdRows .row'));
    rowEls.forEach((row)=>{
      const investInput = row.querySelector('.kpdInvest');
      const passiveInput = row.querySelector('.kpdPassive');
      const resultSpan = row.querySelector('.kpdResult');
      const check = row.querySelector('.kpdCheck');
      if (investInput && passiveInput && resultSpan){
        const invest = parseFloat(investInput.value) || 0;
        const passive = parseFloat(passiveInput.value) || 0;
        // Формируем многострочный вывод
        const lines = [];
        if (invest > 0) {
          const kpdVal = (passive / invest * 100);
          const kpdStr = kpdVal.toFixed(2);
          let color = '#444'; // по умолчанию серый
          if (kpdVal < 1) color = '#c33'; // красный для < 1%
          else if (kpdVal >= 2 && kpdVal < 3) color = '#080'; // зеленый для 2-3
          else if (kpdVal >= 3) color = '#0066cc'; // синий для >= 3
          lines.push(`<span style="color:${color}">КПД: ${kpdStr}%</span>`);
        }
        if (baseTotals && baseTotals.totalExpense>0 && passive>0) {
          const delta = passive / baseTotals.totalExpense;
          lines.push(`КПК: +${delta.toFixed(3)}`);
          if (invest > 0) {
            const effPct = (delta / invest) * EFKPK_SCALE * 100;
            const color = (effPct >= 2 && effPct <= 3) ? '#080' : '#444';
            lines.push(`<span style="color:${color}">ЭфКПК: +${(effPct*10).toFixed(2)}%</span>`);
          }
        }
        resultSpan.innerHTML = lines.join('<br>');
        // Сохраняем eff на контейнере
        const effEl = resultSpan.querySelector('span[style*="ЭфКПК"]') || null;
        const effMatch = /ЭфКПК: \+([0-9.]+)%/.exec(resultSpan.textContent||'');
        const effVal = effMatch ? parseFloat(effMatch[1]) : NaN;
        resultSpan.dataset.eff = isNaN(effVal)? '' : String(effVal);
        if (check && check.checked) { totalInvest += invest; totalPassive += passive; anyChecked = true; }
      }
    });
    const totalKpdElement = block.querySelector('.kpdTotal');
    if (!totalKpdElement) return;
      if (anyChecked && totalInvest > 0) {
      const percent = (totalPassive / totalInvest * 100).toFixed(2);
      const inv = fmtPretty(totalInvest, 0);
      const pas = fmtPretty(totalPassive, 0);
      const deltaTotal = (baseTotals && baseTotals.totalExpense>0) ? (totalPassive / baseTotals.totalExpense) : 0;
      const lines = [];
      let colorKpd = '#444'; // по умолчанию серый
      const kpdNum = parseFloat(percent)||0;
      if (kpdNum < 1) colorKpd = '#c33'; // красный для < 1%
      else if (kpdNum >= 2 && kpdNum < 3) colorKpd = '#080'; // зеленый для 2-3
      else if (kpdNum >= 3) colorKpd = '#0066cc'; // синий для >= 3
      lines.push(`<span style="color:${colorKpd}">КПД: ${percent}%</span>`);
      lines.push(`КПК: +${deltaTotal.toFixed(3)}`);
      if (totalInvest>0) {
          const eff = (((deltaTotal)/(totalInvest))*EFKPK_SCALE*100);
        const colorEff = (eff >= 2 && eff <= 3) ? '#080' : '#444';
          lines.push(`<span style=\"color:${colorEff}\">ЭфКПК: +${(eff*10).toFixed(2)}%</span>`);
      }
      totalKpdElement.innerHTML = `Общий<br>${lines.join('<br>')}<br>(Расход: ${inv}, Пассив: ${pas})`;
      
      // Записываем в историю ходов расчет КПД
      try{ addTurnEventForCurrentTurn(0, `КПД: ${percent}% (${inv} → ${pas})`); }catch{}
      try{ renderTurnsHistory(); }catch{}
    } else {
      const inv = fmtPretty(totalInvest, 0);
      const pas = fmtPretty(totalPassive, 0);
      const percent = (totalInvest>0) ? (totalPassive/totalInvest*100).toFixed(2)+'%' : '';
      const deltaTotal = (baseTotals && baseTotals.totalExpense>0) ? (totalPassive / baseTotals.totalExpense) : 0;
      if (totalInvest>0 || totalPassive>0) {
        const lines = [];
        const kpdNum = parseFloat(percent)||0;
        let colorKpd = '#444'; // по умолчанию серый
        if (kpdNum < 1) colorKpd = '#c33'; // красный для < 1%
        else if (kpdNum >= 2 && kpdNum < 3) colorKpd = '#080'; // зеленый для 2-3
        else if (kpdNum >= 3) colorKpd = '#0066cc'; // синий для >= 3
        lines.push(`<span style="color:${colorKpd}">КПД: ${percent || '0.00%'} </span>`);
        lines.push(`КПК: +${(totalPassive>0?deltaTotal:0).toFixed(3)}`);
        if (totalInvest>0) {
          const eff = (((deltaTotal)/(totalInvest))*EFKPK_SCALE*100);
          const colorEff = (eff >= 2 && eff <= 3) ? '#080' : '#444';
          lines.push(`<span style=\"color:${colorEff}\">ЭфКПК: +${(eff*10).toFixed(2)}%</span>`);
        }
        totalKpdElement.innerHTML = `Общий<br>${lines.join('<br>')}<br>(Расход: ${inv||'0'}, Пассив: ${pas||'0'})`;
        
        // Записываем в историю ходов расчет КПД
        try{ addTurnEventForCurrentTurn(0, `КПД: ${percent}% (${inv} → ${pas})`); }catch{}
        try{ renderTurnsHistory(); }catch{}
      } else {
        totalKpdElement.innerHTML = '';
      }
    }
    // Подсветим лучший ЭфКПК среди строк (если есть хотя бы одно значение)
    try{
      let best = -Infinity;
      const effSpans = Array.from(block.querySelectorAll('.kpdResult .effVal'));
      effSpans.forEach(sp=>{ const v=parseFloat(sp.getAttribute('data-eff')||''); if(!isNaN(v)) best = Math.max(best, v); });
      if (best > -Infinity) {
        effSpans.forEach(sp=>{
          const v = parseFloat(sp.getAttribute('data-eff')||'');
          const inRange = v>=2 && v<=3;
          sp.style.color = inRange ? '#080' : '#444';
          sp.style.fontWeight = (!isNaN(v) && Math.abs(v - best) < 1e-9) ? '700' : (inRange ? '600' : 'normal');
        });
      }
    } catch{}
  });
}
// Обработчики для КПД будут добавляться в renderBuy()
// 2. Сохраняем значения полей "Купить" в localStorage
function saveBuyTempFields(){
  const temp = {
    symbol: $('#buySymbol').value,
    price: $('#buyPrice').value,
    by: {}
  };
  document.querySelectorAll('.buySum').forEach(inp=>{
    temp.by[inp.dataset.p] = inp.value;
  });
  localStorage.setItem('cf_buyTemp', JSON.stringify(temp));
}
function loadBuyTempFields(){
  const temp = JSON.parse(localStorage.getItem('cf_buyTemp')||'{}');
  if(temp.symbol!==undefined) $('#buySymbol').value = temp.symbol;
  if(temp.price!==undefined) $('#buyPrice').value = temp.price;
  if(temp.by) {
    document.querySelectorAll('.buySum').forEach(inp=>{
      if(temp.by[inp.dataset.p]!==undefined) inp.value = temp.by[inp.dataset.p];
    });
  }
}
// 3. Кнопка очистить поля
function clearBuyFields(){
  $('#buySymbol').value = '';
  $('#buyPrice').value = '';
  document.querySelectorAll('.buySum').forEach(inp=>inp.value='');
  localStorage.removeItem('cf_buyTemp');
  updateBuyCalc();
  
  // Записываем в историю ходов очистку полей покупки
  try{ addTurnEventForCurrentTurn(0, 'Очистка полей покупки'); }catch{}
  try{ renderTurnsHistory(); }catch{}
  
  // Обновляем заголовки после очистки полей
  updateBuyHeaders();
}
// Очистить Легкую покупку
function clearEasyBuy(){
  try{
    const sumEl = document.getElementById('easySum');
    const priceEl = document.getElementById('easyPrice');
    const mySumEl = document.getElementById('easyMySum');
    const commissionEl = document.getElementById('easyCommission');
    if(sumEl) sumEl.value = '';
    if(priceEl) priceEl.value = '';
    if(mySumEl) mySumEl.value = '';
    if(commissionEl) commissionEl.value = '0';
    const topEl = document.getElementById('easySummaryTop');
    if (topEl) topEl.innerHTML = '';
    
    // Обнуляем капитал при очистке
    try {
      const st = getMoveState();
      st.balance = 0;
      setMoveState(st);
      updateTopBalance();
      addHistory('Баланс', 'Очистка: баланс обнулен');
    } catch {}
    
    // Записываем в историю ходов очистку легкой покупки
    try{ addTurnEventForCurrentTurn(0, 'Очистка легкой покупки'); }catch{}
    try{ renderTurnsHistory(); }catch{}
    
    // Обновляем заголовки после очистки легкой покупки
    try { updateBuyHeaders(); } catch {}
  }catch{}
}
// 4. Делаем чекбокс крупнее и строку реально зачеркиваем
// В CSS (добавить в <style>):
/*
.paid td, tr.paid td {
  text-decoration: line-through;
  color: #aaa;
}
.paidChkSell {
  width: 28px;
  height: 28px;
  accent-color: #4a90e2;
  transform: scale(1.3);
}
*/
// Сохраняем поля при изменении и сразу пересчитываем
// Обработчики для полей покупки
['#buySymbol','#buyPrice'].forEach(id=>{
  const el = document.querySelector(id);
  if (!el) return;
  el.addEventListener('input',()=>{ saveBuyTempFields(); updateBuyCalc(); });
  el.addEventListener('change',()=>{ saveBuyTempFields(); updateBuyCalc(); });
});
// Отдельно: тумблер авто ×1000 — только событие change (чтобы не дублировать подтверждение)
(function(){
  const el = document.getElementById('buyAuto000');
  if (!el) return;
  el.addEventListener('change', ()=>{
    if (el.checked) {
      if (!confirm('Теперь вы будете вводить в поле "Суммы" количество тысяч, подтвердить?')) { el.checked = false; return; }
    } else {
      if (!confirm('Отменить авто ×1000?')) { el.checked = true; return; }
    }
    updateBuyHeaders();
    saveBuyTempFields();
    updateBuyCalc();
  });
})();

function updateBuyHeaders(){
  try{
    const auto = document.getElementById('buyAuto000')?.checked;
    const tbl = document.getElementById('buyTable');
    if(!tbl) return;
    const ths = tbl.querySelectorAll('tr:first-child th');
    if(ths && ths.length>=2){
      ths[1].textContent = auto ? 'Сумма (тысяч)' : 'Сумма';
    }
    
    // Добавляем информацию о следующем номере покупки в заголовок
    if(ths && ths.length>=1){
      // Находим следующий номер покупки
      let nextBuyNumber = 1;
      try {
        const existingNumbers = new Set();
        Object.values(holdings).forEach(ph => {
          Object.keys(ph).forEach(s => {
            const turnInfo = LS.load('cf_buyTurnBySymbol', {})[s] || '';
            const match = turnInfo.match(/№(\d+)/);
            if (match) {
              existingNumbers.add(parseInt(match[1]));
            }
          });
        });
        
        while (existingNumbers.has(nextBuyNumber)) {
          nextBuyNumber++;
        }
      } catch {}
      
      // Получаем текущий ход
      const currentTurn = parseInt(localStorage.getItem('cf_turn_number')||'1',10)||1;
      const turnLabel = document.getElementById('buyTurnInput')?.value?.trim() || `Ход ${currentTurn}`;
      
      // Обновляем заголовок таблицы
      ths[0].innerHTML = `Участник <span style="color:#666;font-size:12px;font-weight:normal">(№${nextBuyNumber}, ${turnLabel})</span>`;
    }
  }catch{}
}
document.addEventListener('input',e=>{
  if(e.target && e.target.classList.contains('buySum')) saveBuyTempFields();
});
// Сохраняем значения цен продажи для каждой акции в localStorage
function saveSellPrices(){
  let prices = {};
  document.querySelectorAll('.sellPriceForSymbol').forEach(inp=>{
    prices[inp.dataset.sym] = inp.value;
  });
  localStorage.setItem('cf_sellPrices', JSON.stringify(prices));
}
function loadSellPrices(){
  return JSON.parse(localStorage.getItem('cf_sellPrices')||'{}');
}
  function updateSellTotalSum(sym){
    try{
      const priceInput = document.querySelector(`.sellPriceForSymbol[data-sym='${sym}']`);
      const price = priceInput ? parseFloat(priceInput.value)||0 : 0;
      // Посчитаем totalQty (сумма qty по всем участникам)
      let totalQty = 0;
      (participants||[]).forEach(p=>{
        const h = (holdings[p] && holdings[p][sym]) ? holdings[p][sym] : null;
        if(h && h.qty>0) totalQty += h.qty;
      });
      const sum = (price>0 && totalQty>0) ? Math.round(totalQty * price) : 0;
      const label = document.querySelector(`.sellTotalSum[data-sym='${sym}']`);
      if(label) label.textContent = sum ? fmtPretty(sum, 0) : '';
    }catch{}
  }
  // Инициализация списка партнёров для блока "Деньги партнёру"
  setTimeout(()=>{
    try{
      const sel = document.getElementById('partnerPayName');
      if (sel){
        const uniq = new Set(participants||[]);
        uniq.add('Банк');
        sel.innerHTML = '<option value="">— выбрать —</option>' + Array.from(uniq).map(n=>`<option value="${n}">${n}</option>`).join('');
      }
    }catch{}
  }, 0);
  function givePartnerMoney(){
  try{
    const name = (document.getElementById('partnerPayName')?.value||'').trim();
    const sum = Math.round(parseFloat(document.getElementById('partnerPaySum')?.value||'0'))||0;
    if (sum<=0){ showToast('Укажите сумму'); return; }
    
    // Проверяем, достаточно ли денег
    const st = getMoveState();
    const balNow = Math.round(st.balance||0);
    if (balNow < sum) {
      // Показываем диалог подтверждения
      if (confirm(`Не хватает денег. Все равно отдать?\n\nТребуется: ${fmtPretty(sum,0)}$\nДоступно: ${fmtPretty(balNow,0)}$\nНедостает: ${fmtPretty(sum - balNow,0)}$`)) {
        // Пользователь подтвердил - продолжаем
      } else {
        // Пользователь отменил
        return;
      }
    }
    
    applyBalanceDelta(-sum, `Деньги партнёру${name?` — ${name}`:''}`);
    try{ document.getElementById('partnerPaySum').value=''; }catch{}
    showToast(`-${fmtPretty(sum,0)} $`, 1000);
  }catch{}
}
function delBuySymbolTpl(i){
  buySymbolTpls.splice(i,1);
  LS.save('cf_buySymbolTpls',buySymbolTpls);
  renderBuyTemplates();
}
function delBuyPriceTpl(i){
  buyPriceTpls.splice(i,1);
  LS.save('cf_buyPriceTpls',buyPriceTpls);
  renderBuyTemplates();
}
function delSellSymbolTpl(i){
  sellSymbolTpls.splice(i,1);
  LS.save('cf_sellSymbolTpls',sellSymbolTpls);
  renderSellTemplates();
}
function delSellPriceTpl(i){
  sellPriceTpls.splice(i,1);
  LS.save('cf_sellPriceTpls',sellPriceTpls);
  renderSellTemplates();
}
// Легкая покупка: расчет количества акций
function updateEasyBuy() {
  const sum = parseFloat(document.getElementById('easySum').value) || 0;
  const price = parseFloat(document.getElementById('easyPrice').value) || 0;
  let top = '';
  if (sum > 0 && price > 0) {
    const qtyInt = Math.floor(sum / price); // целое число акций
    // Верхнее резюме
    const owner = (localStorage.getItem('cf_owner') || (participants[0]||'') || '').trim();
    const mySum = parseFloat(document.getElementById('easyMySum').value) || 0;
    const commission = parseFloat(document.getElementById('easyCommission').value) || 0;
    
    let myQty = 0;
    if (mySum > 0 && price > 0) {
      // Учитываем комиссию: если комиссия > 0, то мои акции = (моя сумма * (1 - комиссия/100)) / цена
      if (commission > 0) {
        const mySumAfterCommission = mySum * (1 - commission / 100);
        myQty = Math.floor(mySumAfterCommission / price);
      } else {
        myQty = Math.floor(mySum / price);
      }
    }
    
    let line2 = '';
    if (myQty > 0 && owner) {
      line2 = `<br>Из них <b>${fmtPretty(myQty,0)}</b> акций на счет <b>${escapeHtml(owner)}</b>`;
      if (commission > 0) {
        line2 += `<br><br><span style="font-size:14px;color:#666;">(Комиссия ${commission}% учтена)</span>`;
      }
    }
    top = `Покупаем <b>${fmtPretty(qtyInt,0)}</b> акций за <b>${fmtPretty(sum,0)}$</b>${line2}`;
  } else {
    top = '';
  }
  const topEl = document.getElementById('easySummaryTop');
  if (topEl) topEl.innerHTML = top;
  const bottomEl = document.getElementById('easySummaryBottom');
  if (bottomEl) {
    if (sum > 0 && price > 0) {
      const qtyInt = Math.floor(sum / price);
      const owner = (localStorage.getItem('cf_owner') || (participants[0]||'') || '').trim();
      const mySum = parseFloat(document.getElementById('easyMySum').value) || 0;
      const myQty = (mySum > 0 && price > 0) ? Math.floor(mySum / price) : 0;
      const line2 = (myQty > 0 && owner)
        ? `<div style="margin-top:8px">Из них <b>${fmtPretty(myQty,0)}</b> акций на счет <b>${escapeHtml(owner)}</b></div>`
        : '';
      bottomEl.innerHTML = `<div style="margin-bottom:8px;color:#444;">Нужно сказать банку:</div>`+
        `<div style="border:2px solid #4a90e2;border-radius:8px;padding:12px;background:#fff">`+
        `<div>Покупаем <b>${fmtPretty(qtyInt,0)}</b> акций за <b>${fmtPretty(sum,0)}$</b></div>`+
        `${line2}`+
        `</div>`;
    } else {
      bottomEl.innerHTML = '';
    }
  }
  
  // Обновляем расчет моих акций
  updateEasyBuyMy();
  
  // Обновляем заголовки при изменении легкой покупки
  updateBuyHeaders();
}

// Легкая покупка: расчет моих акций
function updateEasyBuyMy() {
  const sum = parseFloat(document.getElementById('easySum').value) || 0;
  const price = parseFloat(document.getElementById('easyPrice').value) || 0;
  const mySum = parseFloat(document.getElementById('easyMySum').value) || 0;
  const commission = parseFloat(document.getElementById('easyCommission').value) || 0;
  
  // Проверка: моя сумма не может быть больше общей суммы
  if (mySum > sum && sum > 0) {
    document.getElementById('easyMySum').value = sum;
    showToast('Моя сумма не может быть больше общей суммы');
    // Пересчитываем после изменения значения (без вывода отдельной метки)
    return;
  }
  
  let myShares = 0;
  if (mySum > 0 && price > 0) {
    // Учитываем комиссию: если комиссия > 0, то мои акции = (моя сумма * (1 - комиссия/100)) / цена
    if (commission > 0) {
      const mySumAfterCommission = mySum * (1 - commission / 100);
      myShares = Math.floor(mySumAfterCommission / price);
    } else {
      myShares = Math.floor(mySum / price);
    }
  }
  
  // Убрали вывод "Мои акции: N" как дублирующий
  // Обновляем верхнее резюме (вторая строка появляется только если есть mySum)
  try {
    const owner = (localStorage.getItem('cf_owner') || (participants[0]||'') || '').trim();
    const qtyInt = (sum > 0 && price > 0) ? Math.floor(sum / price) : 0;
    const topEl = document.getElementById('easySummaryTop');
    const bottomEl = document.getElementById('easySummaryBottom');
    
    // Формируем строку с учетом комиссии
    let mySharesText = '';
    if (myShares > 0 && owner) {
      mySharesText = `<br>Из них <b>${fmtPretty(myShares,0)}</b> акций на счет <b>${escapeHtml(owner)}</b>`;
      if (commission > 0) {
        mySharesText += `<br><span style="font-size:14px;color:#666;">(Комиссия ${commission}% учтена)</span>`;
      }
    }
    
    const html = (qtyInt > 0) ? (`Покупаем <b>${fmtPretty(qtyInt,0)}</b> акций за <b>${fmtPretty(sum,0)}$</b>${mySharesText}`) : '';
    if (topEl) topEl.innerHTML = html;
    if (bottomEl) {
      if (qtyInt > 0) {
        const line2 = (myShares > 0 && owner)
          ? `<div style="margin-top:8px">Из них <b>${fmtPretty(myShares,0)}</b> акций на счет <b>${escapeHtml(owner)}</b></div>`
          : '';
        const commissionText = (commission > 0) ? `<div style="margin-top:8px;font-size:14px;color:#666;">(Комиссия ${commission}% учтена)</div>` : '';
        bottomEl.innerHTML = `<div style=\"margin-bottom:8px;color:#444;\">Нужно сказать банку:</div>`+
          `<div style=\"border:2px solid #4a90e2;border-radius:8px;padding:12px;background:#fff\">`+
          `<div>Покупаем <b>${fmtPretty(qtyInt,0)}</b> акций за <b>${fmtPretty(sum,0)}$</b></div>`+
          `${line2}`+
          `</div>`+
          `${commissionText}`;
      } else {
        bottomEl.innerHTML = '';
      }
    }
  } catch {}
  
  // Обновляем заголовки при изменении моих акций
  updateBuyHeaders();
}

function toggleEasyText(){
  try{
    const wrap = document.getElementById('easyBottomWrap');
    const btn = document.getElementById('easyToggleTextBtn');
    if (!wrap || !btn) return;
    const hidden = (wrap.style.display === 'none' || wrap.style.display === '');
    wrap.style.display = hidden ? 'block' : 'none';
    btn.textContent = hidden ? 'Скрыть текст' : 'Показать текст';
  }catch{}
}
// Функция для показа/скрытия текста в разделе "Ходы"
function toggleEasyTextMoves(){
  try{
    const wrap = document.getElementById('easyBottomWrapMoves');
    const btn = document.getElementById('easyToggleTextBtnMoves');
    if (!wrap || !btn) return;
    const hidden = (wrap.style.display === 'none' || wrap.style.display === '');
    wrap.style.display = hidden ? 'block' : 'none';
    btn.textContent = hidden ? 'Скрыть текст' : 'Показать текст';
  }catch{}
}

// Легкая покупка в разделе Ходы: расчет количества акций
function updateEasyBuyMoves() {
  const sum = parseFloat(document.getElementById('easySumMoves').value) || 0;
  const price = parseFloat(document.getElementById('easyPriceMoves').value) || 0;
  let top = '';
  if (sum > 0 && price > 0) {
    const qtyInt = Math.floor(sum / price); // целое число акций
    const owner = (localStorage.getItem('cf_owner') || (participants[0]||'') || '').trim();
    const mySum = parseFloat(document.getElementById('easyMySumMoves').value) || 0;
    const commission = parseFloat(document.getElementById('easyCommissionMoves').value) || 0;
    
    let myQty = 0;
    if (mySum > 0 && price > 0) {
      // Учитываем комиссию: если комиссия > 0, то мои акции = (моя сумма * (1 - комиссия/100)) / цена
      if (commission > 0) {
        const mySumAfterCommission = mySum * (1 - commission / 100);
        myQty = Math.floor(mySumAfterCommission / price);
      } else {
        myQty = Math.floor(mySum / price);
      }
    }
    
    let line2 = '';
    if (myQty > 0 && owner) {
      line2 = `<br>Из них <b>${fmtPretty(myQty,0)}</b> акций на счет <b>${escapeHtml(owner)}</b>`;
      if (commission > 0) {
        line2 += `<br><br><span style="font-size:14px;color:#666;">(Комиссия ${commission}% учтена)</span>`;
      }
    }
    top = `Покупаем <b>${fmtPretty(qtyInt,0)}</b> акций за <b>${fmtPretty(sum,0)}$</b>${line2}`;
  } else {
    top = '';
  }
  const topEl = document.getElementById('easySummaryTopMoves');
  if (topEl) topEl.innerHTML = top;
  
  // Записываем в историю ходов легкую покупку
  if (sum > 0 && price > 0) {
    try{ addTurnEventForCurrentTurn(0, `Легкая покупка: ${sum}$ → ${qtyInt} акций`); }catch{}
    try{ renderTurnsHistory(); }catch{}
  }
  
  // Автопрокрутка к результату, если он вне экрана
  try {
    const el = document.getElementById('easyResultMoves');
    if (!el) return;
    const rect = el.getBoundingClientRect();
    const topPad = 20; // небольшой отступ сверху
    const bottomPad = 100; // учитываем нижнюю навигацию на мобиле
    const outOfView = rect.bottom > (window.innerHeight - bottomPad) || rect.top < topPad;
    if (outOfView) {
      const target = Math.max(0, window.scrollY + rect.top - window.innerHeight * 0.5);
      window.scrollTo({ top: target, behavior: 'smooth' });
    }
  } catch {}
  
  // Обновляем расчет моих акций
  updateEasyBuyMyMoves();
  
  // Также обновляем верхнее резюме с учетом комиссии
  const mySum = parseFloat(document.getElementById('easyMySumMoves').value) || 0;
  const commission = parseFloat(document.getElementById('easyCommissionMoves').value) || 0;
  if (mySum > 0 && price > 0) {
    let myQty = 0;
    if (commission > 0) {
      const mySumAfterCommission = mySum * (1 - commission / 100);
      myQty = Math.floor(mySumAfterCommission / price);
    } else {
      myQty = Math.floor(mySum / price);
    }
    
    const owner = (localStorage.getItem('cf_owner') || (participants[0]||'') || '').trim();
    if (myQty > 0 && owner) {
      let line2 = '';
      line2 = `<br>Из них <b>${fmtPretty(myQty,0)}</b> акций на счет <b>${escapeHtml(owner)}</b>`;
      if (commission > 0) {
        line2 += `<br><br><span style="font-size:14px;color:#666;">(Комиссия ${commission}% учтена)</span>`;
      }
      
      const topEl = document.getElementById('easySummaryTopMoves');
      if (topEl) {
        const qtyInt = Math.floor(sum / price);
        topEl.innerHTML = `Покупаем <b>${fmtPretty(qtyInt,0)}</b> акций за <b>${fmtPretty(sum,0)}$</b>${line2}`;
      }
    }
  }
  
  // Обновляем заголовки при изменении легкой покупки
  try { updateBuyHeaders(); } catch {}
}

// Легкая покупка в разделе Ходы: расчет моих акций
function updateEasyBuyMyMoves() {
  const sum = parseFloat(document.getElementById('easySumMoves').value) || 0;
  const price = parseFloat(document.getElementById('easyPriceMoves').value) || 0;
  const mySum = parseFloat(document.getElementById('easyMySumMoves').value) || 0;
  const commission = parseFloat(document.getElementById('easyCommissionMoves').value) || 0;
  
  // Проверка: моя сумма не может быть больше общей суммы
  if (mySum > sum && sum > 0) {
    document.getElementById('easyMySumMoves').value = sum;
    showToast('Моя сумма не может быть больше общей суммы');
    // Пересчитываем после изменения значения
    return;
  }
  
  let myShares = 0;
  if (mySum > 0 && price > 0) {
    // Учитываем комиссию: если комиссия > 0, то мои акции = (моя сумма * (1 - комиссия/100)) / цена
    if (commission > 0) {
      const mySumAfterCommission = mySum * (1 - commission / 100);
      myShares = Math.floor(mySumAfterCommission / price);
    } else {
      myShares = Math.floor(mySum / price);
    }
  }
  try {
    const owner = (localStorage.getItem('cf_owner') || (participants[0]||'') || '').trim();
    const qtyInt = (sum > 0 && price > 0) ? Math.floor(sum / price) : 0;
    const topEl = document.getElementById('easySummaryTopMoves');
    const bottomEl = document.getElementById('easySummaryBottomMoves');
    
    // Формируем строку с учетом комиссии
    let mySharesText = '';
    if (myShares > 0 && owner) {
      mySharesText = `<br>Из них <b>${fmtPretty(myShares,0)}</b> акций на счет <b>${escapeHtml(owner)}</b>`;
      if (commission > 0) {
        mySharesText += `<br><br><span style="font-size:14px;color:#666;">(Комиссия ${commission}% учтена)</span>`;
      }
    }
    
    const html = (qtyInt > 0) ? (`Покупаем <b>${fmtPretty(qtyInt,0)}</b> акций за <b>${fmtPretty(sum,0)}$</b>${mySharesText}`) : '';
    if (topEl) topEl.innerHTML = html;
    if (bottomEl) {
      if (qtyInt > 0) {
        const line2 = (myShares > 0 && owner)
          ? `<div style=\"margin-top:8px\">Из них <b>${fmtPretty(myShares,0)}</b> акций на счет <b>${escapeHtml(owner)}</b></div>`
          : '';
        const commissionText = (commission > 0) ? `<div style="margin-top:8px;font-size:14px;color:#666;">(Комиссия ${commission}% учтена)</div>` : '';
        bottomEl.innerHTML = `<div style=\"margin-bottom:8px;color:#444;\">Нужно сказать банку:</div>`+
          `<div style=\"border:2px solid #4a90e2;border-radius:8px;padding:12px;background:#fff\">`+
          `<div>Покупаем <b>${fmtPretty(qtyInt,0)}</b> акций за <b>${fmtPretty(sum,0)}$</b></div>`+
          `${line2}`+
          `</div>`+
          `${commissionText}`;
      } else {
        bottomEl.innerHTML = '';
      }
    }
  } catch {}
  
  // Обновляем заголовки при изменении моих акций
  try { updateBuyHeaders(); } catch {}
}

// Очистка легкой покупки в разделе Ходы
function clearEasyBuyMoves() {
  document.getElementById('easySumMoves').value = '';
  document.getElementById('easyPriceMoves').value = '';
  document.getElementById('easyMySumMoves').value = '';
  document.getElementById('easyCommissionMoves').value = '0';
  document.getElementById('easyResultMoves').innerHTML = '';
  document.getElementById('easyMySharesMoves').textContent = '0';
  
  // Обнуляем капитал при очистке
  try {
    const st = getMoveState();
    st.balance = 0;
    setMoveState(st);
    updateTopBalance();
    addHistory('Баланс', 'Очистка: баланс обнулен');
  } catch {}
  
  // Обновляем заголовки после очистки легкой покупки
  try { updateBuyHeaders(); } catch {}
}

// Сохранение настроек звуков таймера
function saveTimerSounds() {
  const sound15 = document.getElementById('timer15Sound').value;
  const sound7 = document.getElementById('timer7Sound').value;
  const sound3 = document.getElementById('timer3Sound') ? document.getElementById('timer3Sound').value : (localStorage.getItem('cf_timer3Sound')||'playBeep');
  const soundStart = document.getElementById('timerStartSound') ? document.getElementById('timerStartSound').value : (localStorage.getItem('cf_timerStartSound')||'playBong');
  localStorage.setItem('cf_timer15Sound', sound15);
  localStorage.setItem('cf_timer7Sound', sound7);
  localStorage.setItem('cf_timer3Sound', sound3);
  localStorage.setItem('cf_timerStartSound', soundStart);
}

// Загрузка настроек звуков таймера
function loadTimerSounds() {
  const sound15 = localStorage.getItem('cf_timer15Sound') || 'playSound3';
  const sound7 = localStorage.getItem('cf_timer7Sound') || 'playSound6';
  const sound3 = localStorage.getItem('cf_timer3Sound') || 'playBeep';
  const soundStart = localStorage.getItem('cf_timerStartSound') || 'playBong';
  
  const select15 = document.getElementById('timer15Sound');
  const select7 = document.getElementById('timer7Sound');
  const select3 = document.getElementById('timer3Sound');
  const selectStart = document.getElementById('timerStartSound');
  
  if (select15) select15.value = sound15;
  if (select7) select7.value = sound7;
  if (select3) select3.value = sound3;
  if (selectStart) selectStart.value = soundStart;
}

// Инициализация настроек звуков при загрузке страницы
document.addEventListener('DOMContentLoaded', function() {
  // Сброс старых настроек звука на новые значения по умолчанию
  try {
    const current15 = localStorage.getItem('cf_timer15Sound');
    const currentStart = localStorage.getItem('cf_timerStartSound');
    
    if (!current15 || current15 === 'playBong') {
      localStorage.setItem('cf_timer15Sound', 'playSound3');
    }
    if (!currentStart) {
      localStorage.setItem('cf_timerStartSound', 'playBong');
    }
  } catch {}
  try { loadTimerSounds(); } catch {}
});

// Получение функции звука по имени
function getTimerSoundFunction(soundName) {
  const soundFunctions = {
    'playBong': playBong,
    'playSound1': playSound1,
    'playSound2': playSound2,
    'playSound3': playSound3,
    'playSound4': playSound4,
    'playSound5': playSound5,
    'playSound6': playSound6,
    'playSound7': playSound7,
    'playSound8': playSound8,
    'playSound9': playSound9,
    'playSound10': playSound10,
    'playBeep': playBeep
  };
  return soundFunctions[soundName] || playSound3;
}

// Автопрокрутка к полям Легкой покупки при вводе, чтобы поле было видно
;(function(){
  function ensureInputVisible(inputEl){
    if(!inputEl) return;
    try{
      const rect = inputEl.getBoundingClientRect();
      const topPad = 20, bottomPad = 100;
      const out = rect.bottom > (window.innerHeight - bottomPad) || rect.top < topPad;
      if(out){
        const target = Math.max(0, window.scrollY + rect.top - window.innerHeight * 0.5);
        window.scrollTo({ top: target, behavior: 'smooth' });
      }
    }catch{}
  }
  document.addEventListener('input', function(e){
    const t = e.target;
    if(!t || !t.id) return;
    if(t.id === 'easySum' || t.id === 'easyPrice'){
      ensureInputVisible(t);
    }
  });
  // Центруем также при фокусе на поле
  document.addEventListener('focusin', function(e){
    const t = e.target;
    if(!t || !t.id) return;
    if(t.id === 'easySum' || t.id === 'easyPrice'){
      ensureInputVisible(t);
    }
  });
})();

// Центрирование экрана на любом поле ввода при фокусе (input/textarea/select)
;(function(){
  function centerOn(el){
    try{
      const rect = el.getBoundingClientRect();
      const viewportH = window.innerHeight || document.documentElement.clientHeight || 0;
      const target = Math.max(0, window.scrollY + rect.top - (viewportH/2) + (rect.height/2));
      window.scrollTo({ top: target, behavior: 'smooth' });
    }catch{}
  }
  // На фокус и на клик (для случаев, когда фокус уже был в другом поле)
  function onCenter(e){
    const t = e.target;
    if (!t) return;
    const tag = (t.tagName||'').toUpperCase();
    // Не центрируем чекбоксы (особенно в прогнозе), чтобы страница не прыгала
    if (tag === 'INPUT') {
      const isCheckbox = t.type === 'checkbox';
      const isForecastChk = t.classList && t.classList.contains('forecastChk');
      if (isCheckbox || isForecastChk) return;
    }
    if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT'){
      centerOn(t);
    }
  }
  document.addEventListener('focusin', onCenter, true);
  document.addEventListener('mousedown', function(e){
    // Центрируем только по прямому клику по самим полям, чтобы не прыгать при любом клике
    const t = e.target;
    if (!t) return;
    const tag = (t.tagName||'').toUpperCase();
    if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT'){
      // Пропускаем чекбоксы и галочки прогноза
      if (t.type === 'checkbox' || (t.classList && t.classList.contains('forecastChk'))) return;
      // Дадим браузеру поставить каретку, затем центрируем
      setTimeout(()=>onCenter({target:t}), 0);
    }
  }, true);
})();

// Очистка поля при фокусе, если там стоит 0
function clearZeroOnFocus(input) {
  // Очищаем поле если там стоит 0 или пустая строка
  if (input.value === '0' || input.value === '') {
    input.value = '';
    // Устанавливаем курсор в начало поля (только для текстовых полей)
    if (input.type !== 'number') {
      try {
        input.setSelectionRange(0, 0);
      } catch (e) {
        // Игнорируем ошибки для числовых полей
      }
    }
  }
}

// Дополнительная обработка для предотвращения "01000"
function handleInputFocus(input) {
  // Если поле содержит только 0, очищаем его при фокусе
  if (input.value === '0') {
    input.value = '';
    // Устанавливаем курсор в начало поля (только для текстовых полей)
    if (input.type !== 'number') {
      try {
        input.setSelectionRange(0, 0);
      } catch (e) {
        // Игнорируем ошибки для числовых полей
      }
    }
  }
}
// Обработчики для калькуляторов будут добавляться в renderBuy()
// Дополнительно: делегированные обработчики на документ, чтобы всё работало даже при повторных рендерах
document.addEventListener('input', function(e){
  var t = e.target;
  if (!t) return;
  var id = t.id || '';
  console.log('Input event triggered for id:', id, 'value:', t.value);
  if (id === 'easySum' || id === 'easyPrice') {
    try{ updateEasyBuy(); }catch{}
  }
  if (id === 'easyMySum') {
    try{ updateEasyBuyMy(); }catch{}
  }
  if (t.classList && (t.classList.contains('kpdInvest') || t.classList.contains('kpdPassive'))) {
    try{ updateKPD(); }catch{}
  }
  if (id === 'historySearch') {
    try { renderHistory(); } catch {}
  }
  // Автопересчёт оптимизатора при вводе бюджета (только если нет сложных выражений)
  if (id === 'optBudget' && t.tagName === 'INPUT') {
    const value = t.value || '';
    console.log('optBudget input:', value, 'includes +:', value.includes('+'));
    // Если в поле нет сложных выражений, то автопересчитываем
    // Минус не вызывает автоматический пересчет, как и плюс
    if (!value.includes('+') && !value.includes('-') && !value.includes('*') && !value.includes('/') && !value.includes('(')) {
      console.log('Running optimization automatically...');
      try { 
        // Добавляем небольшую задержку, чтобы избежать частых вызовов
        clearTimeout(window.optimizationTimeout);
        window.optimizationTimeout = setTimeout(() => {
          runOptimization(); 
          console.log('Optimization completed');
        }, 300);
      } catch (e) {
        console.error('Optimization error:', e);
      }
    }
  }
  // Обработка полей партнерского раздела
  if (id === 'partnerSum' || id === 'partnerBuy' || id === 'partnerSell' || id === 'partnerCom') {
    try { 
      console.log('Партнеры: ввод в поле', id, 'значение:', t.value);
      console.log('Партнеры: вызываем updatePartnerResult()');
      updatePartnerResult(); 
      console.log('Партнеры: updatePartnerResult() завершен');
    } catch (e) {
      console.error('Партнеры: ошибка при обновлении результата:', e);
    }
  }
  // 5) UX: задать step/inputmode для числовых полей
  if (t.matches && t.matches('input[type="number"].sellCardCommSell')) {
    t.step = '1'; t.min = '0'; t.max = '100'; t.setAttribute('inputmode','numeric');
  }
  if (t.matches && (t.id==='buyPrice' || t.id==='easyPrice' || t.id==='easySum' || t.id==='partnerSum' || t.id==='partnerBuy' || t.id==='partnerSell')) {
    t.step = '0.01'; t.setAttribute('inputmode','decimal');
  }
  // Превью строки прогноза при вводе
  if (id === 'forecastName' || id === 'forecastInvest' || id === 'forecastMonthly' || id === 'forecastPrice') {
    try { renderForecast(); } catch {}
  }
});

// Обновление превью прогноза при смене категории
document.addEventListener('change', function(e){
  var t = e.target;
  if (!t) return;
  console.log('Change event triggered for id:', t.id, 'value:', t.value);
  if (t.id === 'forecastCategory') {
    try { renderForecast(); } catch {}
  }
  if (t.id === 'optBudget' && t.tagName === 'INPUT') {
    const value = t.value || '';
    console.log('optBudget change:', value, 'includes +:', value.includes('+'));
    // Если в поле нет сложных выражений, то автопересчитываем
    // Минус не вызывает автоматический пересчет, как и плюс
    if (!value.includes('+') && !value.includes('-') && !value.includes('*') && !value.includes('/') && !value.includes('(')) {
      console.log('Running optimization on change...');
      try { 
        // Добавляем небольшую задержку, чтобы избежать частых вызовов
        clearTimeout(window.optimizationTimeout);
        window.optimizationTimeout = setTimeout(() => {
          runOptimization(); 
          console.log('Optimization on change completed');
        }, 300);
      } catch (e) {
        console.error('Optimization on change error:', e);
      }
    }
  }
});

// КПД в покупке: сворачиваемый блок
function initBuyKpdToggle(){
  const block = document.getElementById('buyKpdBlock');
  const btn = document.getElementById('buyKpdToggle');
  if (!block || !btn) return;
  const state = localStorage.getItem('cf_buy_kpd_collapsed') === '1';
  block.classList.toggle('collapsed', state);
  btn.textContent = state ? 'Показать' : 'Скрыть';
}
function toggleBuyKPD(){
  const block = document.getElementById('buyKpdBlock');
  const btn = document.getElementById('buyKpdToggle');
  if (!block || !btn) return;
  const willCollapse = !block.classList.contains('collapsed');
  block.classList.toggle('collapsed', willCollapse);
  btn.textContent = willCollapse ? 'Показать' : 'Скрыть';
  localStorage.setItem('cf_buy_kpd_collapsed', willCollapse ? '1' : '0');
}

// Главное: сворачивание КПД
function initMainKpdToggle(){
  const block = document.getElementById('mainKpdBlock');
  const btn = document.getElementById('mainKpdToggle');
  if (!block || !btn) return;
  const state = localStorage.getItem('cf_main_kpd_collapsed') === '1';
  block.classList.toggle('collapsed', state);
  btn.textContent = state ? 'Показать' : 'Скрыть';
}
function toggleMainKPD(){
  const block = document.getElementById('mainKpdBlock');
  const btn = document.getElementById('mainKpdToggle');
  if (!block || !btn) return;
  const willCollapse = !block.classList.contains('collapsed');
  block.classList.toggle('collapsed', willCollapse);
  btn.textContent = willCollapse ? 'Показать' : 'Скрыть';
  localStorage.setItem('cf_main_kpd_collapsed', willCollapse ? '1' : '0');
}

// Главное: сворачивание калькулятора выгодной покупки
function initProfitableBuyToggle(){
  const block = document.getElementById('profitableBuyCalculator');
  const btn = document.getElementById('profBuyToggle');
  if (!block || !btn) return;
  const state = localStorage.getItem('cf_prof_buy_collapsed') === '1';
  block.classList.toggle('collapsed', state);
  btn.textContent = state ? 'Показать' : 'Скрыть';
}
function toggleProfitableBuy(){
  const block = document.getElementById('profitableBuyCalculator');
  const btn = document.getElementById('profBuyToggle');
  if (!block || !btn) return;
  const willCollapse = !block.classList.contains('collapsed');
  block.classList.toggle('collapsed', willCollapse);
  btn.textContent = willCollapse ? 'Показать' : 'Скрыть';
  localStorage.setItem('cf_prof_buy_collapsed', willCollapse ? '1' : '0');
}
// Обработчик фокуса для всех числовых полей
document.addEventListener('focus', function(e){
  var t = e.target;
  if (!t) return;
  
  // Если это числовое поле и содержит только 0, очищаем его
  if (t.type === 'number' && t.value === '0') {
    t.value = '';
    // Не используем setSelectionRange для числовых полей
  }
}, true);
document.addEventListener('change', function(e){
  var t = e.target;
  if (t && t.classList && t.classList.contains('kpdCheck')) {
    try{ updateKPD(); }catch{}
  }
});
  // Калькулятор Кэфа Расхода: вводы
  document.addEventListener('input', function(e){
    if (e.target && e.target.classList && e.target.classList.contains('expCoefInput')) {
      try { updateExpenseCoef(); } catch {}
    }
  });

  // ===== Калькулятор Кэфа Расхода =====
  let expenseCoef = LS.load('cf_expenseCoef', {});
  function renderExpenseCoef(){
    const rowsWrap = document.getElementById('expenseCoefRows');
    const summaryEl = document.getElementById('expenseCoefSummary');
    if(!rowsWrap || !summaryEl) return;
    const owner = localStorage.getItem('cf_owner') || participants[0] || '';
  // Если данных нет — инициализируем пустыми значениями для текущего владельца,
  // чтобы поля ввода всегда отображались после очистки
  if (!expenseCoef || typeof expenseCoef !== 'object') expenseCoef = {};
  if (owner && !expenseCoef[owner]) {
    expenseCoef[owner] = { monthly: '' };
    LS.save('cf_expenseCoef', expenseCoef);
  }
    // Если есть временные данные по владельцу без участников — перенесём на реального владельца
    if (participants && participants.length && expenseCoef['_owner_']) {
      expenseCoef[owner] = expenseCoef['_owner_'];
      delete expenseCoef['_owner_'];
      LS.save('cf_expenseCoef', expenseCoef);
    }
    // гарантируем наличие записей для всех участников
    (participants||[]).forEach(p=>{
      if(!expenseCoef[p]) expenseCoef[p] = { monthly: '' };
    });
    // Строим строки в порядке ввода участников; если участников нет — показываем временную строку владельца
    const list = (participants && participants.length)
      ? [...participants]
      : ['_owner_'];
    rowsWrap.innerHTML = list.map(p=>{
      const key = p;
      const isTempOwner = (p === '_owner_');
      const name = isTempOwner ? 'Владелец' : p;
      const val = expenseCoef[key] || { monthly:'' };
      const isOwner = isTempOwner || p===owner;
      return `<div class="ecRow" style="max-width:700px;margin-bottom:8px">
        <div style="margin-bottom:4px"><input type="text" value="${name}" placeholder="Игрок" disabled style="width:100%;background:#f7f7f7"></div>
        <div style="display:flex;gap:8px;align-items:center">
          <input class="expCoefInput" data-p="${key}" data-k="monthly" type="number" step="0.01" inputmode="decimal" placeholder="Ежемесячный доход" value="${val.monthly||''}" style="flex:1 1 0;min-width:200px">
          <span class="expCoefRatio" data-p="${key}" style="display:inline-block;min-width:60px;font-weight:600;${isOwner?'color:#7a5f00':'color:#226'}"></span>
        </div>
      </div>`;
    }).join('');
    updateExpenseCoef();
  }
  function updateExpenseCoef(){
    let owner = localStorage.getItem('cf_owner') || participants[0] || '';
    if ((!participants || !participants.length) && expenseCoef['_owner_']) owner = '_owner_';
    // Считать текущие значения из DOM и сохранить
    document.querySelectorAll('.expCoefInput').forEach(inp=>{
      const p = inp.getAttribute('data-p');
      const k = inp.getAttribute('data-k');
      if(!expenseCoef[p]) expenseCoef[p] = { monthly:'' };
      const v = inp.value === '' ? '' : (parseFloat(inp.value) || 0);
      expenseCoef[p][k] = v;
    });
    LS.save('cf_expenseCoef', expenseCoef);
    const ownerMonthly = (expenseCoef[owner] && parseFloat(expenseCoef[owner].monthly)) || 0;
    let summaryLines = [];
    const iter = (participants && participants.length) ? participants : Object.keys(expenseCoef);
    iter.forEach(p=>{
      const monthly = parseFloat(expenseCoef[p]?.monthly)||0;
      if(p===owner){
        const txt = ownerMonthly>0? 'x1' : '';
        const span = document.querySelector(`.expCoefRatio[data-p="${CSS.escape(p)}"]`);
        if(span) span.textContent = txt;
        return;
      }
      let ratio = '';
      if(ownerMonthly>0 && monthly>0){
        const r = ownerMonthly / monthly; // во сколько раз меньше ежемесячный доход игрока
        ratio = `x${(r).toFixed(2)}`;
      }
      const span = document.querySelector(`.expCoefRatio[data-p="${CSS.escape(p)}"]`);
      if(span) span.textContent = ratio;
      if(ratio){ summaryLines.push(`${p}: ${ratio}`); }
    });
    const summaryEl = document.getElementById('expenseCoefSummary');
    if(summaryEl){
      summaryEl.innerHTML = summaryLines.length ? 'Рекомендованное соотношение взносов (по ежемесячному доходу):<br>' + summaryLines.join('<br>') : '';
    }
    
    // Записываем в историю ходов обновление коэффициентов расходов
    if (summaryLines.length > 0) {
      try{ addTurnEventForCurrentTurn(0, `Коэффициенты расходов: ${summaryLines.join(', ')}`); }catch{}
      try{ renderTurnsHistory(); }catch{}
    }
  }
function adjustSharesPrompt(sym) {
  openFactorModal({
    title: `Изменение количества: ${sym}`,
    onSubmit: (factor)=>{ adjustShares(sym, factor); }
  });
}
function adjustShares(sym, factor) {
  pushUndo();
  let changed = false;
  participants.forEach(p => {
    if (holdings[p] && holdings[p][sym] && holdings[p][sym].qty > 0) {
      holdings[p][sym].qty = +(holdings[p][sym].qty * factor);
      changed = true;
    }
  });
  if (changed) {
    // Копим историю коэффициентов по символу (не меняя сумму покупки)
    if (!Array.isArray(sellFactors[sym])) sellFactors[sym] = [];
    sellFactors[sym].push(factor);
    sellFactors[sym] = sellFactors[sym].slice(-4); // максимум 4 метки
    LS.save('cf_sellFactors', sellFactors);
    saveAll();
    renderSell();
    showToast('Количество акций изменено');
    addHistory('Изменение акций', `${sym}: × <b>${factor}</b>`);
    
    // Записываем в историю ходов изменение количества акций
    try{ addTurnEventForCurrentTurn(0, `Изменение акций ${sym}: ×${factor}`); }catch{}
    try{ renderTurnsHistory(); }catch{}
  } else {
    showToast('Нет акций для изменения');
  }
}
// Универсальное модальное окно ввода коэффициента
function openFactorModal(opts){
  try {
    const { title = 'Коэффициент', onSubmit } = opts || {};
    const backdrop = document.createElement('div');
    backdrop.className = 'modal-backdrop';
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.innerHTML = `
      <h3>${escapeHtml(title)}</h3>
      <div class="row">
        <label style="min-width:120px">Коэффициент</label>
        <input id="factorInput" type="number" step="0.01" min="0.0001" value="0.5" style="flex:1" inputmode="decimal">
      </div>
      <div class="row" style="gap:6px">
        <button class="btn" data-v="0.5" style="background:#eef">0.5</button>
        <button class="btn" data-v="2" style="background:#eef">2</button>
        <button class="btn" data-v="1" style="background:#eef">1</button>
      </div>
      <div class="actions">
        <button class="btn" id="factorCancel" style="background:#eee;color:#444;border:1px solid #ccc">Отмена</button>
        <button class="btn" id="factorOk">Применить</button>
      </div>
    `;
    backdrop.appendChild(modal);
    document.body.appendChild(backdrop);
    const input = modal.querySelector('#factorInput');
    setTimeout(()=>{ try{ input.focus(); input.select(); }catch{} }, 0);
    modal.querySelectorAll('button[data-v]').forEach(btn=>{
      btn.addEventListener('click', ()=>{ input.value = btn.getAttribute('data-v'); });
    });
    const close = ()=>{ try{ document.body.removeChild(backdrop); }catch{} };
    modal.querySelector('#factorCancel').addEventListener('click', close);
    modal.querySelector('#factorOk').addEventListener('click', ()=>{
      const v = parseFloat(String(input.value).replace(',', '.'));
      if (isNaN(v) || v <= 0) { showToast('Некорректный коэффициент'); return; }
      try { onSubmit && onSubmit(v); } finally { close(); }
    });
    backdrop.addEventListener('click', (e)=>{ if (e.target === backdrop) close(); });
    window.addEventListener('keydown', function onKey(e){ if(e.key==='Escape'){ close(); window.removeEventListener('keydown', onKey); } });
  } catch(e) {
    console.error('openFactorModal error', e);
    showToast('Ошибка модального окна');
  }
}
function burnSymbol(sym){
  pushUndo();
  if (burnedSymbols[sym]) {
    delete burnedSymbols[sym];
    LS.save('cf_burnedSymbols', burnedSymbols);
    renderSell();
    showToast('Снята отметка "сгорело"');
    addHistory('Отмена сгорания', `${sym}`);
    
    // Записываем в историю ходов отмену сгорания акций
    try{ addTurnEventForCurrentTurn(0, `Отмена сгорания акций: ${sym}`); }catch{}
    try{ renderTurnsHistory(); }catch{}
  } else {
    burnedSymbols[sym] = true;
    LS.save('cf_burnedSymbols', burnedSymbols);
    renderSell();
    showToast('Отмечено как сгоревшее');
    addHistory('Сгорание акций', `${sym}`);
    
    // Записываем в историю ходов сгорание акций
    try{ addTurnEventForCurrentTurn(0, `Сгорание акций: ${sym}`); }catch{}
    try{ renderTurnsHistory(); }catch{}
  }
}
// История операций
function getHistory() {
  return LS.load('cf_history', []);
}
function addHistory(type, desc) {
  // Теперь записываем все операции в историю ходов
  addOperationToTurnsHistory(type, desc);
  
  // Сохраняем также в старую историю для обратной совместимости (можно будет убрать позже)
  const arr = getHistory();
  arr.unshift({
    time: new Date().toLocaleString(),
    type,
    desc
  });
  LS.save('cf_history', arr.slice(0, 2000));
}
  // Универсальная функция изменения баланса с уведомлением и записью в историю/события
  function applyBalanceDelta(delta, historyLabel){
    try{
      const d = Math.round(parseFloat(delta)||0);
      if (!d) return;
      const st = getMoveState();
      st.balance = Math.round((st.balance||0) + d);
      setMoveState(st);
      updateTopBalance();
      
      // Проверяем, стал ли баланс отрицательным
      if (st.balance < 0) {
        showToast('Баланс отрицательный', 2000);
      }
      
      // Уведомление на 1 секунду
      const sign = d>0?'+':'';
      showToast(`${sign}${fmtPretty(Math.abs(d),0)} $`, 1000);
      if (historyLabel){
        addHistory('Баланс', `${historyLabel}: ${d>0?'+':'-'}${fmtPretty(Math.abs(d),0)}$`);
      }
      // События уже записываются через addHistory, поэтому не дублируем
    }catch{}
  }
  // ===== Казино =====
  function updateCasino(){
    try{
      const betEl = document.getElementById('casinoBet');
      const coefEl = document.getElementById('casinoCoef');
      const resEl = document.getElementById('casinoResult');
      if (!betEl || !coefEl || !resEl) return;
      const bet = parseFloat(betEl.value||'0') || 0;
      const coef = parseFloat(coefEl.value||'0') || 0;
      if (bet>0 && coef>0){
        const win = Math.round(bet * coef);
        const total = Math.round(win + bet);
        resEl.textContent = `Выигрыш ${fmtPretty(win,0)} + ${fmtPretty(Math.round(bet),0)} = ${fmtPretty(total,0)} $`;
      } else {
        resEl.textContent = '';
      }
    }catch{}
  }
  function setCasinoCoef(v){
    try{
      const el = document.getElementById('casinoCoef');
      if (!el) return;
      el.value = String(v);
      try{ el.dispatchEvent(new Event('input', { bubbles: true })); }catch{}
      updateCasino();
    }catch{}
  }
  function casinoTake(){
    try{
      const takeEl = document.getElementById('casinoTakeAmount');
      if (!takeEl) return;
      const amt = Math.round(parseFloat(takeEl.value||'0')) || 0;
      if (amt<=0){ showToast('Укажите сумму'); return; }
      applyBalanceDelta(amt, 'Казино — забрал');
    }catch{}
  }
  function clearCasino(){
    try{
      const betEl = document.getElementById('casinoBet');
      const coefEl = document.getElementById('casinoCoef');
      const takeEl = document.getElementById('casinoTakeAmount');
      const resEl = document.getElementById('casinoResult');
      if (betEl) betEl.value='';
      if (coefEl) coefEl.value='';
      if (takeEl) takeEl.value='';
      if (resEl) resEl.textContent='';
    }catch{}
  }
function renderHistory() {
  // Загружаем настройки звуков при открытии вкладки истории
  try { loadTimerSounds(); } catch {}
  
  const arr = getHistory();
  const wrap = document.getElementById('historyList');
  if (!wrap) return;
  const q = (document.getElementById('historySearch')?.value || '').trim().toLowerCase();
  if (!arr.length) {
    wrap.textContent = '';
    const div = document.createElement('div');
    div.style.color = '#888';
    div.style.padding = '16px';
    div.textContent = 'Пока нет операций';
    wrap.appendChild(div);
    return;
  }
  wrap.textContent = '';
  // Настройки звуков: единый блок в Истории. Сначала чистим возможные дубликаты, затем создаём/дополняем "старый" стиль.
  try{
    const byId = (id)=> document.getElementById(id);
    // 1) Удаляем все ранее добавленные элементы с этими id, чтобы ids были уникальны и не было дублей
    ['timerStartSound','timer15Sound','timer7Sound','timer3Sound','timerSoundsSaveBtn','testStartBtn','test15Btn','test7Btn','test3Btn'].forEach(id=>{
      try{
        const el = byId(id);
        if (el && el.parentNode){
          // Если это чужой нижний блок — удаляем весь ряд целиком, иначе просто сам элемент
          const row = el.closest('div');
          if (row && row.parentNode) row.parentNode.removeChild(row); else el.parentNode.removeChild(el);
        }
      }catch{}
    });
    const playSelected = (selectId)=>{ try{ const sel = byId(selectId); const fn = sel && getTimerSoundFunction(sel.value); if (fn) fn(); }catch{} };
    const sel15 = byId('timer15Sound');
    const sel7 = byId('timer7Sound');
    // 2) Пытаемся найти существующий контейнер "старого" красивого блока
    if (sel15 || sel7){
      const anchorRow = (sel15 && sel15.parentNode) || (sel7 && sel7.parentNode);
      const container = anchorRow && anchorRow.parentNode;
      if (container){
        // Добавим Старт, если нет
        if (!byId('timerStartSound')){
          const row = document.createElement('div');
          row.style.cssText = 'display:flex;align-items:center;gap:6px';
          row.innerHTML = '<label style="font-size:13px;color:#666">Старт</label>'+
            '<select id="timerStartSound" style="padding:4px 6px;font-size:13px">'+
            '<option value="playBong">Гонг</option>'+
            '<option value="playBeep">Бип</option>'+
            '<option value="playSound1">Тревога 1</option>'+
            '<option value="playSound2">Тревога 2</option>'+
            '<option value="playSound3">Тревога 3</option>'+
            '<option value="playSound4">Тревога 4</option>'+
            '<option value="playSound5">Тревога 5</option>'+
            '<option value="playSound6">Тревога 6</option>'+
            '<option value="playSound7">Тревога 7</option>'+
            '<option value="playSound8">Тревога 8</option>'+
            '<option value="playSound9">Тревога 9</option>'+
            '<option value="playSound10">Тревога 10</option>'+
            '</select>'+
            '<button class="btn" id="testStartBtn" style="padding:4px 8px;font-size:13px">Тест старт</button>';
          container.insertBefore(row, container.firstChild);
        }
        // Добавим 3 сек, если нет
        if (!byId('timer3Sound')){
          const row3 = document.createElement('div');
          row3.style.cssText = 'display:flex;align-items:center;gap:6px';
          row3.innerHTML = '<label style="font-size:13px;color:#666">3 сек</label>'+
            '<select id="timer3Sound" style="padding:4px 6px;font-size:13px">'+
            '<option value="playBong">Гонг</option>'+
            '<option value="playBeep">Бип</option>'+
            '<option value="playSound1">Тревога 1</option>'+
            '<option value="playSound2">Тревога 2</option>'+
            '<option value="playSound3">Тревога 3</option>'+
            '<option value="playSound4">Тревога 4</option>'+
            '<option value="playSound5">Тревога 5</option>'+
            '<option value="playSound6">Тревога 6</option>'+
            '<option value="playSound7">Тревога 7</option>'+
            '<option value="playSound8">Тревога 8</option>'+
            '<option value="playSound9">Тревога 9</option>'+
            '<option value="playSound10">Тревога 10</option>'+
            '</select>'+
            '<button class="btn" id="test3Btn" style="padding:4px 8px;font-size:13px">Тест 3с</button>';
          container.appendChild(row3);
        }
        // Кнопка Сохранить — добавим, если нет
        if (!byId('timerSoundsSaveBtn')){
          const saveWrap = document.createElement('div');
          saveWrap.innerHTML = '<button class="btn" id="timerSoundsSaveBtn" style="padding:4px 10px;font-size:13px">Сохранить</button>';
          container.appendChild(saveWrap);
        }
        // Привяжем обработчики и выставим значения
        try { loadTimerSounds(); } catch {}
        const saveBtn = byId('timerSoundsSaveBtn'); if (saveBtn) saveBtn.onclick = ()=>{ try{ saveTimerSounds(); showToast('Сохранено'); }catch{} };
        const tStart = byId('testStartBtn'); if (tStart) tStart.onclick = ()=> playSelected('timerStartSound');
        const t15 = byId('test15Btn'); if (t15) t15.onclick = ()=> playSelected('timer15Sound');
        const t7 = byId('test7Btn'); if (t7) t7.onclick = ()=> playSelected('timer7Sound');
        const t3 = byId('test3Btn'); if (t3) t3.onclick = ()=> playSelected('timer3Sound');
      }
    } else {
      // 3) Если красивого блока нет (например, на десктопе) — создаём единый блок сверху списка
      const wrapHost = document.getElementById('historyList');
      if (wrapHost && wrapHost.parentNode){
        const holder = document.createElement('div');
        holder.style.margin = '6px 0 10px 0';
        holder.id = 'timerSoundControls';
        holder.innerHTML = ``;
        wrapHost.parentNode.insertBefore(holder, wrapHost);
      }
    }
  }catch{}
  arr.filter(e=>{
    if (!q) return true;
    return (String(e.time).toLowerCase().includes(q) || String(e.type).toLowerCase().includes(q) || String(e.desc).toLowerCase().includes(q));
  }).forEach(e=>{
    const row = document.createElement('div');
    row.style.padding = '7px 0';
    row.style.borderBottom = '1px solid #eee';
    row.style.fontSize = '15px';
    const time = document.createElement('span');
    time.style.color = '#888';
    time.style.fontSize = '13px';
    time.textContent = e.time + ' ';
    const type = document.createElement('b');
    type.style.color = '#226';
    type.textContent = e.type + ': ';
    const desc = document.createElement('span');
    // Добавляем цветные цифры в описании
    let descText = escapeHtml(e.desc).replace(/\n/g,'<br>');
    // Ищем суммы в формате "1234 $" или "+1234 $" или "-1234 $" с разделителями пробелами/запятыми
    descText = descText.replace(/([+-]?[\d\s]+(?:[.,]\d{3})*)\s*\$/g, (match, amount) => {
      const normalized = amount.replace(/\s/g,'').replace(/\.(?=\d{3}(\D|$))/g,'').replace(/,(?=\d{3}(\D|$))/g,'');
      const num = parseFloat(normalized.replace(',', '.'));
      const color = num > 0 ? '#0a0' : (num < 0 ? '#c33' : '#666');
      return `<span style="color:${color};font-weight:600">${match}</span>`;
    });
    desc.innerHTML = descText;
    row.appendChild(time);
    row.appendChild(type);
    row.appendChild(desc);
    wrap.appendChild(row);
  });
}

// Добавить функции экспорта и импорта данных
function exportAppData() {
  const keys = [
    'cf_participants','cf_participantCom','cf_holdings','cf_buyDeals','cf_partnerRows',
    'cf_buySymbolTpls','cf_buyPriceTpls','cf_sellSymbolTpls','cf_sellPriceTpls',
    'cf_paidSells','cf_sellPrices','cf_history',
    'cf_ledgerIncomes','cf_ledgerExpenses',
    'cf_sellDealCom','cf_sellCardCom','cf_sellCardRecipient',
    'cf_sellCardDefaultCom','cf_sellCardDefaultRecipient',
    'cf_sellFactors','cf_burnedSymbols',
    'cf_buySumOriginal','cf_buySumByParticipant','cf_buyTurnBySymbol',
    'cf_expenseCoef','cf_stateVersion',
    'cf_partnerBalance','cf_partnerPrevSum',
    'cf_moves_state','cf_moves_turn','cf_turn_number','cf_credit_hidden','cf_credit_taken','cf_post_turn',
    'cf_timer15Sound','cf_timer7Sound','cf_activeTab','cf_mainTabScrollPosition'
  ];
  const data = {};
  keys.forEach(k => { data[k] = localStorage.getItem(k); });
  const blob = new Blob([JSON.stringify(data, null, 2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  const now = new Date();
  const pad = n => n.toString().padStart(2, '0');
  const fname = `cashflow-helper-${now.getFullYear()}-${pad(now.getMonth()+1)}-${pad(now.getDate())}_${pad(now.getHours())}-${pad(now.getMinutes())}-${pad(now.getSeconds())}.json`;
  a.download = fname;
  document.body.appendChild(a);
  a.click();
  setTimeout(()=>{document.body.removeChild(a);URL.revokeObjectURL(url);}, 100);
  
  // Записываем в историю ходов экспорт данных
  try{ addTurnEventForCurrentTurn(0, 'Экспорт данных приложения'); }catch{}
  try{ renderTurnsHistory(); }catch{}
}
// Экспорт/импорт истории ходов в/из отдельного HTML
function exportTurnsHistory(){
  const arr = getTurns();
  const html = `<!doctype html><html lang="ru"><head><meta charset="utf-8"><title>История ходов</title><style>body{font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;margin:16px} .card{border:1px solid #eee;background:#fff;border-radius:8px;padding:10px;margin:10px 0;} .title{font-weight:700;margin-bottom:6px} .delta{font-size:14px} .delta span{font-weight:600}</style></head><body>
    <h1>История ходов</h1>
    ${arr.map(t=>{
      const isPost = !!t.post;
      const title = isPost ? `После хода ${t.num}` : `Ход №${t.num}`;
      const events = Array.isArray(t.events)?t.events:[];
      const evHtml = events.length?(`<div style="margin-top:6px"><div style="font-weight:600;margin-bottom:2px">Изменения баланса:</div>${events.map(ev=>{ const sign = ev.delta>=0?'+':''; const amt = `${sign}${Math.round(ev.delta)} $`; const desc = ev.desc?` — ${ev.desc}`:''; return `<div class=\"delta\"><span style=\"color:${ev.delta>=0?'#0a0':'#c33'}\">${amt}</span>${desc}</div>`; }).join('')}</div>`):'';
      if (isPost){
        return `<div class=\"card\"><div class=\"title\">${title}</div><div>Баланс: <b>${Math.round(t.balance||0)} $</b></div><div>Капитал: <b>${Math.round(t.capital||0)} $</b></div>${t.comment?`<div style=\"margin-top:6px\"><div style=\"font-weight:600;margin-bottom:2px\">Комментарий после хода:</div><div>${t.comment||''}</div></div>`:''}${evHtml}</div>`;
      }
      return `<div class=\"card\"><div class=\"title\">${title}</div>
        <div>Кубик: <b>${t.dice||''}</b></div>
        <div>Карточка: <b>${t.card||''}</b></div>
        <div>Денежный поток: <b style="color:${t.cashflowDone ? '#0a0' : '#666'}">${t.cashflowDone?('+'+Math.round(t.monthly||0)+' $'):'+0 $'}</b></div>
        ${t.credit?`<div>Кредит: <b>${t.credit}</b></div>`:''}
        <div>Баланс: <b>${Math.round(t.balance||0)} $</b></div>
        <div>Капитал: <b>${Math.round(t.capital||0)} $</b></div>
        ${t.comment?`<div style=\"margin-top:6px\"><div style=\"font-weight:600;margin-bottom:2px\">Комментарий к ходу:</div><div>${t.comment||''}</div></div>`:''}
        ${evHtml}
      </div>`;
    }).join('')}
  <!--DATA:${encodeURIComponent(JSON.stringify(arr))}--></body></html>`;
  const blob = new Blob([html], {type:'text/html'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'turns-history.html'; document.body.appendChild(a); a.click(); setTimeout(()=>{document.body.removeChild(a); URL.revokeObjectURL(url);}, 100);
  
  // Записываем в историю ходов экспорт истории ходов
  try{ addTurnEventForCurrentTurn(0, 'Экспорт истории ходов'); }catch{}
  try{ renderTurnsHistory(); }catch{}
}
function importTurnsHistory(){
  const input = document.createElement('input');
  input.type = 'file'; input.accept = 'text/html';
  input.onchange = (e)=>{
    const file = e.target.files && e.target.files[0]; if (!file) return;
    const reader = new FileReader();
    reader.onload = (evt)=>{
      try{
        const html = String(evt.target.result||'');
        // Грубый парс: ищем JSON в комментарии <!--DATA:...-->
        const m = html.match(/<!--DATA:([^]*)-->/);
        if (m){
          const jsonStr = decodeURIComponent(m[1]);
          const data = JSON.parse(jsonStr);
          if (Array.isArray(data)){ 
            LS.save('cf_turns', data); 
            renderTurnsHistory(); 
            showToast('История ходов импортирована');
            
            // Записываем в историю ходов импорт истории ходов
            try{ addTurnEventForCurrentTurn(0, 'Импорт истории ходов'); }catch{}
            try{ renderTurnsHistory(); }catch{}
          }
        } else {
          alert('В файле не найдены данные истории');
        }
      }catch(err){ alert('Ошибка импорта истории: '+err); }
    };
    reader.readAsText(file);
  };
  document.body.appendChild(input); input.click(); setTimeout(()=>{try{document.body.removeChild(input);}catch{}}, 0);
}
function importAppData() {
  document.getElementById('importFileInput').click();
}
document.getElementById('importFileInput').addEventListener('change', function(e) {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = function(evt) {
    try {
      if (!confirm('Импортировать файл и перезаписать текущие данные? Будет создана резервная копия.')) return;
      // Резервная копия
      try {
        const keys = [
          'cf_participants','cf_participantCom','cf_holdings','cf_buyDeals','cf_partnerRows',
          'cf_buySymbolTpls','cf_buyPriceTpls','cf_sellSymbolTpls','cf_sellPriceTpls',
          'cf_paidSells','cf_sellPrices','cf_history',
          'cf_ledgerIncomes','cf_ledgerExpenses',
          'cf_sellDealCom','cf_sellCardCom','cf_sellCardRecipient',
          'cf_sellCardDefaultCom','cf_sellCardDefaultRecipient',
          'cf_sellFactors','cf_burnedSymbols',
          'cf_buySumOriginal','cf_buySumByParticipant',
          'cf_stateVersion'
        ];
        const backup = {};
        keys.forEach(k=>backup[k]=localStorage.getItem(k));
        localStorage.setItem('cf_backup', JSON.stringify({time: Date.now(), data: backup}));
      } catch {}
      const data = JSON.parse(evt.target.result);
      Object.entries(data).forEach(([k,v])=>{
        if (v !== null && v !== undefined) localStorage.setItem(k, v);
        else localStorage.removeItem(k);
      });
      // Записываем в историю ходов импорт данных
      try{ addTurnEventForCurrentTurn(0, 'Импорт данных приложения'); }catch{}
      try{ renderTurnsHistory(); }catch{}
      
      alert('Данные успешно загружены! Страница будет перезагружена.');
      location.reload();
    } catch(err) {
      alert('Ошибка загрузки файла: ' + err);
    }
  };
  reader.readAsText(file);
});

// Undo/Redo logic
// Безопасная инициализация приложения
function safeInit() {
  try {
    // Восстанавливаем активную вкладку после инициализаций, чтобы шаблоны не пропадали
    if (!window._cfTabRestored) {
      const savedTab = localStorage.getItem('cf_activeTab');
      const activeTab = savedTab && tabs.includes(savedTab) ? savedTab : 'tabParticipants';
      setActive(activeTab);
      
          // Восстанавливаем позицию скролла для вкладки "Главное"
    if (activeTab === 'tabParticipants') {
      const savedScrollPosition = localStorage.getItem('cf_mainTabScrollPosition');
      if (savedScrollPosition) {
        setTimeout(() => {
          try {
            const participantsSection = document.getElementById('participants');
            if (participantsSection) {
              participantsSection.scrollTop = parseInt(savedScrollPosition);
            }
          } catch (e) {
            console.warn('Ошибка восстановления позиции скролла:', e);
          }
        }, 100);
      }
      
      // Добавляем обработчик для сохранения позиции скролла
      setTimeout(() => {
        try {
          const participantsSection = document.getElementById('participants');
          if (participantsSection) {
            participantsSection.addEventListener('scroll', () => {
              localStorage.setItem('cf_mainTabScrollPosition', participantsSection.scrollTop.toString());
            });
          }
        } catch (e) {
          console.warn('Ошибка добавления обработчика скролла:', e);
        }
      }, 200);
    }
      
      window._cfTabRestored = true;
    }
    
    // При первом рендере перерисуем ведомость
    try { 
      renderLedger(); 
    } catch (error) {
      console.warn('Ошибка рендера ведомости:', error);
    }
    
    // Гарантируем создание списка лучших ЭфКПК
    try { 
      setTimeout(() => highlightBestEffTables(), 100); 
    } catch (error) {
      console.warn('Ошибка создания списка лучших ЭфКПК:', error);
    }
    
    // Гарантируем отрисовку калькулятора кэфа расхода даже без участников
    try { renderExpenseCoef(); } catch (e) { console.warn('renderExpenseCoef on init error', e); }

    // Синхронизируем баланс партнеров при загрузке
    try {
      const partnerBalance = localStorage.getItem('cf_partnerBalance');
      if (partnerBalance) {
        const balance = parseFloat(partnerBalance);
        const sign = balance < 0 ? '-' : '';
        const absBalance = Math.abs(balance);
        const balanceText = `${sign}${fmtPretty(absBalance,0)} $`;
        
        // Обновляем баланс для мобильной версии
        const balanceTopEl = document.getElementById('balanceTop');
        if (balanceTopEl) {
          balanceTopEl.textContent = balanceText;
          // Устанавливаем цвет: красный для отрицательных значений
          balanceTopEl.style.color = balance < 0 ? '#c33' : '#222';
        }
        
        // Обновляем баланс для десктопной версии
        const balanceTopDesktopEl = document.getElementById('balanceTopDesktop');
        if (balanceTopDesktopEl) {
          balanceTopDesktopEl.textContent = balanceText;
          // Устанавливаем цвет: красный для отрицательных значений
          balanceTopDesktopEl.style.color = balance < 0 ? '#c33' : '#222';
        }
        
        console.log('Инициализация: синхронизирован баланс партнеров:', balanceText);
      }
    } catch (e) { console.warn('Ошибка синхронизации баланса партнеров:', e); }

    console.log('CashFlow приложение успешно загружено');
    
  } catch (error) {
    showError('Ошибка инициализации приложения: ' + error.message);
    console.error('Ошибка инициализации приложения:', error);
  }
}

// Запускаем инициализацию после загрузки DOM
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', safeInit);
} else {
  safeInit();
}
function getAppSnapshot() {
  const keys = [
    'cf_participants','cf_participantCom','cf_holdings','cf_buyDeals','cf_partnerRows',
    'cf_buySymbolTpls','cf_buyPriceTpls','cf_sellSymbolTpls','cf_sellPriceTpls',
    'cf_paidSells','cf_sellPrices','cf_history',
    'cf_ledgerIncomes','cf_ledgerExpenses'
  ];
  const snap = {};
  keys.forEach(k => { snap[k] = localStorage.getItem(k); });
  return snap;
}
function setAppSnapshot(snap) {
  Object.entries(snap).forEach(([k,v])=>{
    if (v !== null && v !== undefined) localStorage.setItem(k, v);
    else localStorage.removeItem(k);
  });
}
function pushUndo() {
  let stack = JSON.parse(localStorage.getItem('cf_undoStack')||'[]');
  const snap = getAppSnapshot();
  const snapStr = JSON.stringify(snap);
  const lastStr = stack.length ? JSON.stringify(stack[stack.length-1]) : '';
  if (snapStr !== lastStr) {
    stack.push(snap);
    if (stack.length > 30) stack = stack.slice(-30);
    localStorage.setItem('cf_undoStack', JSON.stringify(stack));
    localStorage.setItem('cf_redoStack', JSON.stringify([]));
    
    // Записываем в историю ходов создание точки отката
    try{ addTurnEventForCurrentTurn(0, 'Создана точка отката'); }catch{}
    try{ renderTurnsHistory(); }catch{}
  }
}
function undoAction() {
  let stack = JSON.parse(localStorage.getItem('cf_undoStack')||'[]');
  let redo = JSON.parse(localStorage.getItem('cf_redoStack')||'[]');
  if (stack.length < 2) return showToast('Нет действий для отмены');
  const current = stack.pop();
  redo.push(current);
  const prev = stack[stack.length-1];
  setAppSnapshot(prev);
  localStorage.setItem('cf_undoStack', JSON.stringify(stack));
  localStorage.setItem('cf_redoStack', JSON.stringify(redo));
  
  // Записываем в историю ходов отмену действия
  try{ addTurnEventForCurrentTurn(0, 'Отмена действия (Undo)'); }catch{}
  try{ renderTurnsHistory(); }catch{}
  
  showToast('Действие отменено');
  location.reload();
}
function redoAction() {
  let stack = JSON.parse(localStorage.getItem('cf_undoStack')||'[]');
  let redo = JSON.parse(localStorage.getItem('cf_redoStack')||'[]');
  if (!redo.length) return showToast('Нет действий для возврата');
  const next = redo.pop();
  setAppSnapshot(next);
  stack.push(next);
  localStorage.setItem('cf_undoStack', JSON.stringify(stack));
  localStorage.setItem('cf_redoStack', JSON.stringify(redo));
  
  // Записываем в историю ходов возврат действия
  try{ addTurnEventForCurrentTurn(0, 'Возврат действия (Redo)'); }catch{}
  try{ renderTurnsHistory(); }catch{}
  
  showToast('Действие возвращено');
  location.reload();
}
</script>
<script>
// Централизованная история ошибок
const ERROR_LS_KEY = 'cf_error_history_v1';
function loadErrors(){
  try { return JSON.parse(localStorage.getItem(ERROR_LS_KEY)||'[]'); } catch { return []; }
}
function saveErrors(arr){
  try { localStorage.setItem(ERROR_LS_KEY, JSON.stringify(arr)); } catch {}
}
function addErrorRecord(rec){
  try {
    const list = loadErrors();
    list.unshift(rec);
    if (list.length > 500) list.length = 500;
    saveErrors(list);
    renderErrorHistory();
  } catch {}
}
function exportErrors(){
  try {
    const data = loadErrors();
    const blob = new Blob([JSON.stringify(data, null, 2)], {type:'application/json'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'cashflow_errors.json';
    document.body.appendChild(a);
    a.click();
    a.remove();
  } catch(e) { console.error('exportErrors', e); }
}
function clearErrorHistory(){
  try { localStorage.removeItem(ERROR_LS_KEY); renderErrorHistory(); if (typeof showToast==='function') showToast('История ошибок очищена'); } catch {}
}
function renderErrorHistory(){
  const wrap = document.getElementById('errorHistoryList');
  if (!wrap) return;
  const items = loadErrors();
  if (!items.length){
    wrap.innerHTML = '<div style="color:#888;text-align:center">Нет записей ошибок</div>';
    return;
  }
  const html = items.map((e)=>{
    const time = e.timeFormatted || new Date(e.time||Date.now()).toLocaleString();
    const cat = e.category || 'Ошибка';
    const title = e.name || e.message || '';
    const file = e.file || '';
    const line = (e.line||e.col) ? ` @ ${e.line||''}:${e.col||''}` : '';
    const ctx = e.context ? `<div style="color:#555;margin-top:4px;word-break:break-word">Контекст: ${typeof escapeHtml==='function'?escapeHtml(String(e.context)):String(e.context)}</div>` : '';
    const stack = e.stack ? `<details style="margin-top:6px"><summary style="cursor:pointer;color:#226">Стек</summary><pre style="white-space:pre-wrap;margin:6px 0 0 0;color:#444">${typeof escapeHtml==='function'?escapeHtml(String(e.stack)):String(e.stack)}</pre></details>` : '';
    const extra = e.extra ? `<details style="margin-top:6px"><summary style="cursor:pointer;color:#226">Детали</summary><pre style="white-space:pre-wrap;margin:6px 0 0 0;color:#444">${typeof escapeHtml==='function'?escapeHtml(JSON.stringify(e.extra, null, 2)):JSON.stringify(e.extra, null, 2)}</pre></details>` : '';
    const esc = (s)=> typeof escapeHtml==='function' ? escapeHtml(String(s)) : String(s);
    return `<div style="padding:10px;border:1px solid #f6b3b3;background:#fff5f5;border-radius:8px;margin:8px 0;">
      <div style="font-weight:600;color:#c33">${esc(cat)}: ${esc(title)}</div>
      <div style="color:#666;margin-top:2px">${esc(file)}${esc(line)} • ${esc(time)}</div>
      ${ctx}
      ${stack}
      ${extra}
    </div>`;
  }).join('');
  wrap.innerHTML = html;
}
window.addEventListener('error', function(ev){
  try {
    const err = ev.error || {};
    addErrorRecord({
      category: 'RuntimeError',
      name: err.name || 'Error',
      message: err.message || String(ev.message||'') || 'unknown',
      stack: err.stack || '',
      file: (ev.filename||'') + '',
      line: ev.lineno||null,
      col: ev.colno||null,
      time: Date.now(),
      timeFormatted: new Date().toLocaleString()
    });
  } catch(e) { console.error('error capture failed', e); }
}, true);
window.addEventListener('unhandledrejection', function(ev){
  try {
    const reason = ev.reason;
    addErrorRecord({
      category: 'UnhandledPromiseRejection',
      name: (reason && reason.name) || 'PromiseRejection',
      message: (reason && (reason.message|| (reason.toString && reason.toString()))) || String(reason||'') || 'unknown',
      stack: (reason && reason.stack) || '',
      time: Date.now(),
      timeFormatted: new Date().toLocaleString()
    });
  } catch(e) { console.error('unhandledrejection capture failed', e); }
}, true);
function logAppError(category, message, extra){
  addErrorRecord({
    category: category || 'AppError',
    name: 'AppError',
    message: String(message||''),
    extra: extra || null,
    time: Date.now(),
    timeFormatted: new Date().toLocaleString()
  });
}
setTimeout(()=>{ try { renderErrorHistory(); } catch {} }, 0);
</script>
<!-- Глобальный круговой таймер и логика вкладки "Ходы" -->
<script>
  // ===== Floating Timer (configurable) =====
  (function(){
    try{
      // Create timer DOM
      const wrap = document.createElement('div');
      wrap.className = 'cf-timer-wrap';
      wrap.id = 'cfTimerWrap';
      wrap.innerHTML = `
        <div class="cf-timer" id="cfTimer" title="Показать/скрыть управление">
          <svg viewBox="0 0 100 100" aria-hidden="true">
            <circle class="ring-bg" cx="50" cy="50" r="44"></circle>
            <circle class="ring-fg" id="cfTimerRing" cx="50" cy="50" r="44" stroke-dasharray="276.4601535" stroke-dashoffset="0"></circle>
          </svg>
          <div class="center-text" id="cfTimerText">60</div>
        </div>
        <div class="cf-left-controls" id="cfTimerLeft">
          <button class="cf-btn cf-btn-reset" id="cfTimerResetLeft" title="Сброс">✖</button>
          <button class="cf-btn cf-btn-pause" id="cfTimerPause" title="Пауза">II</button>
        </div>
        <button class="cf-btn cf-timer-play" id="cfTimerPlay" title="Старт">▶</button>
      `;
      document.body.appendChild(wrap);

      // State
      const TIMER_LS_KEY = 'cf_timer_duration_sec';
      const clamp = (n, min, max) => Math.max(min, Math.min(max, n));
      function getTimerDuration(){
        const v = parseInt(localStorage.getItem(TIMER_LS_KEY)||'60',10);
        return clamp(isFinite(v)?v:60, 5, 600);
      }
      let duration = getTimerDuration();
      let remaining = duration;
      let paused = true; // не запускаем сразу
      let lastTick = Date.now();
      let rafId = null;
      let controlsHideId = null;
      const ringLen = 2 * Math.PI * 44; // r=44
      const ring = document.getElementById('cfTimerRing');
      const text = document.getElementById('cfTimerText');
      const timerEl = document.getElementById('cfTimer');
      const playBtn = document.getElementById('cfTimerPlay');
      const pauseBtn = document.getElementById('cfTimerPause');
      const resetBtnLeft = document.getElementById('cfTimerResetLeft');
      // В маленьком плавающем таймере — без поля ввода длительности

      function setPaused(p){
        paused = p;
        timerEl.classList.toggle('paused', paused);
        // Управляем прозрачностью Play: при паузе более прозрачная, при активном таймере скрыта
        try{
          if (playBtn){
            if (paused) {
              playBtn.style.opacity = '.45';
              playBtn.style.display = 'inline-flex';
              if (text) text.style.display = 'none';
            } else {
              playBtn.style.display = 'none';
              if (text) text.style.display = '';
            }
          }
        }catch{}
        lastTick = Date.now();
      }
      function updateRing(){
        const ratio = Math.max(0, Math.min(1, remaining / duration));
        // Синяя часть должна уменьшаться: от полного (0) к пустому (ringLen)
        const offset = ringLen * (1 - ratio);
        if (ring) ring.setAttribute('stroke-dashoffset', String(offset));
        if (text) text.textContent = String(Math.ceil(remaining));
        
        // Изменяем цвет таймера в зависимости от состояния
        if (ring) {
          // Получаем состояние доллара (активен ли знак доллара)
          let dollarActive = false;
          try {
            const st = getMoveState();
            // Доллар активен только если можно получить денежный поток И он еще не получен
            const canGetCash = st.dice !== null && st.cardChoice !== null && st.cardChoice !== undefined;
            dollarActive = canGetCash && st.cashflowDone !== true;
          } catch {}
          
          if (dollarActive) {
            // Зеленый имеет наивысший приоритет
            ring.style.stroke = '#22C55E';
          } else if (remaining <= 3) {
            // 3 сек — красный
            ring.style.stroke = '#ef4444';
          } else if (remaining <= 7) {
            // 7 сек — оранжевый
            ring.style.stroke = '#fb923c';
          } else if (remaining <= 15) {
            // 15 сек — желтый
            ring.style.stroke = '#FDE047';
          } else {
            // По умолчанию — синий
            ring.style.stroke = '#4a90e2';
          }
        }
      }
 function resetTimer(){
   duration = getTimerDuration();
   remaining = duration;
   bongPlayed = false;
   beepPlayed = false;
   alarm3Played = false;
   alarm2Played = false;
   alarm1Played = false;
   setPaused(true); // после сброса — на паузе
   updateRing();
   if (playBtn) playBtn.style.display = 'inline-flex';
   if (text) text.style.display = 'none';
   
   // Принудительно восстанавливаем состояние всех кнопок таймера
   if (resetBtnLeft) {
     resetBtnLeft.style.pointerEvents = 'auto';
     resetBtnLeft.style.cursor = 'pointer';
     resetBtnLeft.disabled = false;
     resetBtnLeft.style.opacity = '1';
     resetBtnLeft.style.display = 'inline-flex';
     resetBtnLeft.style.visibility = 'visible';
   }
   if (playBtn) {
     playBtn.style.pointerEvents = 'auto';
     playBtn.style.cursor = 'pointer';
     playBtn.disabled = false;
     playBtn.style.opacity = '1';
     playBtn.style.display = 'inline-flex';
     playBtn.style.visibility = 'visible';
   }
   if (pauseBtn) {
     pauseBtn.style.pointerEvents = 'auto';
     pauseBtn.style.cursor = 'pointer';
     pauseBtn.disabled = false;
     pauseBtn.style.opacity = '1';
     pauseBtn.style.visibility = 'visible';
   }
   
   // Перепривязываем обработчики событий для надежности
   try {
     if (typeof bindResetHandler === 'function') bindResetHandler();
     if (typeof bindPauseHandler === 'function') bindPauseHandler();
     if (typeof bindPlayHandler === 'function') bindPlayHandler();
   } catch {}
 }
      // After first click on timer, clicking it will not pause; it toggles controls visibility
      let controlsPinned = false;

      // Bong sound
      let bongPlayed = false;
      function playBong(){
        try{
          // Переиспользуем один AudioContext, чтобы не достигать лимитов
          let ctx = window._gongCtx;
          const Ctx = (window.AudioContext || window.webkitAudioContext);
          if (!ctx) { ctx = new Ctx(); window._gongCtx = ctx; }
          if (ctx.state === 'suspended') { try { ctx.resume(); } catch{} }
          // Гонг: удар (noise burst) + низкий сустейн + металлический оттенок
          const master = ctx.createGain();
          master.gain.value = 1.0; // Очень высокая громкость
          const comp = ctx.createDynamicsCompressor();
          comp.threshold.value = -6;
          comp.knee.value = 3;
          comp.ratio.value = 12;
          comp.attack.value = 0.003;
          comp.release.value = 0.25;
          master.connect(comp).connect(ctx.destination);

          // Удар (шум)
          const noiseBuf = ctx.createBuffer(1, ctx.sampleRate * 0.4, ctx.sampleRate);
          const data = noiseBuf.getChannelData(0);
          for (let i=0;i<data.length;i++){ data[i] = (Math.random()*2-1) * Math.exp(-i/(ctx.sampleRate*0.04)); }
          const noise = ctx.createBufferSource(); noise.buffer = noiseBuf;
          const noiseFilter = ctx.createBiquadFilter(); noiseFilter.type = 'bandpass'; noiseFilter.frequency.value = 1200; noiseFilter.Q.value = 0.7;
          const noiseGain = ctx.createGain(); noiseGain.gain.setValueAtTime(0.001, ctx.currentTime);
          noiseGain.gain.exponentialRampToValueAtTime(1.2, ctx.currentTime + 0.02);
          noiseGain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.5);
          noise.connect(noiseFilter).connect(noiseGain).connect(master);
          noise.start(); noise.stop(ctx.currentTime + 0.3);

          // Низкий основной тон (сустейн ~2.2с)
          const base = ctx.createOscillator(); base.type = 'sine'; base.frequency.setValueAtTime(196, ctx.currentTime); // G3
          const baseGain = ctx.createGain(); baseGain.gain.setValueAtTime(0.001, ctx.currentTime);
          baseGain.gain.exponentialRampToValueAtTime(1.0, ctx.currentTime + 0.05);
          baseGain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 2.0);
          base.connect(baseGain).connect(master);
          base.start(); base.stop(ctx.currentTime + 2.05);

          // Металлический оттенок (высокий обертон с колебанием)
          const overt = ctx.createOscillator(); overt.type = 'sine'; overt.frequency.setValueAtTime(784, ctx.currentTime); // G5
          const overtGain = ctx.createGain(); overtGain.gain.setValueAtTime(0.001, ctx.currentTime);
          overtGain.gain.exponentialRampToValueAtTime(0.7, ctx.currentTime + 0.06);
          overtGain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 2.0);
          const vibr = ctx.createOscillator(); vibr.type = 'sine'; vibr.frequency.setValueAtTime(6, ctx.currentTime);
          const vibrGain = ctx.createGain(); vibrGain.gain.value = 12; // +-12 Гц
          vibr.connect(vibrGain).connect(overt.frequency);
          overt.connect(overtGain).connect(master);
          vibr.start(); overt.start(); overt.stop(ctx.currentTime + 2.05); vibr.stop(ctx.currentTime + 2.05);
        }catch{}
      }
      
      // Beep sound (короткий бип)
      let beepPlayed = false;
      function playBeep(){
        try{
          let ctx = window._gongCtx;
          const Ctx = (window.AudioContext || window.webkitAudioContext);
          if (!ctx) { ctx = new Ctx(); window._gongCtx = ctx; }
          if (ctx.state === 'suspended') { try { ctx.resume(); } catch{} }
          
          const master = ctx.createGain();
          master.gain.value = 1.0;
          master.connect(ctx.destination);
          
          // Короткий бип на 800 Гц длительностью 0.2 секунды
          const beep = ctx.createOscillator();
          beep.type = 'sine';
          beep.frequency.setValueAtTime(800, ctx.currentTime);
          
          const beepGain = ctx.createGain();
          beepGain.gain.setValueAtTime(0.001, ctx.currentTime);
          beepGain.gain.exponentialRampToValueAtTime(0.8, ctx.currentTime + 0.05);
          beepGain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.2);
          
          beep.connect(beepGain).connect(master);
          beep.start();
          beep.stop(ctx.currentTime + 0.2);
        }catch{}
      }
      
      // Экспортируем тест звука в глобальную область
      try { window.playBong = playBong; } catch {}
      try { window.playBeep = playBeep; } catch {}
      try { window.getTimerSoundFunction = getTimerSoundFunction; } catch {}
      
      // 10 разных сигналов тревоги для тестирования
      function playSound1() { // Низкий сигнал тревоги
        try{
          let ctx = window._gongCtx;
          const Ctx = (window.AudioContext || window.webkitAudioContext);
          if (!ctx) { ctx = new Ctx(); window._gongCtx = ctx; }
          if (ctx.state === 'suspended') { try { ctx.resume(); } catch{} }
          
          const master = ctx.createGain();
          master.gain.value = 1.0;
          master.connect(ctx.destination);
          
          // Два тона с переключением
          for (let i = 0; i < 3; i++) {
            const osc = ctx.createOscillator();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(200, ctx.currentTime + i * 0.3);
            
            const gain = ctx.createGain();
            gain.gain.setValueAtTime(0.001, ctx.currentTime + i * 0.3);
            gain.gain.exponentialRampToValueAtTime(1.0, ctx.currentTime + i * 0.3 + 0.1);
            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + i * 0.3 + 0.25);
            
            osc.connect(gain).connect(master);
            osc.start(ctx.currentTime + i * 0.3);
            osc.stop(ctx.currentTime + i * 0.3 + 0.25);
          }
        }catch{}
      }
      
      function playSound2() { // Высокий сигнал тревоги
        try{
          let ctx = window._gongCtx;
          const Ctx = (window.AudioContext || window.webkitAudioContext);
          if (!ctx) { ctx = new Ctx(); window._gongCtx = ctx; }
          if (ctx.state === 'suspended') { try { ctx.resume(); } catch{} }
          
          const master = ctx.createGain();
          master.gain.value = 1.0;
          master.connect(ctx.destination);
          
          // Быстрые высокие тоны
          for (let i = 0; i < 6; i++) {
            const osc = ctx.createOscillator();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(1500, ctx.currentTime + i * 0.15);
            
            const gain = ctx.createGain();
            gain.gain.setValueAtTime(0.001, ctx.currentTime + i * 0.15);
            gain.gain.exponentialRampToValueAtTime(1.0, ctx.currentTime + i * 0.15 + 0.05);
            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + i * 0.15 + 0.1);
            
            osc.connect(gain).connect(master);
            osc.start(ctx.currentTime + i * 0.15);
            osc.stop(ctx.currentTime + i * 0.15 + 0.1);
          }
        }catch{}
      }
      
      function playSound3() { // Двойной сигнал тревоги (3 повтора)
        try{
          let ctx = window._gongCtx;
          const Ctx = (window.AudioContext || window.webkitAudioContext);
          if (!ctx) { ctx = new Ctx(); window._gongCtx = ctx; }
          if (ctx.state === 'suspended') { try { ctx.resume(); } catch{} }
          
          const master = ctx.createGain();
          master.gain.value = 1.0;
          master.connect(ctx.destination);
          
          // Чередующиеся тоны — 3 раза
          for (let i = 0; i < 3; i++) {
            const osc1 = ctx.createOscillator();
            osc1.type = 'sine';
            osc1.frequency.setValueAtTime(400, ctx.currentTime + i * 0.4);
            
            const osc2 = ctx.createOscillator();
            osc2.type = 'sine';
            osc2.frequency.setValueAtTime(600, ctx.currentTime + i * 0.4);
            
            const gain = ctx.createGain();
            gain.gain.setValueAtTime(0.001, ctx.currentTime + i * 0.4);
            gain.gain.exponentialRampToValueAtTime(1.0, ctx.currentTime + i * 0.4 + 0.1);
            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + i * 0.4 + 0.3);
            
            osc1.connect(gain).connect(master);
            osc2.connect(gain).connect(master);
            osc1.start(ctx.currentTime + i * 0.4); osc1.stop(ctx.currentTime + i * 0.4 + 0.3);
            osc2.start(ctx.currentTime + i * 0.4); osc2.stop(ctx.currentTime + i * 0.4 + 0.3);
          }
        }catch{}
      }
      
      function playSound4() { // Пульсирующий сигнал тревоги
        try{
          let ctx = window._gongCtx;
          const Ctx = (window.AudioContext || window.webkitAudioContext);
          if (!ctx) { ctx = new Ctx(); window._gongCtx = ctx; }
          if (ctx.state === 'suspended') { try { ctx.resume(); } catch{} }
          
          const master = ctx.createGain();
          master.gain.value = 1.0;
          master.connect(ctx.destination);
          
          // Пульсирующие тоны с нарастанием
          for (let i = 0; i < 5; i++) {
            const osc = ctx.createOscillator();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(300 + i * 50, ctx.currentTime + i * 0.2);
            
            const gain = ctx.createGain();
            gain.gain.setValueAtTime(0.001, ctx.currentTime + i * 0.2);
            gain.gain.exponentialRampToValueAtTime(1.0, ctx.currentTime + i * 0.2 + 0.05);
            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + i * 0.2 + 0.15);
            
            osc.connect(gain).connect(master);
            osc.start(ctx.currentTime + i * 0.2);
            osc.stop(ctx.currentTime + i * 0.2 + 0.15);
          }
        }catch{}
      }
      function playSound5() { // Шумовой сигнал тревоги
        try{
          let ctx = window._gongCtx;
          const Ctx = (window.AudioContext || window.webkitAudioContext);
          if (!ctx) { ctx = new Ctx(); window._gongCtx = ctx; }
          if (ctx.state === 'suspended') { try { ctx.resume(); } catch{} }
          
          const master = ctx.createGain();
          master.gain.value = 1.0;
          master.connect(ctx.destination);
          
          // Серия шумовых всплесков
          for (let i = 0; i < 4; i++) {
            const bufferSize = ctx.sampleRate * 0.1;
            const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
            const data = buffer.getChannelData(0);
            
            for (let j = 0; j < bufferSize; j++) {
              data[j] = (Math.random() * 2 - 1) * Math.exp(-j / (ctx.sampleRate * 0.02));
            }
            
            const source = ctx.createBufferSource();
            source.buffer = buffer;
            
            const gain = ctx.createGain();
            gain.gain.setValueAtTime(0.001, ctx.currentTime + i * 0.25);
            gain.gain.exponentialRampToValueAtTime(1.0, ctx.currentTime + i * 0.25 + 0.02);
            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + i * 0.25 + 0.1);
            
            source.connect(gain).connect(master);
            source.start(ctx.currentTime + i * 0.25);
            source.stop(ctx.currentTime + i * 0.25 + 0.1);
          }
        }catch{}
      }
      
      function playSound6() { // Трель сигнал тревоги
        try{
          let ctx = window._gongCtx;
          const Ctx = (window.AudioContext || window.webkitAudioContext);
          if (!ctx) { ctx = new Ctx(); window._gongCtx = ctx; }
          if (ctx.state === 'suspended') { try { ctx.resume(); } catch{} }
          
          const master = ctx.createGain();
          master.gain.value = 1.0;
          master.connect(ctx.destination);
          
          // Быстрая трель
          for (let i = 0; i < 8; i++) {
            const osc = ctx.createOscillator();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(800 + (i % 2) * 200, ctx.currentTime + i * 0.1);
            
            const gain = ctx.createGain();
            gain.gain.setValueAtTime(0.001, ctx.currentTime + i * 0.1);
            gain.gain.exponentialRampToValueAtTime(1.0, ctx.currentTime + i * 0.1 + 0.02);
            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + i * 0.1 + 0.08);
            
            osc.connect(gain).connect(master);
            osc.start(ctx.currentTime + i * 0.1);
            osc.stop(ctx.currentTime + i * 0.1 + 0.08);
          }
        }catch{}
      }
      
      function playSound7() { // Глиссандо сигнал тревоги
        try{
          let ctx = window._gongCtx;
          const Ctx = (window.AudioContext || window.webkitAudioContext);
          if (!ctx) { ctx = new Ctx(); window._gongCtx = ctx; }
          if (ctx.state === 'suspended') { try { ctx.resume(); } catch{} }
          
          const master = ctx.createGain();
          master.gain.value = 1.0;
          master.connect(ctx.destination);
          
          // Серия глиссандо
          for (let i = 0; i < 3; i++) {
            const osc = ctx.createOscillator();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(200, ctx.currentTime + i * 0.4);
            osc.frequency.exponentialRampToValueAtTime(800, ctx.currentTime + i * 0.4 + 0.3);
            
            const gain = ctx.createGain();
            gain.gain.setValueAtTime(0.001, ctx.currentTime + i * 0.4);
            gain.gain.exponentialRampToValueAtTime(1.0, ctx.currentTime + i * 0.4 + 0.1);
            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + i * 0.4 + 0.3);
            
            osc.connect(gain).connect(master);
            osc.start(ctx.currentTime + i * 0.4);
            osc.stop(ctx.currentTime + i * 0.4 + 0.3);
          }
        }catch{}
      }
      
      function playSound8() { // Аккордный сигнал тревоги
        try{
          let ctx = window._gongCtx;
          const Ctx = (window.AudioContext || window.webkitAudioContext);
          if (!ctx) { ctx = new Ctx(); window._gongCtx = ctx; }
          if (ctx.state === 'suspended') { try { ctx.resume(); } catch{} }
          
          const master = ctx.createGain();
          master.gain.value = 1.0;
          master.connect(ctx.destination);
          
          // Серия диссонирующих аккордов
          for (let i = 0; i < 3; i++) {
            const freqs = [300 + i * 100, 450 + i * 50, 600 + i * 75];
            
            freqs.forEach(freq => {
              const osc = ctx.createOscillator();
              osc.type = 'sine';
              osc.frequency.setValueAtTime(freq, ctx.currentTime + i * 0.3);
              
              const gain = ctx.createGain();
              gain.gain.setValueAtTime(0.001, ctx.currentTime + i * 0.3);
              gain.gain.exponentialRampToValueAtTime(1.0, ctx.currentTime + i * 0.3 + 0.1);
              gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + i * 0.3 + 0.25);
              
              osc.connect(gain).connect(master);
              osc.start(ctx.currentTime + i * 0.3);
              osc.stop(ctx.currentTime + i * 0.3 + 0.25);
            });
          }
        }catch{}
      }
      
      function playSound9() { // Электронный сигнал тревоги
        try{
          let ctx = window._gongCtx;
          const Ctx = (window.AudioContext || window.webkitAudioContext);
          if (!ctx) { ctx = new Ctx(); window._gongCtx = ctx; }
          if (ctx.state === 'suspended') { try { ctx.resume(); } catch{} }
          
          const master = ctx.createGain();
          master.gain.value = 1.0;
          master.connect(ctx.destination);
          
          // Серия электронных звуков
          for (let i = 0; i < 4; i++) {
            const osc = ctx.createOscillator();
            osc.type = 'square';
            osc.frequency.setValueAtTime(400 + i * 100, ctx.currentTime + i * 0.2);
            
            const filter = ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(800 + i * 200, ctx.currentTime + i * 0.2);
            filter.Q.value = 2;
            
            const gain = ctx.createGain();
            gain.gain.setValueAtTime(0.001, ctx.currentTime + i * 0.2);
            gain.gain.exponentialRampToValueAtTime(1.0, ctx.currentTime + i * 0.2 + 0.05);
            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + i * 0.2 + 0.15);
            
            osc.connect(filter).connect(gain).connect(master);
            osc.start(ctx.currentTime + i * 0.2);
            osc.stop(ctx.currentTime + i * 0.2 + 0.15);
          }
        }catch{}
      }
      
      function playSound10() { // Мелодичный сигнал тревоги
        try{
          let ctx = window._gongCtx;
          const Ctx = (window.AudioContext || window.webkitAudioContext);
          if (!ctx) { ctx = new Ctx(); window._gongCtx = ctx; }
          if (ctx.state === 'suspended') { try { ctx.resume(); } catch{} }
          
          const master = ctx.createGain();
          master.gain.value = 1.0;
          master.connect(ctx.destination);
          
          // Тревожная мелодия
          const notes = [
            {freq: 400, duration: 0.2}, // Высокий тон
            {freq: 300, duration: 0.2}, // Средний тон
            {freq: 500, duration: 0.2}, // Еще выше
            {freq: 200, duration: 0.2}, // Низкий тон
            {freq: 600, duration: 0.4}  // Финальный высокий
          ];
          
          let currentTime = ctx.currentTime;
          notes.forEach(note => {
            const osc = ctx.createOscillator();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(note.freq, currentTime);
            
            const gain = ctx.createGain();
            gain.gain.setValueAtTime(0.001, currentTime);
            gain.gain.exponentialRampToValueAtTime(1.0, currentTime + 0.05);
            gain.gain.exponentialRampToValueAtTime(0.001, currentTime + note.duration);
            
            osc.connect(gain).connect(master);
            osc.start(currentTime);
            osc.stop(currentTime + note.duration);
            
            currentTime += note.duration;
          });
        }catch{}
      }
      
      // Экспортируем все звуки в глобальную область
      try { window.playSound1 = playSound1; } catch {}
      try { window.playSound2 = playSound2; } catch {}
      try { window.playSound3 = playSound3; } catch {}
      try { window.playSound4 = playSound4; } catch {}
      try { window.playSound5 = playSound5; } catch {}
      try { window.playSound6 = playSound6; } catch {}
      try { window.playSound7 = playSound7; } catch {}
      try { window.playSound8 = playSound8; } catch {}
      try { window.playSound9 = playSound9; } catch {}
      try { window.playSound10 = playSound10; } catch {}
      
      // Экспортируем функции таймера в глобальную область
      try { 
        window.resetGlobalTimer = resetTimer; 
        window.reinitTimerHandlers = function() {
          try {
            if (typeof bindResetHandler === 'function') bindResetHandler();
            if (typeof bindPauseHandler === 'function') bindPauseHandler();
            if (typeof bindPlayHandler === 'function') bindPlayHandler();
          } catch {}
        };
      } catch {}

      // История: переназначаем кнопку "Тревога 3" на корректный звук (playSound3)
      try{
        document.addEventListener('click', function(e){
          const t = e.target;
          if (!t) return;
          // Ищем только кнопки с текстом "Тревога 3"
          if ((t.tagName==='BUTTON' || t.closest('button'))){
            const btn = (t.tagName==='BUTTON') ? t : t.closest('button');
            const label = (btn && (btn.textContent||'').trim().toLowerCase()) || '';
            if (label === 'тревога 3'){
              e.preventDefault();
              e.stopPropagation();
              try{ const f = getTimerSoundFunction('playSound3'); if (f) f(); }catch{}
            }
          }
        }, true);
      }catch{}

      // Одноразовые флаги для тревог 3/2/1 сек
      let alarm3Played = false;
      let alarm2Played = false;
      let alarm1Played = false;

      function tick(){
        const now = Date.now();
        const dt = (now - lastTick) / 1000;
        lastTick = now;
        if (!paused){
          // Гарантируем скрытие кнопки Старт во время работы таймера
          try{ if (playBtn && playBtn.style.display !== 'none') playBtn.style.display = 'none'; }catch{}
          const prev = remaining;
          remaining -= dt;
          // Надежные триггеры по факту пересечения порогов (устойчиво к пропущенным кадрам)
          if (!bongPlayed && prev > 15 && remaining <= 15) {
            bongPlayed = true;
            const sound15 = localStorage.getItem('cf_timer15Sound') || 'playSound3';
            const soundFunc15 = getTimerSoundFunction(sound15);
            if (soundFunc15) soundFunc15();
          }
          if (!beepPlayed && prev > 7 && remaining <= 7) {
            beepPlayed = true;
            const sound7 = localStorage.getItem('cf_timer7Sound') || 'playSound6';
            const soundFunc7 = getTimerSoundFunction(sound7);
            if (soundFunc7) soundFunc7();
          }
          if (!alarm3Played && prev > 3 && remaining <= 3) {
            alarm3Played = true;
            const sound3 = localStorage.getItem('cf_timer3Sound') || 'playBeep'; // 3 сек: по умолчанию БИП
            const soundFunc3 = getTimerSoundFunction(sound3);
            if (soundFunc3) soundFunc3();
          }
          // Дополнительные сигналы на 2 и 1 сек — используем тот же выбранный звук, что и для 3 сек
          if (!alarm2Played && prev > 2 && remaining <= 2) {
            alarm2Played = true;
            const sound3 = localStorage.getItem('cf_timer3Sound') || 'playBeep';
            const soundFunc3 = getTimerSoundFunction(sound3);
            if (soundFunc3) soundFunc3();
          }
          if (!alarm1Played && prev > 1 && remaining <= 1) {
            alarm1Played = true;
            const sound3 = localStorage.getItem('cf_timer3Sound') || 'playBeep';
            const soundFunc3 = getTimerSoundFunction(sound3);
            if (soundFunc3) soundFunc3();
          }
          if (remaining <= 0){
            remaining = 0;
            setPaused(true);
            // не играем звук на 0 секунде
            // show play after 3s
            setTimeout(()=>{ if (playBtn) playBtn.style.display = 'inline-flex'; }, 3000);
          }
          updateRing();
        }
        rafId = requestAnimationFrame(tick);
      }
      function showControls(withAutoHide=true){
        wrap.classList.add('controls-visible');
        if (withAutoHide){
          clearTimeout(controlsHideId);
          controlsHideId = setTimeout(()=>{
            if (!controlsPinned) wrap.classList.remove('controls-visible');
          }, 1000);
        }
      }
      timerEl.addEventListener('click', ()=>{
        // переключаем видимость кнопок при клике на таймер
        if (wrap.classList.contains('controls-visible')) {
          // если кнопки видны - скрываем их
          wrap.classList.remove('controls-visible');
          controlsPinned = false;
          clearTimeout(controlsHideId);
        } else {
          // если кнопки скрыты - показываем их
          controlsPinned = false;
          showControls(true);
        }
      });
      // Функция для привязки обработчика паузы
      function bindPauseHandler() {
        if (pauseBtn) {
          pauseBtn.removeEventListener('click', handlePauseClick);
          pauseBtn.addEventListener('click', handlePauseClick);
        }
      }
      
      function handlePauseClick(e) { 
        e.stopPropagation(); 
        controlsPinned = true; 
        clearTimeout(controlsHideId); 
        showControls(false); 
        setPaused(!paused); 
        
        // Записываем в историю ходов управление таймером
        try{ addTurnEventForCurrentTurn(0, `Таймер: ${!paused ? 'Пауза' : 'Старт'}`); }catch{}
        try{ renderTurnsHistory(); }catch{}
      }
      
      bindPauseHandler();
      // Функция для привязки обработчика сброса (чтобы можно было переприменить)
      function bindResetHandler() {
        if (resetBtnLeft) {
          // Удаляем старые обработчики
          resetBtnLeft.removeEventListener('click', handleResetClick);
          // Добавляем новый обработчик
          resetBtnLeft.addEventListener('click', handleResetClick);
        }
      }
      
      function handleResetClick(e) {
        e.stopPropagation(); 
        controlsPinned = true; 
        clearTimeout(controlsHideId); 
        showControls(false); 
        // если пользователь выставил число в барабане — сохраняем и применяем
        try{
          const v = parseInt(document.getElementById('cfTimerInlineDuration')?.value||'',10);
          if (isFinite(v)) { const vv = clamp(v,5,600); localStorage.setItem(TIMER_LS_KEY, String(vv)); }
        }catch{}
        resetTimer(); 
        
        // Записываем в историю ходов сброс таймера
        try{ addTurnEventForCurrentTurn(0, 'Таймер: Сброс'); }catch{}
        try{ renderTurnsHistory(); }catch{}
      }
      
      bindResetHandler();
      
      // Дополнительная проверка: убеждаемся, что кнопка сброса всегда доступна
      if (resetBtnLeft) {
        resetBtnLeft.style.pointerEvents = 'auto';
        resetBtnLeft.style.cursor = 'pointer';
        resetBtnLeft.disabled = false;
      }
      if (playBtn) {
        playBtn.style.display = 'inline-flex';
        // При первом расчёте фиксируем wrap как относительно позиционированный и не меняем его координаты при клике
        const style = window.getComputedStyle(wrap);
        if (style.position === 'static') wrap.style.position = 'fixed';
        wrap.style.top = wrap.style.top || '12px';
        wrap.style.right = wrap.style.right || '12px';
        // Функция для привязки обработчика play
        function bindPlayHandler() {
          if (playBtn) {
            playBtn.removeEventListener('click', handlePlayClick);
            playBtn.addEventListener('click', handlePlayClick);
          }
        }
        
        function handlePlayClick(e) { 
          e.stopPropagation(); 
            if (remaining<=0) { 
              duration = getTimerDuration(); 
              remaining = duration; 
               // Сбрасываем одноразовые флаги звуков при рестарте без крестика
               bongPlayed = false; 
               beepPlayed = false; 
               try { alarm3Played = false; alarm2Played = false; alarm1Played = false; } catch {}
            } 
          if (text) text.style.display=''; 
          setPaused(false); 
            // Звук запуска — отдельная настройка (по умолчанию Гонг) и отдельный тумблер
            const startSound = localStorage.getItem('cf_timerStartSound') || 'playBong';
            const startFunc = getTimerSoundFunction(startSound);
            const startSoundEnabled = (localStorage.getItem('cf_timerStartSoundEnabled') !== '0');
            if (startFunc && startSoundEnabled) startFunc();
          
          // Записываем в историю ходов запуск таймера
          try{ addTurnEventForCurrentTurn(0, 'Таймер: Запуск'); }catch{}
          try{ renderTurnsHistory(); }catch{}
        }
        
        bindPlayHandler();
      }
      // Dragging (mouse + touch)
      (function(){
        const target = wrap;
        let sx=0, sy=0, ox=0, oy=0, dragging=false, activeDrag=false;
        const stored = JSON.parse(localStorage.getItem('cf_timer_pos')||'null');
        if (stored && typeof stored.x==='number' && typeof stored.y==='number'){
          target.style.left = stored.x+'px';
          target.style.top = stored.y+'px';
          target.style.right = 'auto';
          target.style.position = 'fixed';
        }
        function save(){
          const rect = target.getBoundingClientRect();
          localStorage.setItem('cf_timer_pos', JSON.stringify({x: rect.left, y: rect.top}));
        }
        function start(x,y){
          dragging=true; activeDrag=false; sx=x; sy=y;
          const r=target.getBoundingClientRect();
          ox=r.left; oy=r.top;
        }
        function ensureFixedAnchor(){
          const style = window.getComputedStyle(target);
          if (style.position !== 'fixed') target.style.position = 'fixed';
          // При первом реальном движении конвертируем из right/top в left/top без скачка
          const r = target.getBoundingClientRect();
          target.style.left = r.left + 'px';
          target.style.top = r.top + 'px';
          target.style.right = 'auto';
        }
        function move(x,y){
          if(!dragging) return;
          const dx = x - sx; const dy = y - sy;
          if (!activeDrag){
            if (Math.abs(dx) < 4 && Math.abs(dy) < 4) return; // порог, чтобы клик не считался перетаскиванием
            activeDrag = true;
            ensureFixedAnchor();
          }
          const nx = ox + dx; const ny = oy + dy;
          target.style.left = nx+'px';
          target.style.top = ny+'px';
        }
        function end(){ if(!dragging) return; dragging=false; if (activeDrag) save(); activeDrag=false; }
        target.addEventListener('mousedown', e=>{ if(e.button!==0) return; start(e.clientX, e.clientY); e.preventDefault(); });
        document.addEventListener('mousemove', e=> move(e.clientX, e.clientY));
        document.addEventListener('mouseup', end);
        target.addEventListener('touchstart', e=>{ const t=e.touches[0]; if(t) start(t.clientX, t.clientY); }, {passive:true});
        document.addEventListener('touchmove', e=>{ const t=e.touches[0]; if(t) move(t.clientX, t.clientY); }, {passive:true});
        document.addEventListener('touchend', end);
      })();

      updateRing();
      // Изначально скрываем цифру, если на паузе
      try{ if (paused && text) text.style.display = 'none'; }catch{}
      rafId = requestAnimationFrame(tick);

      // Глобальный хук для сброса таймера к 60 сек по кнопке "Удалить все"
      try{
        document.addEventListener('click', function(e){
          try{
            const t = e.target;
            if (t && t.tagName === 'BUTTON'){
              const label = (t.textContent||'').trim().toLowerCase();
              if (label.includes('удалить все')){
                localStorage.removeItem(TIMER_LS_KEY);
                duration = getTimerDuration();
                remaining = duration;
                updateRing();
                showToast('Таймер: по умолчанию 60 сек');
              }
            }
          }catch{}
        });
      }catch{}
    }catch(e){ console.warn('Timer init failed', e); }
  })();

  // ===== Moves Tab Logic =====
  function getMoveState(){
    const d = LS.load('cf_moves_state', null);
    if (d && typeof d==='object') return d;
    return { dice: null, card: null, cashflowDone: null, creditTaken: false, creditChoice: null, balance: 0, monthly: 0, comment: '', events: [], autoCashflow: false, checksPassed: 0, doubleCashflowChoice: null };
  }
  // Post-turn helpers
  function getPostTurn(){
    const d = LS.load('cf_post_turn', null);
    return (d && typeof d==='object') ? d : null;
  }
  function setPostTurn(v){ LS.save('cf_post_turn', v); }
  function clearPostTurn(){ try{ localStorage.removeItem('cf_post_turn'); }catch{} }
  function addPostTurnEvent(delta, desc){
    try{
      let p = getPostTurn();
      if (!p) return;
      if (!Array.isArray(p.events)) p.events = [];
      const d = Math.round(parseFloat(delta)||0);
      p.events.unshift({ time: Date.now(), delta: d, desc: String(desc||'') });
      setPostTurn(p);
    }catch{}
  }
  function setMoveState(s){ LS.save('cf_moves_state', s); }
  function addTurnEventForCurrentTurn(delta, desc){
    try{
      const st = getMoveState();
      if (!Array.isArray(st.events)) st.events = [];
      const d = Math.round(parseFloat(delta)||0);
      if (d !== 0){
        st.events.unshift({ time: Date.now(), delta: d, desc: String(desc||'') });
        setMoveState(st);
      }
    }catch{}
  }
  
  // Новая функция для добавления операций в историю ходов
  function addOperationToTurnsHistory(type, desc, delta = 0, additionalData = {}) {
    try {
      const currentTurn = parseInt(localStorage.getItem('cf_turn_number') || '1', 10) || 1;
      const turns = getTurns();
      
      // Ищем текущий ход или создаем новую запись
      let currentTurnRecord = turns.find(t => t.num === currentTurn && !t.post);
      
      if (!currentTurnRecord) {
        // Если текущий ход не найден, создаем его
        currentTurnRecord = {
          num: currentTurn,
          dice: null,
          card: 'Не завершен',
          cardChoice: null,
          cashflowDone: null,
          monthly: Math.round(ensureMonthlyFromLedger()),
          creditTaken: false,
          credit: '',
          balance: Math.round(getMoveState()?.balance || 0),
          capital: Math.round((getMoveState()?.balance || 0) + computeCapitalFromCurrentState().invested + computeCapitalFromCurrentState().payoff),
          balanceChange: 0,
          time: Date.now(),
          timeFormatted: new Date().toLocaleString(),
          events: [],
          comment: '',
          operations: [] // Новое поле для операций
        };
        turns.unshift(currentTurnRecord);
      }
      
      // Добавляем операцию
      if (!Array.isArray(currentTurnRecord.operations)) {
        currentTurnRecord.operations = [];
      }
      
      // Извлекаем дельту из описания, если она не передана
      let extractedDelta = delta;
      if (delta === 0 && desc) {
        const deltaMatch = desc.match(/([+-]?[\d\s]+(?:[.,]\d{3})*)\s*\$/);
        if (deltaMatch) {
          const amount = deltaMatch[1].replace(/\s/g, '').replace(/\.(?=\d{3}(\D|$))/g, '').replace(/,(?=\d{3}(\D|$))/g, '');
          extractedDelta = parseFloat(amount.replace(',', '.'));
        }
      }
      
      const operation = {
        time: Date.now(),
        timeFormatted: new Date().toLocaleString(),
        type: type,
        desc: desc,
        delta: extractedDelta,
        ...additionalData
      };
      
      currentTurnRecord.operations.unshift(operation);
      
      // Обновляем время хода на самое позднее
      currentTurnRecord.time = Math.max(currentTurnRecord.time, operation.time);
      currentTurnRecord.timeFormatted = new Date(currentTurnRecord.time).toLocaleString();
      
      setTurns(turns);
      
      // Обновляем отображение
      try { renderTurnsHistory(); } catch {}
      
    } catch (e) {
      console.warn('Ошибка при добавлении операции в историю ходов:', e);
    }
  }
  // Единая запись события по денежному потоку на ход: удаляем прежние и добавляем одну (если получено)
  function setCashflowEventForCurrentTurn(amount, received){
    try{
      const st = getMoveState();
      if (!Array.isArray(st.events)) st.events = [];
      st.events = st.events.filter(ev => !String(ev.desc||'').includes('Денежный поток'));
      if (received && (Math.round(amount)||0) > 0){
        st.events.unshift({ time: Date.now(), delta: Math.round(amount), desc: 'Денежный поток' });
      }
      setMoveState(st);
    }catch{}
  }
  function updateTopBalance(){
    try{
      const st = getMoveState();
      const balance = Math.round(st.balance||0);
      // Показываем минус для отрицательных значений
      const sign = balance < 0 ? '-' : '';
      const absBalance = Math.abs(balance);
      const balanceText = `${sign}${fmtPretty(absBalance,0)} $`;
      
      // Обновляем баланс для мобильной версии
      const el = document.getElementById('balanceTop');
      if (el) {
        el.textContent = balanceText;
        // Устанавливаем цвет: красный для отрицательных значений
        el.style.color = balance < 0 ? '#c33' : '#222';
      }
      
      // Обновляем баланс для десктопной версии
      const elDesktop = document.getElementById('balanceTopDesktop');
      if (elDesktop) {
        elDesktop.textContent = balanceText;
        // Устанавливаем цвет: красный для отрицательных значений
        elDesktop.style.color = balance < 0 ? '#c33' : '#222';
      }
    }catch{}
  }
  function ensureMonthlyFromLedger(){
    try{
      const totals = computeTotals();
      // cashflow = totalIncome - totalExpense
      const monthly = (totals.totalIncome||0) - (totals.totalExpense||0);
      return monthly;
    }catch{ return 0; }
  }
  function renderMoves(){
    try{
      const st = getMoveState();
      const post = getPostTurn();
      // Intro/top controls: Start Balance and Intro Text
      try{
        const movesSec = document.getElementById('moves');
        const headerEl = document.getElementById('movesHeader');
        let intro = document.getElementById('movesIntroTop');
        if (!intro){
          intro = document.createElement('div');
          intro.id = 'movesIntroTop';
          intro.style.margin = '0 0 10px 0';
          intro.style.background = '#f8f9fa';
          intro.style.border = '1px solid #e9ecef';
          intro.style.borderRadius = '8px';
          intro.style.padding = '10px';
          if (movesSec && headerEl) movesSec.insertBefore(intro, headerEl);
        }
        // Render controls
        const introText = localStorage.getItem('cf_intro_text') || '';
        intro.innerHTML = `
          <div style="display:flex;flex-wrap:wrap;gap:10px;align-items:flex-end">
            <div style="flex:0 0 220px">
              <label style="display:block;font-size:12px;color:#666;margin-bottom:4px">Стартовый баланс $</label>
              <input id="startBalanceInput" type="number" step="0.01" placeholder="Сумма" style="width:100%;padding:6px 8px;font-size:14px">
            </div>
            <div style="flex:0 0 auto">
              <button class="btn" id="startBalanceSet" style="padding:6px 10px;font-size:14px">Установить</button>
            </div>
          </div>
          <div style="margin-top:10px">
            <label style="display:block;font-size:12px;color:#666;margin-bottom:4px">Вступительный текст <span style="font-size:11px;color:#999;font-weight:normal">(кликните для раскрытия)</span></label>
            <textarea id="introText" rows="4" placeholder="Текст, который сохранится" style="width:100%;box-sizing:border-box;padding:6px 8px;font-size:14px;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',sans-serif;resize:vertical;transition:all 0.3s ease;overflow:hidden;" data-expanded="false"></textarea>
          </div>`;
        const sb = document.getElementById('startBalanceInput');
        if (sb) sb.value = String(Math.round(st.balance||0));
        const sbSet = document.getElementById('startBalanceSet');
        if (sbSet && !sbSet._wired){
          sbSet._wired = true;
          sbSet.onclick = ()=>{
            try{
              const v = Math.round(parseFloat(document.getElementById('startBalanceInput')?.value||'0'))||0;
              const ns = getMoveState();
              ns.balance = v; setMoveState(ns); updateTopBalance(); renderMoves();
            }catch{}
          };
        }
        const it = document.getElementById('introText');
        if (it) it.value = introText;
        if (it && !it._wired){
          it._wired = true;
          it.oninput = ()=>{
            try{ localStorage.setItem('cf_intro_text', document.getElementById('introText').value||''); }catch{}
          };
          
          // Функциональность раскрытия/сворачивания поля
          it.addEventListener('focus', function() {
            if (this.getAttribute('data-expanded') === 'false') {
              this.setAttribute('data-expanded', 'true');
              this.style.rows = '14';
              this.style.overflow = 'visible';
              this.style.height = '350px';
              this.style.minHeight = '350px';
              this.style.maxHeight = 'none';
              this.style.zIndex = '1000';
              this.style.position = 'relative';
              console.log('Поле раскрыто на 14 строк'); // Отладочная информация
            }
          });
          
          // Обработчик клика вне поля
          document.addEventListener('click', function(e) {
            if (e.target !== it && !it.contains(e.target)) {
              if (it.getAttribute('data-expanded') === 'true') {
                it.setAttribute('data-expanded', 'false');
                it.style.rows = '4';
                it.style.overflow = 'hidden';
                it.style.height = 'auto';
                it.style.minHeight = 'auto';
                it.style.maxHeight = 'none';
                it.style.zIndex = 'auto';
                it.style.position = 'static';
                console.log('Поле свернуто к 4 строкам'); // Отладочная информация
              }
            }
          });
          
          // Обработчик клавиши Escape для сворачивания поля
          document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape' && it.getAttribute('data-expanded') === 'true') {
              it.setAttribute('data-expanded', 'false');
              it.style.rows = '4';
              it.style.overflow = 'hidden';
              it.style.height = 'auto';
              it.style.minHeight = 'auto';
              it.style.maxHeight = 'none';
              it.style.zIndex = 'auto';
              it.style.position = 'static';
              it.blur(); // Убираем фокус с поля
              console.log('Поле свернуто по Escape'); // Отладочная информация
            }
          });
        }
        // Показ/скрытие: только на первом ходу
        try{
          const tnum = parseInt(localStorage.getItem('cf_turn_number')||'1',10) || 1;
          intro.style.display = (tnum === 1) ? '' : 'none';
        }catch{}
      }catch{}
      
      // Обработчик кнопки "Пропуск хода"
      const skipTurnBtn = document.getElementById('skipTurnBtn');
      if (skipTurnBtn && !skipTurnBtn._wired) {
        skipTurnBtn._wired = true;
        skipTurnBtn.onclick = () => {
          if (confirm('Вы уверены, что хотите пропустить этот ход? Все несохраненные данные будут потеряны.')) {
            // Сбрасываем состояние хода (берём актуальное состояние, а не захваченную копию)
            const curr = getMoveState();
            // Восстановим позицию: при пропуске хода позиция НЕ меняется — возвращаемся на startIndex этого хода
            try {
              const t0 = getTurnState();
              if (typeof t0.startIndex === 'number') {
                const tFix = getTurnState();
                tFix.pos = t0.startIndex >= 0 ? t0.startIndex : 0;
                tFix.passedCheck = false;
                setTurnState(tFix);
              }
            } catch {}
            // Восстановим баланс/поток на значения начала хода
            const __fallbackMonthly = Math.round(curr.monthly || ensureMonthlyFromLedger());
            const restoredMonthly = (typeof curr.startMonthly === 'number') ? curr.startMonthly : __fallbackMonthly;
            let restoredBalance;
            if (typeof curr.startBalance === 'number') {
              // Если знаем баланс на начало хода — берём его без дополнительных вычитаний
              restoredBalance = curr.startBalance;
            } else {
              // Иначе стартовый баланс не известен: откатываем текущее состояние на величину фактически зачисленной суммы
              restoredBalance = Math.round(curr.balance||0);
              try {
                const credited = Math.round(curr.cashflowCredited || 0);
                if (credited > 0) {
                  restoredBalance = Math.round(restoredBalance - credited);
                }
              } catch {}
            }
            const next = { dice:null, card:null, cardChoice:null, dealType:null, cashflowDone:null, creditTaken:false, creditChoice:null, balance: restoredBalance, monthly: restoredMonthly, events: [] };
            setMoveState(next);
            // Фиксируем запись в истории ходов как "Пропуск хода"
            try {
              const numNow = parseInt(localStorage.getItem('cf_turn_number')||'1',10) || 1;
              const stNow = getMoveState();
              const rec = { num: numNow, card: 'Пропуск хода', balance: Math.round(restoredBalance||0), time: Date.now(), post: true, skip: true, events: [] };
              const turns = getTurns(); turns.unshift(rec); setTurns(turns);
              
              // Записываем в историю ходов пропуск хода
              try{ addTurnEventForCurrentTurn(0, `Пропуск хода ${numNow}`); }catch{}
              try{ renderTurnsHistory(); }catch{}
            } catch{}
            
            // Увеличиваем номер хода
            const currentTurn = parseInt(localStorage.getItem('cf_turn_number')||'1',10) || 1;
            localStorage.setItem('cf_turn_number', String(currentTurn + 1));
            try{ renderTurnsHistory(); }catch{}
            
            // Сбрасываем стартовую точку для нового хода
            const t = getTurnState(); 
            t.startIndex = t.pos; 
            setTurnState(t);
            
            // Включаем режим "После хода" и перерисовываем интерфейс
            try{ setPostTurn({ num: currentTurn, events: [] }); }catch{}
            renderMoves();
            
            // Показываем уведомление
            try {
              const prev = currentTurn; // это номер только что пропущенного хода
              showToast(`Ход ${prev} пропущен`, 500);
            } catch {}
          }
        };
      }
      
      // Controls
      const diceWrap = document.getElementById('diceChoices');
      if (!diceWrap) return;

      // If in post-turn mode — hide steps and show "После хода"
      const movesListEl = document.querySelector('.moves-list');
      const movesTimerWrap = document.querySelector('.moves-timer-wrap');
      const floatTimerWrap = document.getElementById('cfTimerWrap');
      // Ensure post-turn UI exists (place it ABOVE history area, before anchor)
      let postWrap = document.getElementById('postTurnWrap');
      if (!postWrap){
        postWrap = document.createElement('div');
        postWrap.id = 'postTurnWrap';
        postWrap.style.display = 'none';
        postWrap.style.margin = '10px 0';
      }
      // Always ensure it's positioned right above the history block
      try{
        const histEl = document.getElementById('postTurnAnchor');
        if (histEl && histEl.parentNode) {
          if (postWrap.parentNode !== histEl.parentNode || postWrap.nextSibling !== histEl) {
            histEl.parentNode.insertBefore(postWrap, histEl);
          }
        } else {
          // Fallback: append to moves section
          const host = document.getElementById('moves');
          if (host && postWrap.parentNode !== host) host.appendChild(postWrap);
        }
      }catch{}
      if (post){
        // Hide timers and moves list
        if (movesTimerWrap) movesTimerWrap.style.display = 'none';
        if (movesListEl) movesListEl.style.display = 'none';
        if (floatTimerWrap) floatTimerWrap.style.display = 'none';
        const nextTurn = parseInt(localStorage.getItem('cf_turn_number')||'1',10)||1;
        const prevTurn = post.num || (nextTurn-1);
        postWrap.style.display = 'block';
        postWrap.innerHTML = `
          <div style=\"border:1px solid #eee;background:#fff;border-radius:8px;padding:12px\">
            <div style=\"display:flex;justify-content:space-between;align-items:center;margin-bottom:8px\">
              <div style=\"font-weight:700\">После хода ${prevTurn}</div>
              <div style=\"display:flex;align-items:center;gap:8px\">
                <div style=\"display:flex;flex-direction:column;align-items:center;gap:2px\">
                  <input type=\"number\" id=\"postTurnNextDur\" min=\"5\" max=\"600\" step=\"5\" value=\"${parseInt(localStorage.getItem('cf_timer_duration_sec')||'60',10) || 60}\" style=\"width:64px;padding:4px 6px;font-size:12px;text-align:center;border:1px solid #ddd;border-radius:8px\"/>
                  <div style=\"font-size:10px;color:#666\">сек</div>
                </div>
                <button class=\"btn\" id=\"fullscreenTurnBtn\" style=\"margin-right:8px;padding:8px 12px;font-size:18px;background:#4a90e2;color:#fff;border:1px solid #357abd;border-radius:8px;cursor:pointer;min-width:50px;height:50px;display:flex;align-items:center;justify-content:center;transition:all 0.3s ease;\" title=\"Полноэкранный режим\" onmouseover=\"this.style.background='#357abd'; this.style.transform='scale(1.05)'\" onmouseout=\"this.style.background='#4a90e2'; this.style.transform='scale(1)'\">⛶</button>
                <button class=\"btn\" id=\"startNextTurnBtn\">Начать Ход ${nextTurn}</button>
              </div>
            </div>
            <div class=\"row\" style=\"display:flex;gap:6px;align-items:center;flex-wrap:wrap\">
              <input type=\"number\" id=\"postDelta\" step=\"0.01\" placeholder=\"± Сумма $\" style=\"width:160px;padding:6px 8px;font-size:14px\">
              <input type=\"text\" id=\"postComment\" placeholder=\"Комментарий (к записи изменения)\" style=\"flex:1;min-width:160px;padding:6px 8px;font-size:14px;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',sans-serif\">
              <button class=\"btn\" id=\"postApply\" style=\"padding:6px 10px;font-size:14px\">Применить</button>
            </div>
            <div id=\"postTurnCommentWrap\" style=\"background:#fffef7;border:1px solid #f3e0b3;border-radius:8px;padding:8px;margin:10px 0\">
              <div style=\"margin-bottom:6px;font-weight:600\">Комментарий после хода</div>
              <textarea id=\"postTurnComment\" rows=\"5\" placeholder=\"Комментарий после хода\" style=\"width:100%;box-sizing:border-box;padding:6px 8px;font-size:14px;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',sans-serif;resize:vertical\"></textarea>
            </div>
            <div style=\"display:flex;justify-content:space-between;gap:8px;margin-top:10px;flex-wrap:wrap\">
              <div style=\"display:flex;gap:6px;align-items:center\">
                <button class=\"btn\" id=\"postBalanceAdjustBtn\" title=\"Установить баланс вручную\" style=\"padding:6px 10px;font-size:14px;background:#c33\">Корректировка баланса</button>
              </div>
            </div>
          </div>`;
        // Wire handlers
        try{
          const postApply = document.getElementById('postApply');
          const postDelta = document.getElementById('postDelta');
          const postComment = document.getElementById('postComment');
          const postTurnComment = document.getElementById('postTurnComment');
          const postAdjBtn = document.getElementById('postBalanceAdjustBtn');
          const stNow = getMoveState();
          // no input field now
          // hydrate post-turn comment
          try{ if (postTurnComment) postTurnComment.value = String(post.comment||''); }catch{}
          if (postTurnComment){
            postTurnComment.oninput = ()=>{
              const p = getPostTurn() || { num: prevTurn, events: [] };
              p.comment = String(postTurnComment.value||'');
              setPostTurn(p);
            };
          }
          if (postApply){
            postApply.onclick = ()=>{
              const v = Math.round(parseFloat(postDelta.value)||0);
              const c = (postComment.value||'').trim();
              const ns2 = getMoveState();
              ns2.balance = Math.round((ns2.balance||0) + v);
              setMoveState(ns2);
              addPostTurnEvent(v, c?`После хода — ${c}`:'После хода');
              try{ renderTurnsHistory(); }catch{}
              postDelta.value=''; postComment.value='';
              renderMoves();
            };
          }
          if (postAdjBtn){
            postAdjBtn.onclick = ()=>{
              const cur = Math.round((getMoveState().balance)||0);
              const input = prompt('Установить баланс на сумму ($):', String(cur));
              if (input===null) return;
              const v = Math.round(parseFloat(String(input).replace(',', '.'))||0);
              const ns2 = getMoveState();
              const prev = Math.round(ns2.balance||0);
              ns2.balance = v; setMoveState(ns2);
              const diff = Math.round(v - prev);
              if (diff !== 0) {
                const action = diff > 0 ? 'Начисление' : 'Списание';
                addPostTurnEvent(diff, `После хода — Корректировка баланса: ${action} ${Math.abs(diff)}$`);
              }
              try{ renderTurnsHistory(); }catch{}
              renderMoves();
            };
          }
          const startBtn = document.getElementById('startNextTurnBtn');
          if (startBtn){
            startBtn.onclick = ()=>{
              // Сохраняем выбранную длительность для следующих ходов
              try{
                const inp = document.getElementById('postTurnNextDur');
                if (inp){
                  const v = parseInt(inp.value||'60',10);
                  const vv = Math.max(5, Math.min(600, isFinite(v)?v:60));
                  localStorage.setItem('cf_timer_duration_sec', String(vv));
                }
              }catch{}
              const st2 = getMoveState();
              const p = getPostTurn();
              // Рассчитываем капитал для записи "После хода"
              const capital = Math.round(st2.balance||0) + computeCapitalFromCurrentState().invested + computeCapitalFromCurrentState().payoff;
              // Рассчитываем изменение баланса за этот ход
              const balanceChange = (p && Array.isArray(p.events)) ? p.events.reduce((sum, ev) => sum + (ev.delta || 0), 0) : 0;
              const rec = { num: (p && p.num) ? p.num : (nextTurn-1), post: true, balance: Math.round(st2.balance||0), capital: capital, balanceChange: balanceChange, time: Date.now(), events: (p && Array.isArray(p.events))?p.events.slice(0,50):[], comment: (p && p.comment) ? String(p.comment) : '' };
              const turns = getTurns(); turns.unshift(rec); setTurns(turns);
              clearPostTurn();
              // Restore UI
              if (movesTimerWrap) movesTimerWrap.style.display = '';
              if (movesListEl) movesListEl.style.display = '';
              if (floatTimerWrap) floatTimerWrap.style.display = '';
              postWrap.style.display = 'none';
              // Hide banner if any
              try{ const b = document.getElementById('postTurnBanner'); if (b) b.style.display='none'; }catch{}
              renderTurnsHistory();
              renderMoves();
              // Reset and start timer on new turn
              try{ if (window.resetGlobalTimer) window.resetGlobalTimer(); }catch{}
              try{ document.getElementById('cfTimerPlay')?.click(); }catch{}
            };
          }
          
          // Обработчики для полноэкранного модального окна
          const fullscreenTurnBtn = document.getElementById('fullscreenTurnBtn');
          const fullscreenModal = document.getElementById('fullscreenTurnModal');
          const closeFullscreenModal = document.getElementById('closeFullscreenModal');
          const fullscreenStartTurnBtn = document.getElementById('fullscreenStartTurnBtn');
          const fullscreenTurnNumber = document.getElementById('fullscreenTurnNumber');
          
          if (fullscreenTurnBtn && !fullscreenTurnBtn._wired) {
            fullscreenTurnBtn._wired = true;
            fullscreenTurnBtn.onclick = () => {
              if (fullscreenModal) {
                // Обновляем номер хода в модальном окне
                if (fullscreenTurnNumber) {
                  fullscreenTurnNumber.textContent = nextTurn;
                }
                // Показываем модальное окно
                fullscreenModal.style.display = 'flex';
                // Добавляем анимацию появления
                setTimeout(() => {
                  fullscreenModal.style.opacity = '1';
                }, 10);
              }
            };
          }
          
          if (closeFullscreenModal && !closeFullscreenModal._wired) {
            closeFullscreenModal._wired = true;
            closeFullscreenModal.onclick = () => {
              if (fullscreenModal) {
                fullscreenModal.style.display = 'none';
              }
            };
          }
          
          if (fullscreenStartTurnBtn && !fullscreenStartTurnBtn._wired) {
            fullscreenStartTurnBtn._wired = true;
            fullscreenStartTurnBtn.onclick = () => {
              // Закрываем модальное окно
              if (fullscreenModal) {
                fullscreenModal.style.display = 'none';
              }
              // Выполняем ту же логику, что и обычная кнопка "Начать Ход"
              const startBtn = document.getElementById('startNextTurnBtn');
              if (startBtn && startBtn.onclick) {
                startBtn.onclick();
              }
            };
          }
          
          // Закрытие модального окна по клику на фон
          if (fullscreenModal && !fullscreenModal._wired) {
            fullscreenModal._wired = true;
            fullscreenModal.onclick = (e) => {
              if (e.target === fullscreenModal) {
                fullscreenModal.style.display = 'none';
              }
            };
          }
          
          // Закрытие модального окна по клавише Escape
          document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && fullscreenModal && fullscreenModal.style.display === 'flex') {
              fullscreenModal.style.display = 'none';
            }
          });
        }catch{}
        
        // Stop further rendering of steps while in post-turn mode
        // Also update top balance mirror
        updateTopBalance();
        return;
      } else {
        // Ensure steps are visible if not in post-turn mode
          if (movesTimerWrap) movesTimerWrap.style.display = '';
        if (movesListEl) movesListEl.style.display = '';
        if (floatTimerWrap) floatTimerWrap.style.display = '';
        if (postWrap) postWrap.style.display = 'none';
        try{ const b = document.getElementById('postTurnBanner'); if (b) b.style.display='none'; }catch{}

        // Добавляем спиннер длительности слева над крестиком большого таймера (во время хода)
        try{
          const host = movesTimerWrap;
          if (host && !document.getElementById('movesTimerDurationWrap')){
            host.style.position = host.style.position || 'relative';
            const box = document.createElement('div');
            box.id = 'movesTimerDurationWrap';
            box.style.position = 'absolute';
            box.style.left = '8px';
            box.style.top = '8px'; // Опускаем ниже, чтобы не перекрывать надпись "ход 9"
            box.style.display = 'flex';
            box.style.flexDirection = 'column';
            box.style.alignItems = 'center';
            box.style.gap = '2px';
            const val = parseInt(localStorage.getItem('cf_timer_duration_sec')||'60',10) || 60;
            box.innerHTML = `<input type="number" id="movesTimerDurInput" min="5" max="600" step="5" value="${val}" style="width:40px;padding:2px 4px;font-size:12px;text-align:center;border:1px solid #ddd;border-radius:4px;background:#fff"/>`+
                            `<div style="font-size:10px;color:#666">сек</div>`;
            host.appendChild(box);
            const inp = box.querySelector('#movesTimerDurInput');
            inp.addEventListener('change', ()=>{
              try{
                const v = parseInt(inp.value||'60',10);
                const vv = Math.max(5, Math.min(600, isFinite(v)?v:60));
                localStorage.setItem('cf_timer_duration_sec', String(vv));
                showToast(`Таймер: ${vv} сек`);
              }catch{}
            });
          }
          // Переключатель "Звук старта" в правом верхнем углу большого таймера
          if (host && !document.getElementById('movesTimerStartSoundWrap')){
            host.style.position = host.style.position || 'relative';
            const wrapLbl = document.createElement('label');
            wrapLbl.id = 'movesTimerStartSoundWrap';
            wrapLbl.style.position = 'absolute';
            wrapLbl.style.right = '8px';
            wrapLbl.style.top = '8px';
            wrapLbl.style.display = 'flex';
            wrapLbl.style.alignItems = 'center';
            wrapLbl.style.gap = '6px';
            wrapLbl.style.fontSize = '12px';
            wrapLbl.style.background = '#fff';
            wrapLbl.style.border = '1px solid #ddd';
            wrapLbl.style.borderRadius = '8px';
            wrapLbl.style.padding = '4px 8px';
            if (localStorage.getItem('cf_timerStartSoundEnabled') === null){
              try{ localStorage.setItem('cf_timerStartSoundEnabled', '1'); }catch{}
            }
            const enabled = (localStorage.getItem('cf_timerStartSoundEnabled') !== '0');
            wrapLbl.innerHTML = `<input type="checkbox" id="movesStartSoundToggle" ${enabled? 'checked':''} style="width:16px;height:16px">`+
                                `<span style="color:#444;user-select:none;">Звук старта</span>`;
            host.appendChild(wrapLbl);
            const chk = wrapLbl.querySelector('#movesStartSoundToggle');
            chk.addEventListener('change', ()=>{
              try{ localStorage.setItem('cf_timerStartSoundEnabled', chk.checked ? '1' : '0'); }catch{}
            });
          }
        }catch{}
      }

      // 1) Dice 1..12
      diceWrap.innerHTML = '';
      for (let i=1;i<=12;i++){
        const btn = document.createElement('button');
        btn.className = 'dice-btn' + (st.dice===i ? ' active':'' );
        btn.textContent = String(i);
        btn.onclick = ()=>{
          const ns = getMoveState();
          // Первый выбор в ходу фиксирует startIndex
          const turnNum = parseInt(localStorage.getItem('cf_turn_number')||'1',10) || 1;
          const t = getTurnState();
          if (ns.dice==null) {
            // Начало хода: если это самый первый ход, стартуем с -1 (вне доски)
            const startFrom = (turnNum===1) ? -1 : t.pos;
            t.startIndex = startFrom;
            setTurnState(t);
            // Сохраняем стартовый снимок баланса/потока на начало хода (для отмены при Пропуске)
            try{
              const ns0 = getMoveState();
              ns0.startBalance = Math.round(ns0.balance||0);
              ns0.startMonthly = Math.round(ensureMonthlyFromLedger());
              setMoveState(ns0);
            }catch{}
          }
          // Сбрасываем счетчик чеков при каждом новом броске
          const prevDice = ns.dice;
          ns.dice = i; 
          // Если это новый бросок (dice изменился), сбрасываем счетчик чеков и устанавливаем выборы по умолчанию
          if (prevDice !== i) {
            // Отменяем предыдущее зачисление денежного потока, если оно было
            if (ns.cashflowDone === true) {
              const credited = Math.round(ns.cashflowCredited || 0);
              if (credited > 0) {
                ns.balance = Math.round((ns.balance||0) - credited);
              }
            }
            
            ns.checksPassed = 0;
            // Автоматически выбираем "Взял" карточку по умолчанию
            ns.card = 'Взял';
            ns.cardChoice = true;
            ns.dealType = 'small'; // Автоматически выбираем "Мелкая" сделку по умолчанию
            ns.cashflowDone = null; // Сбрасываем выбор денежного потока для последующего автоматического выбора
            ns.doubleCashflowChoice = null; // Сбрасываем выбор двойного потока
            ns.cashflowCredited = 0; // Сбрасываем зачисленную сумму
          }
          setMoveState(ns);
          const info = getBoardInfo(ns, i);
          // Текст: из какой в какую и что с чеком
          const prevName = (info.oldPos<0) ? 'Старт' : BOARD_CELLS[info.oldPos];
          const titleMap = { 'СД':'Сделка','ВС':'Всячина','БЛ':'Благотворительность','ЧК':'Расчётный чек','РЫ':'Рынок','РБ':'Ребёнок','УВ':'Увольнение' };
          const prevFull = (info.oldPos<0) ? 'Старт' : (titleMap[prevName] || prevName);
          const toFull = info.cellName;
          const chkTxt = (info.cellAbbr==='ЧК') ? ' (наступил на Чек)' : (info.passedCheck ? ' (пройден Чек)' : '');
          document.getElementById('diceSelected').textContent = `Выпало: ${i}. ${prevFull} → ${toFull}${chkTxt}`;
          document.getElementById('move1').classList.add('done');
          
          // Записываем в историю ходов бросок кубика
          try{ addTurnEventForCurrentTurn(0, `Кубик: ${i} (${prevFull} → ${toFull})`); }catch{}
          try{ renderTurnsHistory(); }catch{}
          
          // Не скроллим наверх при завершении — просто обновим блок
          const scrollY = window.scrollY;
          renderMoves();
          
          // Автоматически выбираем денежный поток после рендера
          setTimeout(() => {
            try {
              const nsAuto = getMoveState();
              const turnState = getTurnState();
              const onCheck = (BOARD_CELLS[turnState.pos]==='ЧК');
              const passed = !!turnState.passedCheck || onCheck;
              const checksPassed = nsAuto.checksPassed || 0;
              const isDoubleCashflow = checksPassed >= 2;
              
              // Если чек пройден и выбор еще не сделан, автоматически выбираем
              if (passed && (nsAuto.cashflowDone === null || nsAuto.cashflowDone === undefined)) {
                if (isDoubleCashflow) {
                  // Для двойного чека автоматически выбираем "Получил 2" (второй поток)
                  const yes3 = document.getElementById('cashflowYes3');
                  if (yes3) {
                    yes3.click();
                  }
                } else {
                  // Для одинарного чека автоматически выбираем "Получил"
                  const yes = document.getElementById('cashflowYes');
                  if (yes) {
                    yes.click();
                  }
                }
              }
            } catch {}
          }, 200);
          
          try { window.scrollTo({ top: scrollY, behavior: 'instant' }); } catch {}
        };
        diceWrap.appendChild(btn);
      }
      document.getElementById('diceSelected').textContent = st.dice ? ('Выпало: '+st.dice) : '';
      if (st.dice) document.getElementById('move1').classList.add('done'); else document.getElementById('move1').classList.remove('done');

      // Draw board track
      drawBoardTrack();
      // Если это первый ход и старт не указан — показываем "Старт" как откуда
      try{
        const turnNum = parseInt(localStorage.getItem('cf_turn_number')||'1',10) || 1;
        const t = getTurnState();
        if (turnNum===1 && typeof t.startIndex !== 'number') { 
          t.startIndex = -1; 
          setTurnState(t); 
          
          // Добавляем запись стартовых данных в историю перед первым ходом
          const turns = getTurns();
          const startRecord = turns.find(tr => tr.num === 0 && tr.post === true);
          // Убираем автоматическое добавление стартовых данных
        }
      }catch{}

      // 2) Card choices (простые кнопки Взял/Не взял)
      const cardYes = document.getElementById('cardYes');
      const cardNo = document.getElementById('cardNo');
      const cardStatus = document.getElementById('cardStatus');
      
      // Кнопки доступны только после выбора кубика
      const canPick = st.dice != null;
      if (!canPick) { 
        try{ cardYes.setAttribute('disabled',''); cardNo.setAttribute('disabled',''); }catch{} 
      } else { 
        try{ cardYes.removeAttribute('disabled'); cardNo.removeAttribute('disabled'); }catch{} 
      }
      
      cardYes.onclick = ()=>{
        const ns = getMoveState();
        ns.card = 'Взял';
        ns.cardChoice = true;
        // сбрасываем выбор типа сделки на этом шаге, выбор появится ниже, если клетка — Сделка
        ns.dealType = null;
        setMoveState(ns);
        cardStatus.textContent = 'Карточка взята';
        document.getElementById('move2').classList.add('done');
        try{ cardYes.classList.add('active','btn-checkmark'); cardNo.classList.remove('active','btn-checkmark'); }catch{}
        
        // Записываем в историю ходов взятие карточки
        try{ addTurnEventForCurrentTurn(0, 'Карточка: Взял'); }catch{}
        try{ renderTurnsHistory(); }catch{}
        
        renderMoves();
      };
      
      cardNo.onclick = ()=>{
        const ns = getMoveState();
        ns.card = 'Не взял';
        ns.cardChoice = false;
        ns.dealType = null;
        setMoveState(ns);
        cardStatus.textContent = 'Карточка не взята';
        document.getElementById('move2').classList.add('done');
        try{ cardYes.classList.remove('active','btn-checkmark'); cardNo.classList.add('active','btn-checkmark'); }catch{}
        
        // Записываем в историю ходов отказ от карточки
        try{ addTurnEventForCurrentTurn(0, 'Карточка: Не взял'); }catch{}
        try{ renderTurnsHistory(); }catch{}
        
        renderMoves();
      };
      
      // Подсветка кнопок в зависимости от выбора
      try{
        const turnNow2 = getTurnState();
        const isNoCardCell2 = (BOARD_CELLS[turnNow2.pos]==='ЧК' || BOARD_CELLS[turnNow2.pos]==='РБ' || BOARD_CELLS[turnNow2.pos]==='УВ');
        // Рекомендация: если не выбор сделан
        // Рекомендация: по умолчанию "Взял" пунктиром, пока не выбран вариант
        const notChosen = (st.cardChoice === null || st.cardChoice === undefined);
        cardYes.classList.toggle('recommend', notChosen && !isNoCardCell2);
        // Если нажали "Не взял" — обе без рекомендации
        if (st.cardChoice === false){ cardYes.classList.remove('recommend'); cardNo.classList.remove('recommend'); }
        // Активность — только по факту клика
        cardYes.classList.toggle('active', st.cardChoice === true);
        cardNo.classList.toggle('active', st.cardChoice === false);
        cardYes.classList.remove('btn-checkmark');
        cardNo.classList.remove('btn-checkmark');
      }catch{}
      
      if (st.cardChoice !== null && st.cardChoice !== undefined) {
        document.getElementById('move2').classList.add('done');
      } else {
        document.getElementById('move2').classList.remove('done');
      }

      // UI выбора типа сделки (Мелкая/Крупная) и статус карточки
      try {
        const move2El = document.getElementById('move2');
        const turnNow = getTurnState();
        const cellAbbr = BOARD_CELLS[turnNow.pos];
        const titleMap = { 'СД':'Сделка','ВС':'Всячина','БЛ':'Благотворительность','ЧК':'Расчётный чек','РЫ':'Рынок','РБ':'Ребёнок','УВ':'Увольнение' };
        const cellName = titleMap[cellAbbr] || cellAbbr;
        const isDeal = (cellAbbr === 'СД');
        const isNoCardCell = (cellAbbr === 'ЧК' || cellAbbr === 'РБ' || cellAbbr === 'УВ');

        // контейнер для кнопок типа сделки
        let dealWrap = document.getElementById('dealTypeWrap');
        if (!dealWrap) {
          dealWrap = document.createElement('div');
          dealWrap.id = 'dealTypeWrap';
          dealWrap.style.marginTop = '8px';
          move2El.appendChild(dealWrap);
        }

        // Для клеток без карточки (ЧК/РБ/УВ) НЕ автопроставляем выбор — оставляем кнопки видимыми,
        // чтобы следующий шаг (денежный поток) стал доступен только после явного клика "Взял/Не взял"
        try{
          const yesNoWrap = move2El.querySelector('div');
          if (isNoCardCell) { /* noop: держим блок видимым */ }
          if (yesNoWrap) yesNoWrap.style.display = '';
          if (isNoCardCell) { cardStatus.textContent = `Карточка: ${cellName}`; }
        }catch{}
        // Показываем/скрываем в зависимости от условий
        if (st.cardChoice === true && isDeal) {
          // Кнопки выбора типа сделки
          if (!document.getElementById('dealSmallBtn')) {
            const smallBtn = document.createElement('button');
            smallBtn.className = 'card-btn';
            smallBtn.id = 'dealSmallBtn';
            smallBtn.textContent = 'Мелкая';
            smallBtn.style.marginRight = '6px';
            smallBtn.onclick = ()=>{
              const ns = getMoveState();
              ns.dealType = 'small';
              setMoveState(ns);
              try{
                document.getElementById('dealSmallBtn').classList.add('active','btn-checkmark');
                document.getElementById('dealLargeBtn').classList.remove('active','btn-checkmark');
              }catch{}
              const st2 = getMoveState();
              const cs = document.getElementById('cardStatus');
              if (cs) cs.textContent = 'Сделка: мелкая';
            };
            dealWrap.appendChild(smallBtn);
          }
          if (!document.getElementById('dealLargeBtn')) {
            const largeBtn = document.createElement('button');
            largeBtn.className = 'card-btn';
            largeBtn.id = 'dealLargeBtn';
            largeBtn.textContent = 'Крупная';
            largeBtn.onclick = ()=>{
              const ns = getMoveState();
              ns.dealType = 'large';
              setMoveState(ns);
              try{
                document.getElementById('dealLargeBtn').classList.add('active','btn-checkmark');
                document.getElementById('dealSmallBtn').classList.remove('active','btn-checkmark');
              }catch{}
              const cs = document.getElementById('cardStatus');
              if (cs) cs.textContent = 'Сделка: крупная';
            };
            dealWrap.appendChild(largeBtn);
          }
          // Обновляем подсветку по сохранённому выбору
          const dType = getMoveState().dealType;
          document.getElementById('dealSmallBtn').classList.toggle('active', dType==='small');
          document.getElementById('dealSmallBtn').classList.toggle('btn-checkmark', dType==='small');
          document.getElementById('dealLargeBtn').classList.toggle('active', dType==='large');
          document.getElementById('dealLargeBtn').classList.toggle('btn-checkmark', dType==='large');
          // Текст статуса
          if (dType === 'small') cardStatus.textContent = 'Сделка: мелкая';
          else if (dType === 'large') cardStatus.textContent = 'Сделка: крупная';
          else cardStatus.textContent = 'Выберите сделку: мелкая или крупная';
          dealWrap.style.display = '';
        } else {
          // Не сделка — скрываем блок и пишем тип карточки по клетке
          dealWrap.style.display = 'none';
          if (st.cardChoice === true) {
            cardStatus.textContent = `Карточка: ${cellName}`;
          }
        }
      } catch{}
      // 3) Cashflow grant (только после выбора кубика)
      const yes = document.getElementById('cashflowYes');
      const yes2 = document.getElementById('cashflowYes2');
      const yes3 = document.getElementById('cashflowYes3');
      const no = document.getElementById('cashflowNo');
      const applied = document.getElementById('cashflowApplied');
      const monthly = ensureMonthlyFromLedger();
      const balanceEl = document.getElementById('gameBalance');
      const monthlyEl = document.getElementById('gameCashflow');
      if (monthlyEl) monthlyEl.textContent = fmtPretty(Math.round(ensureMonthlyFromLedger()), 0);
      if (balanceEl) {
        const balance = Math.round(st.balance||0);
        // Показываем минус для отрицательных значений
        const sign = balance < 0 ? '-' : '';
        const absBalance = Math.abs(balance);
        balanceEl.textContent = `${sign}${fmtPretty(absBalance,0)}`;
      }
      // Кнопки выдачи доступны только после выбора кубика и карточки, и только если пройден чек
      const turnState = getTurnState();
      const onCheck = (BOARD_CELLS[turnState.pos]==='ЧК');
      const passed = !!turnState.passedCheck || onCheck;
      const canCash = (st.dice != null) && (st.cardChoice !== null && st.cardChoice !== undefined);
      const canGetCash = canCash && passed;
      
      // Определяем количество пройденных чеков
      const checksPassed = st.checksPassed || 0;
      const isDoubleCashflow = checksPassed >= 2;
      
      // Скрываем/показываем кнопки в зависимости от количества чеков
      if (isDoubleCashflow) {
        yes.style.display = 'none';
        yes2.style.display = '';
        yes3.style.display = '';
        // Добавляем текст "Двойной Чек"
        const move3Title = document.querySelector('#move3 div');
        if (move3Title) {
          move3Title.innerHTML = '3) Выдача Денежного потока <span style="color:#c33;font-size:14px;">(Двойной Чек)</span>';
        }
      } else {
        yes.style.display = '';
        yes2.style.display = 'none';
        yes3.style.display = 'none';
        // Убираем текст "Двойной Чек"
        const move3Title = document.querySelector('#move3 div');
        if (move3Title) {
          move3Title.innerHTML = '3) Выдача Денежного потока';
        }
      }
      
      if (!canCash){ 
        try{ 
          yes.setAttribute('disabled',''); 
          yes2.setAttribute('disabled',''); 
          yes3.setAttribute('disabled',''); 
          no.setAttribute('disabled',''); 
        }catch{} 
      } else { 
        try{ 
          if (passed) {
            if (isDoubleCashflow) {
              yes2.removeAttribute('disabled');
              yes3.removeAttribute('disabled');
            } else {
              yes.removeAttribute('disabled');
            }
            // Разрешаем "Пропуск" только для отмены уже полученного потока (undo)
            if (st.cashflowDone === true) {
              no.removeAttribute('disabled');
            } else {
              no.setAttribute('disabled','');
            }
          } else {
            yes.setAttribute('disabled','');
            yes2.setAttribute('disabled','');
            yes3.setAttribute('disabled','');
            no.removeAttribute('disabled');
          }
        }catch{} 
      }
      yes.onclick = ()=>{
        const ns = getMoveState();
        if (ns.cashflowDone===true) {
          // Переключение на одиночный поток: пересчитываем баланс на разницу
          const base = Math.round(ensureMonthlyFromLedger());
          const prevCredited = Math.round(ns.cashflowCredited || 0);
          const newCredited = base;
          const diff = newCredited - prevCredited;
          if (diff !== 0) {
            ns.balance = Math.round((ns.balance||0) + diff);
          }
          ns.doubleCashflowChoice = 'single';
          ns.cashflowCredited = Math.round(newCredited);
          setMoveState(ns);
          applied.textContent = `Зачислено: +${fmtPretty(newCredited,0)} $`;
          try{ yes.classList.add('active','btn-checkmark'); yes2.classList.remove('active','btn-checkmark'); yes3.classList.remove('active','btn-checkmark'); }catch{}
          try{ if (typeof setCashflowEventForCurrentTurn==='function') setCashflowEventForCurrentTurn(newCredited, true); }catch{}
          try{ renderTurnsHistory(); }catch{}
          try{ updateTopBalance(); }catch{}
          renderMoves();
          return;
        } // prevent double add in same turn
        
        // Проверяем, был ли пройден чек
        const turnCheck = getTurnState();
        const onCheckCheck = (BOARD_CELLS[turnCheck.pos]==='ЧК');
        const passedCheck = !!turnCheck.passedCheck || onCheckCheck;
        
        if (!passedCheck) {
          alert('Нельзя получить денежный поток, если не было пройдено поле чек!');
          return;
        }
        
        try{ if (typeof ns.startBalance !== 'number') ns.startBalance = Math.round(ns.balance||0); if (typeof ns.startMonthly !== 'number') ns.startMonthly = Math.round(ensureMonthlyFromLedger()); }catch{}
        
        const m = Math.round(ensureMonthlyFromLedger());
        ns.balance = Math.round((ns.balance||0) + m);
        ns.cashflowDone = true;
        ns.monthly = m;
        ns.cashflowCredited = Math.round(m);
        setMoveState(ns);
        applied.textContent = `Зачислено: +${fmtPretty(m,0)} $`;
        document.getElementById('move3').classList.add('done');
        try{ yes.classList.add('active','btn-checkmark'); no.classList.remove('active','btn-checkmark'); }catch{}
        try{ if (typeof setCashflowEventForCurrentTurn==='function') setCashflowEventForCurrentTurn(m, true); }catch{}
        try{ renderTurnsHistory(); }catch{}
        
        renderMoves();
      };
      no.onclick = ()=>{
        const ns = getMoveState();
        // Если уже были выданы деньги в этом ходу — снимаем их назад
        if (ns.cashflowDone===true) {
          // Снимаем ровно ту сумму, которая была зачислена
          const credited = Math.round(ns.cashflowCredited || 0);
          if (credited > 0) {
            ns.balance = Math.round((ns.balance||0) - credited);
          }
          ns.cashflowDone = false;
          ns.doubleCashflowChoice = null; // Сбрасываем выбор двойного потока
          ns.cashflowCredited = 0;
          setMoveState(ns);
          applied.textContent = '';
          try{ if (typeof setCashflowEventForCurrentTurn==='function') setCashflowEventForCurrentTurn(0, false); }catch{}
        try{ renderTurnsHistory(); }catch{}
      } else {
        ns.cashflowDone = false; 
        ns.doubleCashflowChoice = null; // Сбрасываем выбор двойного потока
        ns.cashflowCredited = 0;
        setMoveState(ns);
        applied.textContent = '';
        try{ if (typeof setCashflowEventForCurrentTurn==='function') setCashflowEventForCurrentTurn(0, false); }catch{}
        try{ renderTurnsHistory(); }catch{}
      }
        const el=document.getElementById('move3'); if(el){ el.classList.add('dimmed'); el.classList.remove('done'); }
        try{ yes.classList.remove('active','btn-checkmark'); no.classList.add('active','btn-checkmark'); }catch{}
        renderMoves();
      };
      
      // Обработчик для кнопки "Получил 1" (первый денежный поток)
      yes2.onclick = ()=>{
        const ns = getMoveState();
        if (ns.cashflowDone===true) {
          // Переключение на двойной поток (первый): пересчитываем баланс на разницу
          const base = Math.round(ensureMonthlyFromLedger());
          const newCredited = base; // Получил 1 = одинарная сумма
          const prevCredited = Math.round(ns.cashflowCredited || 0);
          const diff = newCredited - prevCredited;
          if (diff !== 0) {
            ns.balance = Math.round((ns.balance||0) + diff);
          }
          ns.doubleCashflowChoice = 'first';
          ns.cashflowCredited = Math.round(newCredited);
          setMoveState(ns);
          applied.textContent = `Зачислено: +${fmtPretty(newCredited,0)} $`;
          try{ yes2.classList.add('active','btn-checkmark'); yes3.classList.remove('active','btn-checkmark'); yes.classList.remove('active','btn-checkmark'); }catch{}
          try{ if (typeof setCashflowEventForCurrentTurn==='function') setCashflowEventForCurrentTurn(newCredited, true); }catch{}
          try{ renderTurnsHistory(); }catch{}
          try{ updateTopBalance(); }catch{}
          renderMoves();
          return;
        } // prevent double add in same turn
        
        // Проверяем, был ли пройден чек
        const turnCheck = getTurnState();
        const onCheckCheck = (BOARD_CELLS[turnCheck.pos]==='ЧК');
        const passedCheck = !!turnCheck.passedCheck || onCheckCheck;
        
        if (!passedCheck) {
          alert('Нельзя получить денежный поток, если не было пройдено поле чек!');
          return;
        }
        
        try{ if (typeof ns.startBalance !== 'number') ns.startBalance = Math.round(ns.balance||0); if (typeof ns.startMonthly !== 'number') ns.startMonthly = Math.round(ns.monthly || ensureMonthlyFromLedger()); }catch{}
        
        const m = Math.round(ensureMonthlyFromLedger()); // Всегда используем оригинальный ежемесячный поток
        ns.balance = Math.round((ns.balance||0) + m);
        ns.cashflowDone = true;
        ns.doubleCashflowChoice = 'first'; // Отмечаем, что выбран первый поток
        ns.cashflowCredited = Math.round(m);
        // НЕ изменяем ns.monthly, оставляем оригинальный поток
        setMoveState(ns);
        applied.textContent = `Зачислено: +${fmtPretty(m,0)} $`;
        document.getElementById('move3').classList.add('done');
        try{ yes2.classList.add('active','btn-checkmark'); yes3.classList.remove('active','btn-checkmark'); no.classList.remove('active','btn-checkmark'); }catch{}
        try{ if (typeof setCashflowEventForCurrentTurn==='function') setCashflowEventForCurrentTurn(m, true); }catch{}
        try{ renderTurnsHistory(); }catch{}
        
        renderMoves();
      };
      
      // Обработчик для кнопки "Получил 2" (второй денежный поток)
      yes3.onclick = ()=>{
        const ns = getMoveState();
        if (ns.cashflowDone===true) {
          // Переключение на двойной поток (второй): пересчитываем баланс на разницу
          const base = Math.round(ensureMonthlyFromLedger());
          const newCredited = base * 2;
          const prevCredited = Math.round(ns.cashflowCredited || 0);
          const diff = newCredited - prevCredited;
          if (diff !== 0) {
            ns.balance = Math.round((ns.balance||0) + diff);
          }
          ns.doubleCashflowChoice = 'second';
          ns.cashflowCredited = Math.round(newCredited);
          setMoveState(ns);
          applied.textContent = `Зачислено: +${fmtPretty(newCredited,0)} $ (двойной)`;
          try{ yes3.classList.add('active','btn-checkmark'); yes2.classList.remove('active','btn-checkmark'); yes.classList.remove('active','btn-checkmark'); }catch{}
          try{ if (typeof setCashflowEventForCurrentTurn==='function') setCashflowEventForCurrentTurn(newCredited, true); }catch{}
          try{ renderTurnsHistory(); }catch{}
          try{ updateTopBalance(); }catch{}
          renderMoves();
          return;
        } // prevent double add in same turn
        
        // Проверяем, был ли пройден чек
        const turnCheck = getTurnState();
        const onCheckCheck = (BOARD_CELLS[turnCheck.pos]==='ЧК');
        const passedCheck = !!turnCheck.passedCheck || onCheckCheck;
        
        if (!passedCheck) {
          alert('Нельзя получить денежный поток, если не было пройдено поле чек!');
          return;
        }
        
        try{ if (typeof ns.startBalance !== 'number') ns.startBalance = Math.round(ns.balance||0); if (typeof ns.startMonthly !== 'number') ns.startMonthly = Math.round(ns.monthly || ensureMonthlyFromLedger()); }catch{}
        
        const m = Math.round(ensureMonthlyFromLedger()); // Всегда используем оригинальный ежемесячный поток
        const doubleM = m * 2; // Для двойного чека зачисляем двойную сумму
        ns.balance = Math.round((ns.balance||0) + doubleM);
        ns.cashflowDone = true;
        ns.doubleCashflowChoice = 'second'; // Отмечаем, что выбран второй поток
        ns.cashflowCredited = Math.round(doubleM);
        // НЕ изменяем ns.monthly, оставляем оригинальный поток
        setMoveState(ns);
        applied.textContent = `Зачислено: +${fmtPretty(doubleM,0)} $ (двойной)`;
        document.getElementById('move3').classList.add('done');
        try{ yes3.classList.add('active','btn-checkmark'); yes2.classList.remove('active','btn-checkmark'); no.classList.remove('active','btn-checkmark'); }catch{}
        try{ if (typeof setCashflowEventForCurrentTurn==='function') setCashflowEventForCurrentTurn(doubleM, true); }catch{}
        try{ renderTurnsHistory(); }catch{}
        
        renderMoves();
      };
      const move3El = document.getElementById('move3');
      if (move3El) {
        move3El.classList.toggle('done', st.cashflowDone===true);
        move3El.classList.toggle('dimmed', st.cashflowDone===false);
      }
      // Подсветка правильной кнопки в зависимости от Чека + авто-Пропуск при отсутствии Чека
      try{
        const turnHighlight = getTurnState();
        const onCheckHighlight = (BOARD_CELLS[turnHighlight.pos]==='ЧК');
        const passedHighlight = !!turnHighlight.passedCheck || onCheckHighlight;
        // Лейбл "Выдача Денежного потока" всегда видимый
        try{
          const titleEl = document.querySelector('#move3 > div');
          if (titleEl) titleEl.style.textDecoration = '';
        }catch{}
        // Если чек не пройден и выбор ещё не сделан — авто-проставляем Пропуск
        if (!passedHighlight && (st.cashflowDone===null || st.cashflowDone===undefined)){
          const nsAuto = getMoveState(); nsAuto.cashflowDone = false; setMoveState(nsAuto);
          try{ 
            yes.classList.remove('active','btn-checkmark'); 
            yes2.classList.remove('active','btn-checkmark'); 
            yes3.classList.remove('active','btn-checkmark'); 
            no.classList.add('active','btn-checkmark'); 
          }catch{}
          applied.textContent = '';
        }
        // Подсветку рекомендаций и текст показываем только если можно нажимать (после кубика и карточки)
        if (canCash){
          // Рекомендация: пунктирная обводка, пока не нажато
          if (st.cashflowDone!==true && st.cashflowDone!==false){
            if (isDoubleCashflow) {
              yes2.classList.toggle('recommend', passedHighlight);
              yes3.classList.toggle('recommend', passedHighlight);
            } else {
              yes.classList.toggle('recommend', passedHighlight);
            }
            no.classList.toggle('recommend', !passedHighlight);
          } else {
            yes.classList.remove('recommend');
            yes2.classList.remove('recommend');
            yes3.classList.remove('recommend');
            no.classList.remove('recommend');
          }
          
          // Подсветка активных кнопок
          if (isDoubleCashflow) {
            // Для двойного чека показываем активной только ту кнопку, которая была нажата
            yes2.classList.toggle('active', st.cashflowDone===true && st.doubleCashflowChoice === 'first');
            yes3.classList.toggle('active', st.cashflowDone===true && st.doubleCashflowChoice === 'second');
          } else {
            yes.classList.toggle('active', st.cashflowDone===true);
          }
          no.classList.toggle('active', st.cashflowDone===false);
          
          if (!st.cashflowDone && passedHighlight){
            const m = Math.round(ensureMonthlyFromLedger());
            if (isDoubleCashflow) {
              applied.textContent = `Рекомендуется получить: +${fmtPretty(m * 2,0)} $ (двойной)`;
            } else {
              applied.textContent = `Рекомендуется получить: +${fmtPretty(m,0)} $`;
            }
          } else {
            if (st.cashflowDone===true) {
              const mBase = Math.round(ensureMonthlyFromLedger());
              const creditedShown = Math.round(st.cashflowCredited || mBase);
              const isDoubleNow = creditedShown === mBase*2;
              applied.textContent = `Зачислено: +${fmtPretty(creditedShown,0)} $${isDoubleNow ? ' (двойной)' : ''}`;
            } else {
              applied.textContent = '';
            }
          }
        } else {
          yes.classList.remove('active');
          yes2.classList.remove('active');
          yes3.classList.remove('active');
          no.classList.remove('active');
          if (!st.cashflowDone && passedHighlight) {
            const m = Math.round(ensureMonthlyFromLedger());
            if (isDoubleCashflow) {
              applied.textContent = `Рекомендуется получить: +${fmtPretty(m * 2,0)} $ (двойной)`;
            } else {
              applied.textContent = `Рекомендуется получить: +${fmtPretty(m,0)} $`;
            }
          } else if (!st.cashflowDone) {
            applied.textContent = '';
          }
        }
      }catch{}
      // Значок $ справа от заголовка "Выдача Денежного потока" (только там), виден пока можно получить и ещё не получили
      try{
        const titleEl = document.querySelector('#move3 > div');
        if (titleEl){ titleEl.style.position = 'relative'; }
        let icon = document.getElementById('cashflowIconInline');
        if (!icon && titleEl){
          icon = document.createElement('span');
          icon.id = 'cashflowIconInline';
          icon.textContent = '$';
          icon.style.position = 'absolute';
          icon.style.right = '0';
          icon.style.top = '0';
          icon.style.color = '#22C55E';
          icon.style.fontSize = '66px';
          icon.style.lineHeight = '1';
          icon.style.display = 'none';
          titleEl.appendChild(icon);
        }
        if (icon){
          // Показываем знак доллара сразу после выбора кубика, если можно получить денежный поток
          const canShowIcon = canGetCash && st.cashflowDone !== true && st.dice !== null;
          icon.style.display = canShowIcon ? 'inline' : 'none';
        }
      }catch{}

      // 4) Credit (visible until taken)
      const creditBlock = document.getElementById('creditBlock');
      const creditStatus = document.getElementById('creditStatus');
      const creditYes = document.getElementById('creditYes');
      const creditNo = document.getElementById('creditNo');
      // Ensure input and confirm controls exist
      let creditSumInput = document.getElementById('creditSumInput');
      let creditConfirmBtn = document.getElementById('creditConfirmBtn');
      if (creditBlock && !creditSumInput) {
        creditSumInput = document.createElement('input');
        creditSumInput.type = 'number';
        creditSumInput.step = '0.01';
        creditSumInput.placeholder = 'Сумма кредита $';
        creditSumInput.id = 'creditSumInput';
        creditSumInput.style.width = '160px';
        creditSumInput.style.padding = '6px 8px';
        creditSumInput.style.fontSize = '14px';
        creditSumInput.style.display = 'none';
        creditBlock.appendChild(creditSumInput);
      }
      if (creditBlock && !creditConfirmBtn) {
        creditConfirmBtn = document.createElement('button');
        creditConfirmBtn.className = 'btn';
        creditConfirmBtn.id = 'creditConfirmBtn';
        creditConfirmBtn.textContent = 'Подтвердить';
        creditConfirmBtn.style.padding = '6px 10px';
        creditConfirmBtn.style.fontSize = '14px';
        creditConfirmBtn.style.display = 'none';
        creditBlock.appendChild(creditConfirmBtn);
      }
      // Handlers
      creditYes.onclick = ()=>{
        const ns = getMoveState();
        ns.creditTaken = true; ns.creditChoice = true; setMoveState(ns);
        if (creditSumInput) { creditSumInput.style.display = ''; creditSumInput.value = ns.creditSum ? String(ns.creditSum) : ''; }
        if (creditConfirmBtn) { creditConfirmBtn.style.display = ''; }
        creditStatus.textContent = 'Введите сумму кредита';
        const el=document.getElementById('move4'); if(el){ el.classList.add('done'); el.classList.remove('dimmed'); }
        try{ creditYes.classList.add('active','btn-checkmark'); creditNo.classList.remove('active','btn-checkmark'); }catch{}
        renderMoves();
      };
      creditNo.onclick = ()=>{
        const ns=getMoveState(); ns.creditTaken=false; ns.creditChoice=false; setMoveState(ns);
        creditStatus.textContent='Кредит не получен';
        if (creditSumInput) { creditSumInput.style.display = 'none'; creditSumInput.value = ''; }
        if (creditConfirmBtn) { creditConfirmBtn.style.display = 'none'; }
        const el=document.getElementById('move4'); if(el){ el.classList.add('done'); el.classList.remove('dimmed'); }
        try{ creditYes.classList.remove('active','btn-checkmark'); creditNo.classList.add('active','btn-checkmark'); }catch{}
        renderMoves();
      };
      if (creditConfirmBtn) {
        creditConfirmBtn.onclick = ()=>{
          try{
            const sum = Math.round(parseFloat(creditSumInput && creditSumInput.value || '0')) || 0;
            if (sum <= 0) { creditStatus.textContent = 'Укажите сумму кредита'; return; }
            const monthlyPay = Math.round(sum / 10);
            // 1) Увеличиваем баланс на сумму кредита
            const ns = getMoveState();
            ns.creditSum = sum; // запомним
            ns.balance = Math.round((ns.balance||0) + sum);
            setMoveState(ns);
            updateTopBalance();
            try{ if (typeof addTurnEventForCurrentTurn==='function') addTurnEventForCurrentTurn(sum, 'Кредит получен'); }catch{}
            try{ renderTurnsHistory(); }catch{}
            // 2) Вносим/обновляем в Ведомость расход "Банк. кредит"
            let row = (ledgerExpenses||[]).find(r=> r && r.category === 'Банк. кредит' && !r.closed);
            if (!row) {
              row = { id: Date.now(), category: 'Банк. кредит', amount: monthlyPay, payoff: sum, closable: true, closed: false, children: 0 };
              ledgerExpenses.push(row);
            } else {
              // Если кредит уже существует, добавляем к нему новые значения
              row.amount += monthlyPay;
              row.payoff += sum;
            }
            LS.save('cf_ledgerExpenses', ledgerExpenses);
            try{ renderLedger(); }catch{}
            // 3) Обновляем ежемесячный поток в состоянии хода (учитывая новый кредит)
            const updatedMonthly = ensureMonthlyFromLedger();
            ns.monthly = updatedMonthly;
            setMoveState(ns);
            // Обновляем отображение ежемесячного потока
            try{ 
              const gameCashflowEl = document.getElementById('gameCashflow');
              if (gameCashflowEl) gameCashflowEl.textContent = String(Math.round(updatedMonthly));
              // Обновляем также в верхней панели
              const balanceTopEl = document.getElementById('balanceTop');
              if (balanceTopEl) {
                const monthly = Math.round(updatedMonthly);
                const sign = monthly < 0 ? '-' : '';
                const absMonthly = Math.abs(monthly);
                balanceTopEl.textContent = `${sign}${absMonthly} $`;
                // Устанавливаем цвет: красный для отрицательных значений
                balanceTopEl.style.color = monthly < 0 ? '#c33' : '#222';
              }
            }catch{}
            creditStatus.textContent = `Кредит оформлен: ${fmtPretty(sum,0)} $, ежемесячно: ${fmtPretty(monthlyPay,0)} $`;
            if (creditSumInput) creditSumInput.style.display = 'none';
            if (creditConfirmBtn) creditConfirmBtn.style.display = 'none';
            // Кредит остается доступным для повторного использования
          }catch(e){ creditStatus.textContent = 'Ошибка оформления кредита'; }
        };
      }
      // Кредит всегда доступен
      const move4 = document.getElementById('move4');
      if (move4) move4.style.display = 'block';
      
      // Подсветка кнопок кредита в зависимости от выбора
      try{
        creditYes.classList.toggle('active', st.creditChoice === true);
        creditYes.classList.toggle('btn-checkmark', st.creditChoice === true);
        creditNo.classList.toggle('active', st.creditChoice === false);
        creditNo.classList.toggle('btn-checkmark', st.creditChoice === false);
      }catch{}
      
      // Обновляем статус кредита
      if (st.creditChoice === false) {
        creditStatus.textContent = 'Кредит не получен';
      } else if (st.creditChoice === true && st.creditSum) {
        const monthlyPay = Math.round(st.creditSum / 10);
        creditStatus.textContent = `Кредит оформлен: ${fmtPretty(st.creditSum,0)} $, ежемесячно: ${fmtPretty(monthlyPay,0)} $`;
      } else if (st.creditChoice === true) {
        creditStatus.textContent = 'Введите сумму кредита';
      } else {
        creditStatus.textContent = '';
      }

      // Комментарий к ходу: биндим textarea
      const deltaInput = document.getElementById('balanceDelta');
      const applyBtn = document.getElementById('applyDelta');
      const commentArea = document.getElementById('turnComment');
      try{ if (commentArea){ const s=getMoveState(); commentArea.value = s.comment||''; commentArea.oninput = ()=>{ const m=getMoveState(); m.comment = commentArea.value; setMoveState(m); }; } }catch{}
      applyBtn.onclick = ()=>{
        const ns = getMoveState();
        const v = parseFloat(deltaInput.value)||0;
        ns.balance = Math.round((ns.balance||0) + v);
        const comment = (document.getElementById('balanceComment')?.value||'').trim();
        setMoveState(ns);
        deltaInput.value = '';
        const cEl = document.getElementById('balanceComment'); if (cEl) cEl.value='';
        // multiple times allowed; do not lock; just briefly mark done
        const m5 = document.getElementById('move5'); if (m5){ m5.classList.add('done'); setTimeout(()=>m5.classList.remove('done'), 500); }
        renderMoves();
        try{ addHistory('Корректировка', `Баланс ${v>=0?'+':''}${fmtPretty(Math.round(v),0)}$${comment?` — ${escapeHtml(comment)}`:''}`); }catch{}
        try{ if (typeof addTurnEventForCurrentTurn==='function') addTurnEventForCurrentTurn(Math.round(v), comment?`Корректировка — ${comment}`:'Корректировка'); }catch{}
        try{ renderTurnsHistory(); }catch{}
      };
      updateTopBalance();
      // Turn header and finish button
      const turn = parseInt(localStorage.getItem('cf_turn_number')||'1',10) || 1;
      const headerNum = document.getElementById('turnNumber'); if (headerNum) headerNum.textContent = String(turn);
      const finishBtn = document.getElementById('finishTurnBtn');
      if (finishBtn){
        finishBtn.onclick = ()=>{
          const ns = getMoveState();
          // Завершить глобальный таймер сразу, без подтверждения
          try{
            // Используем глобальную функцию сброса таймера
            if (window.resetGlobalTimer) {
              window.resetGlobalTimer();
            } else {
              // Fallback: сбрасываем визуально
              const textSmall = document.getElementById('cfTimerText');
              const ringSmall = document.getElementById('cfTimerRing');
              if (textSmall && ringSmall){
                textSmall.textContent = '59';
                ringSmall.setAttribute('stroke-dashoffset','0');
              }
              // Принудительно ставим паузу/показываем Play
              const playBtn = document.getElementById('cfTimerPlay');
              const timerEl = document.getElementById('cfTimer');
              if (timerEl) timerEl.classList.add('paused');
              if (playBtn){ playBtn.style.display='inline-flex'; playBtn.style.opacity='.45'; }
            }
          }catch{}
          // Validate all required points
          const missing = [];
          if (ns.dice==null) missing.push('Бросок кубика');
          if (ns.cardChoice === null || ns.cardChoice === undefined) missing.push('Взять карточку');
          if (ns.cashflowDone===null || ns.cashflowDone===undefined) missing.push('Денежный поток (получил/пропуск)');
          // Кредит не обязателен - можно пропустить
          // Если чек пройден — рекомендуем Получил; если нет и авто-пропуск стоит, не блокируем завершение
          if (missing.length){ 
            showFinishTurnModal('Нельзя завершить ход. Заполните: '+missing.join(', ')); 
            return; 
          }
          const turnBlock = document.createElement('div');
          turnBlock.style.border = '1px solid #eee';
          turnBlock.style.background = '#fff';
          turnBlock.style.borderRadius = '8px';
          turnBlock.style.padding = '10px';
          turnBlock.style.margin = '10px 0';
          // Save turn to storage
          // Определяем, какая именно карточка была + действие (Взял/Не взял)
          let cardLabel = 'Не выбрано';
          try {
            const tNow = getTurnState();
            const abbr = BOARD_CELLS[tNow.pos];
            const titleMap = { 'СД':'Сделка','ВС':'Всячина','БЛ':'Благотворительность','ЧК':'Расчётный чек','РЫ':'Рынок','РБ':'Ребёнок','УВ':'Увольнение' };
            const typeLabel = (abbr === 'СД')
              ? (ns.dealType === 'small' ? 'Сделка (мелкая)' : (ns.dealType === 'large' ? 'Сделка (крупная)' : 'Сделка'))
              : (titleMap[abbr] || abbr);
            if (ns.cardChoice === true) {
              cardLabel = `Взял: ${typeLabel}`;
            } else if (ns.cardChoice === false) {
              cardLabel = `Не взял: ${typeLabel}`;
            }
          } catch {}
          // Статус кредита в записи
          let creditText = '';
          try {
            const creditHidden = (localStorage.getItem('cf_credit_hidden') === '1');
            if (ns.creditChoice === true) creditText = 'оформлен';
            else if (!creditHidden && ns.creditChoice === false) creditText = 'не получил';
          } catch {}
          // Рассчитываем капитал для этого хода
          const capital = Math.round(ns.balance||0) + computeCapitalFromCurrentState().invested + computeCapitalFromCurrentState().payoff;
          // Рассчитываем изменение баланса за этот ход
          const balanceChange = Array.isArray(ns.events) ? ns.events.reduce((sum, ev) => sum + (ev.delta || 0), 0) : 0;
          const rec = { num: turn, dice: ns.dice, card: cardLabel, cardChoice: ns.cardChoice, cashflowDone: !!ns.cashflowDone, monthly: Math.round(ensureMonthlyFromLedger()), creditTaken: !!ns.creditTaken, credit: creditText, balance: Math.round(ns.balance||0), capital: capital, balanceChange: balanceChange, time: Date.now(), timeFormatted: new Date().toLocaleString(), events: Array.isArray(ns.events)?ns.events.slice(0,50):[], comment: (ns.comment||'') };
          const turns = getTurns(); turns.unshift(rec); setTurns(turns);
          
          // Записываем в историю ходов завершение хода
          try{ addTurnEventForCurrentTurn(0, `Завершение хода ${turn}`); }catch{}
          try{ renderTurnsHistory(); }catch{}
          // Next turn: reset move choices but keep balance and monthly; clear per-turn events
          const next = { dice:null, card:null, cardChoice:null, dealType:null, cashflowDone:null, creditTaken:false, creditChoice:null, balance: ns.balance||0, monthly: ns.monthly||0, events: [], checksPassed: 0, doubleCashflowChoice: null };
          setMoveState(next);
          localStorage.setItem('cf_turn_number', String(turn+1));
          renderTurnsHistory();
          // Сбрасываем стартовую точку для нового хода
          const t = getTurnState(); t.startIndex = t.pos; setTurnState(t);
          // Включаем режим "После хода"
          setPostTurn({ num: turn, events: [] });
          renderMoves();
          // Снять визуальные галочки с кнопок хода
          try{
            document.getElementById('cashflowYes')?.classList.remove('active','btn-checkmark');
            document.getElementById('cashflowYes2')?.classList.remove('active','btn-checkmark');
            document.getElementById('cashflowYes3')?.classList.remove('active','btn-checkmark');
            document.getElementById('cashflowNo')?.classList.remove('active','btn-checkmark');
            document.getElementById('cashflowYes')?.classList.remove('recommend');
            document.getElementById('cashflowYes2')?.classList.remove('recommend');
            document.getElementById('cashflowYes3')?.classList.remove('recommend');
            document.getElementById('cashflowNo')?.classList.remove('recommend');
            document.getElementById('cashflowApplied') && (document.getElementById('cashflowApplied').textContent='');
            document.getElementById('cardYes')?.classList.remove('active','btn-checkmark');
            document.getElementById('cardNo')?.classList.remove('active','btn-checkmark');
            document.getElementById('cardYes')?.classList.remove('recommend');
            document.getElementById('cardNo')?.classList.remove('recommend');
            document.getElementById('cardStatus') && (document.getElementById('cardStatus').textContent='');
            
    
          }catch{}
          // Тост: ход завершен (быстро)
          try{ showToast(`Ход ${turn} завершен`, 500); }catch{}
        };
      }
      // Balance manual adjust at bottom
      const adjBtn = document.getElementById('balanceAdjustBtn');
      if (adjBtn){
        adjBtn.onclick = ()=>{
          const stNow = getMoveState();
          const cur = Math.round(stNow.balance||0);
          const input = prompt('Установить баланс на сумму ($):', String(cur));
          if (input===null) return;
          const v = Math.round(parseFloat(String(input).replace(',', '.'))||0);
          const ns = getMoveState();
          const prev = Math.round(ns.balance||0);
          ns.balance = v;
          setMoveState(ns);
          updateTopBalance(); renderMoves();
          const diff = Math.round(v - prev);
          if (diff !== 0){
            const action = diff > 0 ? 'Начисление' : 'Списание';
            try{ if (typeof addTurnEventForCurrentTurn==='function') addTurnEventForCurrentTurn(diff, `Корректировка баланса: ${action} ${Math.abs(diff)}$`); }catch{}
            try{ renderTurnsHistory(); }catch{}
            addHistory('Баланс', `Корректировка: ${action} ${fmtPretty(Math.abs(diff),0)}$`);
          }
        };
      }
      // Mirror small timer to big timer in Moves
      (function mirrorTimer(){
        try{
          const smallText = document.getElementById('cfTimerText');
          const smallRing = document.getElementById('cfTimerRing');
          const bigText = document.getElementById('movesTimerText');
          const bigRing = document.getElementById('movesTimerRing');
          const pauseBtn = document.getElementById('cfTimerPause');
          const resetLeft = document.getElementById('cfTimerResetLeft');
          const movesPause = document.getElementById('movesTimerPause');
          const movesReset = document.getElementById('movesTimerReset');
          const smallPlay = document.getElementById('cfTimerPlay');
          const movesPlay = document.getElementById('movesTimerPlay');
          if (smallText && bigText) bigText.textContent = smallText.textContent;
          if (smallRing && bigRing) {
            bigRing.setAttribute('stroke-dashoffset', smallRing.getAttribute('stroke-dashoffset')||'0');
            // Копируем цвет от маленького таймера к большому
            bigRing.style.stroke = smallRing.style.stroke || '#4a90e2';
          }
          if (movesPause && pauseBtn && !movesPause._wired){ 
            movesPause._wired=true; 
            movesPause.onclick = ()=> {
              pauseBtn.click();
              // Записываем в историю ходов управление большим таймером
              try{ addTurnEventForCurrentTurn(0, 'Большой таймер: Пауза/Старт'); }catch{}
              try{ renderTurnsHistory(); }catch{}
            }; 
          }
          
          // Показываем кнопки таймера при их появлении
          if (movesPause && movesReset && movesPlay) {
            movesPause.style.display = 'inline-flex';
            movesReset.style.display = 'inline-flex';
            movesPlay.style.display = 'inline-flex';
            
            // Сбрасываем флаг скрытия для повторного показа
            if (movesPlay._hideTimer) {
              movesPlay._hideTimer = false;
            }
          }
          if (movesReset && resetLeft && !movesReset._wired){ 
            movesReset._wired=true; 
            movesReset.onclick = ()=> {
              resetLeft.click();
              // Записываем в историю ходов сброс большого таймера
              try{ addTurnEventForCurrentTurn(0, 'Большой таймер: Сброс'); }catch{}
              try{ renderTurnsHistory(); }catch{}
            }; 
          }
          if (movesPlay && smallPlay && !movesPlay._wired){ 
            movesPlay._wired=true; 
            movesPlay.onclick = ()=> {
              smallPlay.click();
              // Записываем в историю ходов запуск большого таймера
              try{ addTurnEventForCurrentTurn(0, 'Большой таймер: Запуск'); }catch{}
              try{ renderTurnsHistory(); }catch{}
            }; 
          }
          if (smallPlay && movesPlay) {
            movesPlay.style.display = smallPlay.style.display || 'none';
            movesPlay.style.opacity = smallPlay.style.opacity || (document.getElementById('cfTimer')?.classList.contains('paused')?'.45':'1');
            
            // Автоматически скрываем кнопки таймера через секунду
            if (movesPlay.style.display !== 'none' && !movesPlay._hideTimer) {
              movesPlay._hideTimer = true;
              setTimeout(() => {
                const movesPause = document.getElementById('movesTimerPause');
                const movesReset = document.getElementById('movesTimerReset');
                const movesPlay = document.getElementById('movesTimerPlay');
                if (movesPause) movesPause.style.display = 'none';
                if (movesReset) movesReset.style.display = 'none';
                if (movesPlay) movesPlay.style.display = 'none';
              }, 1000);
            }
          }
        }catch{}
        requestAnimationFrame(mirrorTimer);
      })();
      // === Текущий ход (снизу) ===
      try{
        const movesSec = document.getElementById('moves');
        if (movesSec){
          // Размещаем строго внизу раздела "Ходы"
          let currentWrap = document.getElementById('currentTurnBottom');
          if (!currentWrap){
            currentWrap = document.createElement('div');
            currentWrap.id = 'currentTurnBottom';
            currentWrap.style.margin = '12px 0 4px 0';
            movesSec.appendChild(currentWrap);
          } else if (currentWrap.parentNode === movesSec && movesSec.lastElementChild !== currentWrap){
            // Переносим в конец, если вдруг не последний
            movesSec.appendChild(currentWrap);
          }
          // Рендерим события текущего хода
          const evs = Array.isArray(st.events) ? st.events : [];
          if (evs.length){
            const turnNumNow = parseInt(localStorage.getItem('cf_turn_number')||'1',10) || 1;
            let html = `<div style="border:1px solid #eee;background:#fffef7;border-radius:8px;padding:10px">`+
              `<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">`+
              `<div style="font-weight:700">Текущий ход №${turnNumNow}</div>`+
              `</div>`+
              `<div>`+
              evs.map(ev=>{
                const sign = (ev.delta||0)>=0?'+':'';
                const amt = `${sign}${fmtPretty(Math.round(ev.delta||0),0)} $`;
                const desc = ev.desc ? ` — ${escapeHtml(ev.desc)}` : '';
                const color = (ev.delta||0) >= 0 ? '#0a0' : '#c33';
                return `<div style="font-size:14px;"><span style="color:${color};font-weight:600">${amt}</span>${desc}</div>`;
              }).join('')+
              `</div>`+
              `</div>`;
            currentWrap.innerHTML = html;
          } else {
            currentWrap.innerHTML = '';
          }
        }
      }catch{}
      
      // === Кнопка для хода 26 ===
      try{
        const turnNum = parseInt(localStorage.getItem('cf_turn_number')||'1',10) || 1;
        const turn26Button = document.getElementById('turn26Button');
        if (turn26Button) {
          // Показываем кнопку только на ходу 26
          turn26Button.style.display = (turnNum === 26) ? 'block' : 'none';
        }
      }catch{}
    }catch(e){ console.warn('renderMoves error', e); }
  }

  // ===== Board model =====
  // Simple 20-cell loop with known labels; include a CHECK cell
  // 24-клеточный трек по канонической карте
  const BOARD_CELLS = [
    'СД','ВС','СД','БЛ','СД','ЧК','СД','РЫ','СД','ВС','СД','РБ','СД','ЧК','СД','РЫ','СД','ВС','СД','УВ','СД','ЧК','СД','РЫ'
  ];

  // Цвета для клеток по порядку (полная окраска)
  const BOARD_COLORS = [
    '#22C55E','#F472B6','#22C55E','#FB923C','#22C55E','#FDE68A','#22C55E','#3B82F6','#22C55E','#F472B6','#22C55E','#A78BFA',
    '#22C55E','#FDE68A','#22C55E','#3B82F6','#22C55E','#F472B6','#22C55E','#0F172A','#22C55E','#FDE68A','#22C55E','#3B82F6'
  ];
  function getTurnState(){
    const d = LS.load('cf_moves_turn', null);
    if (d && typeof d==='object') return d;
    // startIndex: индекс клетки, от которой считаем бросок этого хода
    // -1 означает "до первой клетки" (старт вне доски)
    return { pos: 0, passedCheck: false, startIndex: -1 };
  }
  function setTurnState(v){ LS.save('cf_moves_turn', v); }
  function getBoardInfo(ns, roll){
    const t = getTurnState();
    // Бросок всегда считаем от начальной клетки хода
    const startIdx = (typeof t.startIndex === 'number') ? t.startIndex : t.pos;
    const oldPos = startIdx;
    let newPos = (startIdx + roll) % BOARD_CELLS.length;
    if (newPos < 0) newPos += BOARD_CELLS.length;
    // проходим ли клетку ЧК (чек) по пути
    let passedCheck = false;
    let checksCount = 0;
    for (let k=1;k<=roll;k++){
      const idx = (startIdx + k) % BOARD_CELLS.length;
      if (BOARD_CELLS[idx] === 'ЧК') {
        passedCheck = true;
        checksCount++;
      }
    }
    t.pos = newPos;
    t.passedCheck = passedCheck;
    t.prevPos = startIdx;
    setTurnState(t);
    
    // Обновляем количество пройденных чеков в состоянии хода
    if (checksCount > 0) {
      const moveState = getMoveState();
      // Добавляем чек к текущему счетчику (сброс уже произошел при нажатии на кнопку кубика)
      moveState.checksPassed = (moveState.checksPassed || 0) + checksCount;
      setMoveState(moveState);
    }
    
    const cellAbbr = BOARD_CELLS[newPos] || '—';
    const titleMap = { 'СД':'Сделка','ВС':'Всячина','БЛ':'Благотворительность','ЧК':'Расчётный чек','РЫ':'Рынок','РБ':'Ребёнок','УВ':'Увольнение' };
    const cellName = titleMap[cellAbbr] || cellAbbr;
    return { cellName, passedCheck, oldPos, newPos, cellAbbr };
  }
  function drawBoardTrack(){
    try{
      const track = document.getElementById('boardTrack');
      if (!track) return;
      const t = getTurnState();
      track.innerHTML = '';
      // В первом ходу отображаем метку Старт над первой клеткой
      try{
        const turnNum = parseInt(localStorage.getItem('cf_turn_number')||'1',10) || 1;
        if (turnNum===1) {
          const startEl = document.createElement('div');
          startEl.className = 'board-start';
          startEl.textContent = 'Старт';
          startEl.style.position = 'absolute';
          startEl.style.top = '0';
          startEl.style.left = '0';
          startEl.style.transform = 'none';
          track.appendChild(startEl);
        }
      }catch{}
      BOARD_CELLS.forEach((name, idx)=>{
        const cell = document.createElement('div');
        let cls = 'board-cell';
        if (idx===t.pos) cls += ' active';
        if (typeof t.prevPos === 'number' && idx===t.prevPos) cls += ' from';
        cell.className = cls;
        // Применяем полную окраску клетки
        const bg = BOARD_COLORS[idx] || '#f2f2f2';
        cell.style.background = bg;
        cell.style.borderColor = bg;
        // Контрастный цвет текста/маркера при активной клетке
        if (idx===t.pos){ cell.style.outlineColor = '#1f2937'; }
        // Тултип с расшифровкой
        const titleMap = { 'СД':'Сделка','ВС':'Всячина','БЛ':'Благотворительность','ЧК':'Расчётный чек','РЫ':'Рынок','РБ':'Ребёнок','УВ':'Увольнение' };
        cell.title = titleMap[name] || name;
        // Две буквы на клетке
        const abbr = name;
        cell.style.color = '#0b0b0b';
        cell.style.fontWeight = '700';
        cell.textContent = abbr;
        if (idx===t.pos){
          const m = document.createElement('div');
          m.className = 'board-marker';
          m.textContent = '🧍';
          cell.appendChild(m);
        }
        track.appendChild(cell);
      });
      // После отрисовки клеток точно позиционируем метку Старт над первой
      try{
        const startEl = track.querySelector('.board-start');
        if (startEl){
          const firstCell = track.querySelector('.board-cell');
          if (firstCell){
            const tr = track.getBoundingClientRect();
            const fr = firstCell.getBoundingClientRect();
            const left = (fr.left - tr.left) + Math.max(0, (firstCell.offsetWidth - startEl.offsetWidth) / 2);
            const gap = 12; // небольшой отступ между меткой и первой клеткой
            const top = Math.max(0, firstCell.offsetTop - startEl.offsetHeight - gap);
            startEl.style.left = left + 'px';
            startEl.style.top = top + 'px';
          }
        }
      }catch{}
    }catch{}
  }

  // ===== Turns history (editable) =====
  function getTurns(){ const d = LS.load('cf_turns', []); return Array.isArray(d)?d:[]; }
  function setTurns(v){ LS.save('cf_turns', v); }
  function renderTurnsHistory(){
    try{
      const histTab = document.getElementById('history');
      const containerId = 'turnsHistoryList';
      let hist = document.getElementById(containerId);
      if (!hist && histTab){
        hist = document.createElement('div');
        hist.id = containerId;
        hist.style.marginTop = '14px';
        histTab.appendChild(hist);
      }
      if (!hist) return;
      const arr = getTurns();
      hist.innerHTML = '';
      // Показать текущие события баланса незавершённого хода
      try{
        // Текущий ход показываем внизу вкладки "Ходы", не в Истории
      }catch{}
      if (!arr.length){ hist.innerHTML = '<div style="color:#888;padding:8px">История ходов пуста</div>'; return; }
      arr.forEach((t, idx)=>{
        const wrap = document.createElement('div');
        wrap.style.border = '1px solid #eee';
        wrap.style.background = '#fff';
        wrap.style.borderRadius = '8px';
        wrap.style.padding = '10px';
        wrap.style.margin = '10px 0';
        const isPost = !!t.post;
        const title = isPost ? (t.skip ? `Ход ${t.num} пропущен` : `После хода ${t.num}`) : `Ход ${t.num}`;
        let body = '';
        if (isPost){
          body = `
            <div data-view>
              <div>Баланс: <b>${t.balance < 0 ? '-' : ''}${fmtPretty(Math.abs(t.balance),0)} $</b>${t.balanceChange ? ` (${t.balanceChange >= 0 ? '+' : ''}${fmtPretty(t.balanceChange,0)} $${(t.balance - t.balanceChange) !== 0 ? `, x${(t.balanceChange / (t.balance - t.balanceChange) + 1).toFixed(2)}` : ''})` : ''}</div>
              <div>Капитал: <b>${fmtPretty(Math.round(t.capital || 0),0)} $</b></div>
              ${t.comment?`<div style="margin-top:6px"><div style="font-weight:600;margin-bottom:2px">Комментарий после хода:</div><div style="white-space:pre-wrap">${escapeHtml(t.comment)}</div></div>`:''}
              ${Array.isArray(t.events) && t.events.length ? `<div style="margin-top:6px"><div style="font-weight:600;margin-bottom:2px">Изменения баланса:</div>${t.events.map(ev=>{
                const sign = ev.delta>=0?'+':'';
                const amt = `${sign}${fmtPretty(Math.round(ev.delta),0)} $`;
                const desc = ev.desc ? ` — ${escapeHtml(ev.desc)}` : '';
                const color = ev.delta >= 0 ? '#0a0' : '#c33';
                return `<div style="font-size:14px;"><span style="color:${color};font-weight:600">${amt}</span>${desc}</div>`;
              }).join('')}</div>`: ''}
              ${Array.isArray(t.operations) && t.operations.length ? `<div style="margin-top:6px"><div style="font-weight:600;margin-bottom:2px">Операции:</div>${t.operations.map(op=>{
                const timeStr = op.timeFormatted || new Date(op.time).toLocaleString();
                const deltaStr = op.delta !== 0 ? ` <span style="color:${op.delta > 0 ? '#0a0' : '#c33'};font-weight:600">${op.delta > 0 ? '+' : ''}${fmtPretty(Math.round(op.delta),0)} $</span>` : '';
                return `<div style="font-size:13px;color:#666;margin-bottom:2px;"><span style="color:#888;font-size:11px;">${timeStr}</span> <b>${op.type}</b>: ${escapeHtml(op.desc)}${deltaStr}</div>`;
              }).join('')}</div>`: ''}
            </div>`;
        } else {
          body = `
            <div data-view>
              <div>Кубик: <b>${t.dice}</b></div>
              <div>Карточка: <b>${t.card ? t.card : (t.cardChoice === true ? 'Взял' : (t.cardChoice === false ? 'Не взял' : 'Не выбрано'))}</b></div>
              <div>Денежный поток: <b style="color:${t.cashflowDone ? '#0a0' : '#666'}">${t.cashflowDone?('+'+fmtPretty(t.monthly,0)+' $'):'+0 $'}</b></div>
              ${t.credit ? `<div>Кредит: <b>${t.credit}</b></div>` : ''}
              <div>Баланс: <b>${t.balance < 0 ? '-' : ''}${fmtPretty(Math.abs(t.balance),0)} $</b>${t.balanceChange ? ` (${t.balanceChange >= 0 ? '+' : ''}${fmtPretty(t.balanceChange,0)} $${(t.balance - t.balanceChange) !== 0 ? `, x${(t.balanceChange / (t.balance - t.balanceChange) + 1).toFixed(2)}` : ''})` : ''}</div>
              <div>Капитал: <b>${fmtPretty(Math.round(t.capital || 0),0)} $</b></div>
              ${t.comment?`<div style="margin-top:6px"><div style="font-weight:600;margin-bottom:2px">Комментарий к ходу:</div><div style="white-space:pre-wrap">${escapeHtml(t.comment)}</div></div>`:''}
              ${Array.isArray(t.events) && t.events.length ? `<div style="margin-top:6px"><div style="font-weight:600;margin-bottom:2px">Изменения баланса:</div>${t.events.map(ev=>{
                const sign = ev.delta>=0?'+':'';
                const amt = `${sign}${fmtPretty(Math.round(ev.delta),0)} $`;
                const desc = ev.desc ? ` — ${escapeHtml(ev.desc)}` : '';
                const color = ev.delta >= 0 ? '#0a0' : '#c33';
                return `<div style="font-size:14px;"><span style="color:${color};font-weight:600">${amt}</span>${desc}</div>`;
              }).join('')}</div>`: ''}
              ${Array.isArray(t.operations) && t.operations.length ? `<div style="margin-top:6px"><div style="font-weight:600;margin-bottom:2px">Операции:</div>${t.operations.map(op=>{
                const timeStr = op.timeFormatted || new Date(op.time).toLocaleString();
                const deltaStr = op.delta !== 0 ? ` <span style="color:${op.delta > 0 ? '#0a0' : '#c33'};font-weight:600">${op.delta > 0 ? '+' : ''}${fmtPretty(Math.round(op.delta),0)} $</span>` : '';
                return `<div style="font-size:13px;color:#666;margin-bottom:2px;"><span style="color:#888;font-size:11px;">${timeStr}</span> <b>${op.type}</b>: ${escapeHtml(op.desc)}${deltaStr}</div>`;
              }).join('')}</div>`: ''}
            </div>`;
        }
        wrap.innerHTML = `
          <div style=\"display:flex;justify-content:space-between;align-items:center;margin-bottom:6px\">
            <div style=\"font-weight:700\">${title}</div>
            <div style=\"display:flex;align-items:center;gap:8px\">
              <span style=\"color:#888;font-size:12px;\">${t.timeFormatted || new Date(t.time).toLocaleString()}</span>
              <button class=\"btn\" style=\"padding:4px 8px;font-size:12px\" data-act=\"edit\">Редактировать</button>
            </div>
          </div>
          ${body}
        `;
        const btn = wrap.querySelector('button[data-act="edit"]');
        btn.onclick = ()=>{
          const view = wrap.querySelector('[data-view]');
          const form = document.createElement('div');
          form.innerHTML = `
            <div style="display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:6px;align-items:center;font-size:13px">
              <label>Кубик <input type="number" min="1" max="12" value="${t.dice}" data-f="dice"></label>
              <label>Карточка <select data-f="cardChoice"><option value="true" ${t.cardChoice===true?'selected':''}>Взял</option><option value="false" ${t.cardChoice===false?'selected':''}>Не взял</option></select></label>
              <label>Поток <select data-f="flow"><option value="yes" ${t.cashflowDone?'selected':''}>получил</option><option value="no" ${!t.cashflowDone?'selected':''}>пропуск</option></select></label>
              <label>Ежемес. <input type="number" step="1" value="${t.monthly}" data-f="monthly"></label>
              <label>Кредит <select data-f="credit"><option value="yes" ${t.creditTaken?'selected':''}>оформлен</option><option value="no" ${!t.creditTaken?'selected':''}>не получил</option></select></label>
              <label>Баланс <input type="number" step="1" value="${t.balance}" data-f="balance"></label>
              <label style="grid-column:1/-1">Комментарий к ходу
                <textarea rows="5" data-f="comment" style="width:100%;padding:6px 8px;font-size:13px;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',sans-serif">${t.comment||''}</textarea>
              </label>
            </div>
            <div style="margin-top:8px;display:flex;gap:8px;justify-content:flex-end">
              <button class="btn" style="padding:6px 10px;font-size:13px" data-act="save">Сохранить</button>
              <button class="btn" style="padding:6px 10px;font-size:13px;background:#eee;color:#444;border:1px solid #ccc" data-act="cancel">Отмена</button>
            </div>
          `;
          wrap.replaceChild(form, view);
          const save = form.querySelector('[data-act="save"]');
          const cancel = form.querySelector('[data-act="cancel"]');
          cancel.onclick = ()=> renderTurnsHistory();
          save.onclick = ()=>{
            const dice = Math.max(1, Math.min(12, parseInt(form.querySelector('[data-f="dice"]').value||'0',10)||1));
            const cardChoice = form.querySelector('[data-f="cardChoice"]').value === 'true';
            const flow = form.querySelector('[data-f="flow"]').value==='yes';
            const monthly = Math.round(parseFloat(form.querySelector('[data-f="monthly"]').value)||0);
            const credit = form.querySelector('[data-f="credit"]').value==='yes';
            const balance = Math.round(parseFloat(form.querySelector('[data-f="balance"]').value)||0);
            const comment = String(form.querySelector('[data-f="comment"]').value||'');
            const arr2 = getTurns();
            if (arr2[idx]){ Object.assign(arr2[idx], { dice, cardChoice, cashflowDone: flow, monthly, creditTaken: credit, balance, comment }); setTurns(arr2); }
            renderTurnsHistory();
          };
        };
        hist.appendChild(wrap);
      });
    }catch{}
  }
  // === График баланса и капитала (История) ===
  function computeCapitalFromCurrentState() {
    try {
      const incomes = LS.load('cf_ledgerIncomes', []);
      const expenses = LS.load('cf_ledgerExpenses', []);
      const invested = Array.isArray(incomes) ? incomes.reduce((sum, r) => sum + (parseFloat(r.invest) || 0), 0) : 0;
      const payoff = Array.isArray(expenses) ? expenses.reduce((sum, r) => sum + (parseFloat(r.payoff) || 0), 0) : 0;
      return { invested: Math.round(invested), payoff: Math.round(payoff) };
    } catch { return { invested: 0, payoff: 0 }; }
  }
  
  // Новая функция для расчета капитала без учета трат на закрытие расходов
  function computeCapitalWithoutPayoff() {
    try {
      const incomes = LS.load('cf_ledgerIncomes', []);
      const invested = Array.isArray(incomes) ? incomes.reduce((sum, r) => sum + (parseFloat(r.invest) || 0), 0) : 0;
      return { invested: Math.round(invested), payoff: 0 }; // payoff = 0, так как не учитываем траты на закрытие
    } catch { return { invested: 0, payoff: 0 }; }
  }
  function renderBalanceChart(){
    try{
      const canvas = document.getElementById('balanceChart');
      const emptyMsg = document.getElementById('balanceChartEmpty');
      if (!canvas || !emptyMsg) return;
      const turns = getTurns();
      if (!Array.isArray(turns) || !turns.length){
        emptyMsg.style.display = '';
        canvas.style.display = 'none';
        return;
      }
      emptyMsg.style.display = 'none';
      canvas.style.display = 'block';

      // Размеры под контейнер
      const pxRatio = (window.devicePixelRatio || 1);
      const cssW = canvas.clientWidth || 900;
      const cssH = 220;
      canvas.width = Math.floor(cssW * pxRatio);
      canvas.height = Math.floor(cssH * pxRatio);
      const ctx = canvas.getContext('2d');
      ctx.setTransform(pxRatio, 0, 0, pxRatio, 0, 0);

      // Данные (хронологически слева направо)
      const arr = turns.slice().reverse();
      const labels = arr.map(t=> t.num);
      const balances = arr.map(t=> Math.round(t.balance||0));
      // Капитал: для каждого хода считаем накопленные инвестиции БЕЗ учета трат на закрытие расходов
      const capitals = [];
      let accumulatedInvested = 0;
      
      for (let i = 0; i < arr.length; i++) {
        const turn = arr[i];
        // Добавляем инвестиции из событий этого хода
        if (turn.events && Array.isArray(turn.events)) {
          turn.events.forEach(event => {
            if (event.desc && typeof event.desc === 'string') {
              const desc = event.desc.toLowerCase();
              // Инвестиции в доходы (покупка недвижимости, бизнеса)
              if (desc.includes('покупка') || desc.includes('инвестиция') || desc.includes('вложено')) {
                accumulatedInvested += Math.abs(event.delta || 0);
              }
              // Возврат инвестиций (продажа)
              if (desc.includes('продажа') || desc.includes('возврат инвестиции')) {
                accumulatedInvested = accumulatedInvested - Math.abs(event.delta || 0);
              }
              // НЕ учитываем траты на закрытие расходов (погашение)
            }
          });
        }
        // Капитал = баланс + накопленные инвестиции (без погашений)
        capitals.push(balances[i] + accumulatedInvested);
      }

      // Паддинги и оси
      const padL=44, padR=10, padT=12, padB=28;
      const W = canvas.width/pxRatio, H = canvas.height/pxRatio;
      const plotW = W - padL - padR, plotH = H - padT - padB;
      ctx.clearRect(0,0,W,H);

      const allVals = balances.concat(capitals);
      const minV = Math.min.apply(null, allVals);
      const maxV = Math.max.apply(null, allVals);
      const span = Math.max(1, maxV - minV);
      const xOf = i => padL + (labels.length>1 ? (i/(labels.length-1))*plotW : 0);
      const yOf = v => padT + plotH - ((v - minV)/span)*plotH;

      // Сетка Y
      ctx.strokeStyle = '#eee'; ctx.lineWidth = 1;
      ctx.fillStyle = '#666'; ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", sans-serif';
      ctx.textAlign = 'right'; ctx.textBaseline = 'middle';
      for(let k=0;k<=5;k++){
        const y = padT + plotH*(k/5);
        ctx.beginPath(); ctx.moveTo(padL, y); ctx.lineTo(W-padR, y); ctx.stroke();
        const val = Math.round(maxV - (span*(k/5)));
        ctx.fillText(String(val), padL - 6, y);
      }

      // Ось X — несколько меток по шагу
      ctx.textAlign = 'center'; ctx.textBaseline = 'top'; ctx.fillStyle = '#666';
      const step = Math.max(1, Math.floor(labels.length/6));
      for (let i=0;i<labels.length;i+=step){ ctx.fillText(String(labels[i]), xOf(i), H - padB + 4); }

      // Вертикальные линии для каждого хода
      ctx.strokeStyle = '#e0e0e0';
      ctx.lineWidth = 1;
      ctx.setLineDash([2, 2]);
      for (let i=0;i<labels.length;i++){
        const x = xOf(i);
        ctx.beginPath();
        ctx.moveTo(x, padT);
        ctx.lineTo(x, H - padB);
        ctx.stroke();
      }
      ctx.setLineDash([]); // Сбрасываем пунктир

      // Линии
      function drawLine(values, color){
        ctx.lineWidth = 2; ctx.strokeStyle = color; ctx.beginPath();
        values.forEach((val, i) => { const x=xOf(i), y=yOf(val); if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); });
        ctx.stroke();
      }
      // Баланс — синяя, Капитал — зелёная
      drawLine(balances, '#3b82f6');
      drawLine(capitals, '#22c55e');

      // Легенда
      let lx = padL + 6, ly = padT + 6;
      function legend(color, title){ ctx.fillStyle = color; ctx.fillRect(lx, ly, 16, 3); ctx.fillStyle = '#333'; ctx.fillText(title, lx + 24, ly - 6); lx += 140; }
      legend('#3b82f6', 'Баланс'); legend('#22c55e', 'Капитал (без погашений)');
    }catch(e){ console.warn('renderBalanceChart failed', e); }
  }
  // Функция обновления результата партнерских расчетов и баланса
  function updatePartnerResult() {
    try {
      // Инициализируем состояние хода, если его нет
      if (typeof getMoveState === 'function') {
        const st = getMoveState();
        if (!st || typeof st !== 'object') {
          console.log('Партнеры: инициализируем состояние хода');
          if (typeof setMoveState === 'function') {
            setMoveState({ dice: null, card: null, cashflowDone: null, creditTaken: false, creditChoice: null, balance: 0, monthly: 0, comment: '', events: [], autoCashflow: false });
          }
        }
      }
      // Закомментировано, так как элементы партнеров теперь создаются динамически
      // Расчеты теперь происходят в функции renderPartners()
      const sum = 0; // parseFloat(document.getElementById('partnerSum')?.value || '0');
      const buy = 0; // parseFloat(document.getElementById('partnerBuy')?.value || '0');
      const sell = 0; // parseFloat(document.getElementById('partnerSell')?.value || '0');
      const com = 20; // parseFloat(document.getElementById('partnerCom')?.value || '20');
      
      // Закомментировано, так как элемент partnerResult больше не существует
      // const resultEl = document.getElementById('partnerResult');
      // if (!resultEl) return;
      
      // Закомментировано, так как расчеты теперь происходят в renderPartners()
      /*
      if (sum && buy && sell) {
        const qty = sum / buy;
        const sumSell = qty * sell;
        const net = sumSell * (1 - com/100);
        const profit = net - sum;
        const mult = sum > 0 ? (net/sum) : null;
        
        let html = `<div style="margin-top:12px;padding:12px;background:#f0f8ff;border:1px solid #b3d6f6;border-radius:6px;font-size:14px;">`;
        html += `<div style="margin-bottom:8px;font-weight:600;color:#226;">Результат расчета:</div>`;
        html += `<div>Инвестируем: <b>${fmtPretty(sum, 0)}</b> $</div>`;
        html += `<div>Сумма продажи: <b>${fmtPretty(sumSell, 0)}</b> $</div>`;
        html += `<div>Комиссия партнеру: <span style="color:#c33"><b>${fmtPretty(sumSell - net, 0)}</b></span> $</div>`;
        html += `<div>Получу на руки: <span style="color:#226"><b>${fmtPretty(net, 0)}</b></span> $</div>`;
        html += `<div>Чистая прибыль: <span style="color:#080;font-weight:600">${fmtPretty(profit, 0)}</span> $`;
        if (mult !== null) {
          html += ` <span style="color:#080">(x${mult.toFixed(1)})</span>`;
        }
        html += `</div></div>`;
        
        resultEl.innerHTML = html;
        
        // Корректируем баланс при изменении суммы покупки
        // Храним предыдущую сумму в localStorage
        const prevSumKey = 'cf_partnerPrevSum';
        const prevSum = parseFloat(localStorage.getItem(prevSumKey) || '0');
        
        console.log('Партнеры: проверка суммы - текущая:', sum, 'предыдущая:', prevSum);
        
        if (Math.abs(sum - prevSum) > 0.01) {
          const diff = sum - prevSum;
          console.log('Партнеры: sum=', sum, 'prevSum=', prevSum, 'diff=', diff);
          
          if (diff !== 0) {
            // Если это первый ввод (prevSum = 0), то сразу устанавливаем баланс
            if (prevSum === 0 && sum > 0) {
              console.log('Партнеры: первый ввод, устанавливаем баланс = -', sum);
            }
            
            // Простой способ обновления баланса - напрямую через localStorage
            const currentBalance = parseFloat(localStorage.getItem('cf_partnerBalance') || '0');
            const newBalance = currentBalance - diff;
            localStorage.setItem('cf_partnerBalance', String(newBalance));
            console.log('Партнеры: обновлен баланс в localStorage:', newBalance);
            
            // Обновляем отображение баланса напрямую
            const sign = newBalance < 0 ? '-' : '';
            const absBalance = Math.abs(newBalance);
            const balanceText = `${sign}${fmtPretty(absBalance,0)} $`;
            
            // Обновляем баланс для мобильной версии
            const balanceTopEl = document.getElementById('balanceTop');
            if (balanceTopEl) {
              balanceTopEl.textContent = balanceText;
              // Устанавливаем цвет: красный для отрицательных значений
              balanceTopEl.style.color = newBalance < 0 ? '#c33' : '#222';
              console.log('Партнеры: обновлен мобильный баланс:', balanceText, 'цвет:', newBalance < 0 ? '#c33' : '#222');
            } else {
              console.log('Партнеры: элемент balanceTop не найден');
            }
            
            // Обновляем баланс для десктопной версии
            const balanceTopDesktopEl = document.getElementById('balanceTopDesktop');
            if (balanceTopDesktopEl) {
              balanceTopDesktopEl.textContent = balanceText;
              // Устанавливаем цвет: красный для отрицательных значений
              balanceTopDesktopEl.style.color = newBalance < 0 ? '#c33' : '#222';
              console.log('Партнеры: обновлен десктопный баланс:', balanceText, 'цвет:', newBalance < 0 ? '#c33' : '#222');
            } else {
              console.log('Партнеры: элемент balanceTopDesktop не найден');
            }
            
            console.log('Партнеры: обновлен баланс напрямую:', balanceText);
            
            // Также обновляем через функции состояния хода, если они доступны
            if (typeof getMoveState === 'function' && typeof setMoveState === 'function') {
              try {
                const st = getMoveState();
                console.log('Партнеры: текущий баланс в состоянии=', st.balance);
                
                // Уменьшаем баланс на сумму покупки
                st.balance = Math.round((st.balance || 0) - diff);
                console.log('Партнеры: новый баланс в состоянии=', st.balance);
                setMoveState(st);
                
                // Обновляем отображение баланса
                if (typeof updateTopBalance === 'function') {
                  updateTopBalance();
                }
                
                // Записываем в историю, если функция существует
                if (typeof addHistory === 'function') {
                  addHistory('Баланс', `Партнёрская сделка: -${fmtPretty(Math.abs(diff), 0)}$`);
                }
                
                // Записываем в историю ходов, если функция существует
                if (typeof addTurnEventForCurrentTurn === 'function') {
                  try { addTurnEventForCurrentTurn(-diff, `Партнёрская сделка`); } catch {}
                }
                
                // Обновляем историю ходов, если функция существует
                if (typeof renderTurnsHistory === 'function') {
                  try { renderTurnsHistory(); } catch {}
                }
              } catch (e) {
                console.log('Партнеры: ошибка при обновлении состояния хода:', e);
              }
            } else {
              console.log('Партнеры: функции getMoveState или setMoveState не найдены');
            }
          }
          
          // Сохраняем новую сумму
          localStorage.setItem(prevSumKey, String(sum));
        }
      } else {
        resultEl.innerHTML = '<div style="margin-top:12px;color:#666;font-style:italic;">Введите все данные для расчета</div>';
      }
      */
    } catch (e) {
      console.error('Ошибка в updatePartnerResult:', e);
    }
  }

  // Функция для очистки старой истории операций
  function clearOldHistory() {
    if (confirm('Вы уверены, что хотите очистить старую историю операций? Все операции теперь записываются в историю ходов.')) {
      LS.save('cf_history', []);
      showToast('Старая история очищена', 2000);
      try { renderHistory(); } catch {}
    }
  }
  
  // Авто-обновление графика при открытии Истории и после перерисовок
  (function(){
    try{
      const prevSetActive = window.setActive;
      window.setActive = function(tabId){
        try{ prevSetActive(tabId); }catch{}
        if (tabId === 'tabHistory') { try{ renderBalanceChart(); }catch{} }
        if (tabId === 'tabMoves') { try{ placeEasyBuyAtBottom(); }catch{} }
        if (tabId === 'tabParticipants') { try{ ensureTimerSoundControlsAlways(); }catch{} }
      };
    }catch{}
    // Лёгкая обёртка для вызова графика после перерисовки истории/ходов
    try{
      const prevRenderHistory = window.renderHistory;
      window.renderHistory = function(){ try{ prevRenderHistory && prevRenderHistory(); }catch{} try{ renderBalanceChart(); }catch{} };
    }catch{}
    try{
      const prevRenderTurns = window.renderTurnsHistory;
      window.renderTurnsHistory = function(){ try{ prevRenderTurns && prevRenderTurns(); }catch{} try{ renderBalanceChart(); }catch{} };
    }catch{}
    // Если история уже активна — отрисуем сразу
    try{ if ((localStorage.getItem('cf_activeTab')||'')==='tabHistory') renderBalanceChart(); }catch{}
  })();

  // Функции для управления всплывающей панелью с финансовыми показателями
  let financialPanelVisible = false;
  let isDragging = false;
  let dragStartX = 0;
  let dragStartY = 0;
  let panelStartX = 0;
  let panelStartY = 0;

  // Функция переключения видимости панели
  function toggleFinancialPanel() {
    const panel = document.getElementById('financialPanel');
    if (!panel) return;
    
    financialPanelVisible = !financialPanelVisible;
    panel.style.display = financialPanelVisible ? 'block' : 'none';
    
    // Сохраняем состояние в localStorage
    localStorage.setItem('cf_financialPanelVisible', financialPanelVisible ? 'true' : 'false');
    
    // Если панель стала видимой, обновляем данные
    if (financialPanelVisible) {
      updateFinancialPanel();
    }
  }

  // Функция обновления данных в панели
  function updateFinancialPanel() {
    if (!financialPanelVisible) return;
    
    try {
      const totals = computeTotals();
      
      // Обновляем значения в панели
      const passiveEl = document.getElementById('panelPassive');
      const incomeEl = document.getElementById('panelIncome');
      const expenseEl = document.getElementById('panelExpense');
      const cashflowEl = document.getElementById('panelCashflow');
      
      if (passiveEl) passiveEl.textContent = Math.round(totals.passiveIncome);
      if (incomeEl) incomeEl.textContent = Math.round(totals.totalIncome);
      if (expenseEl) expenseEl.textContent = Math.round(totals.totalExpense);
      if (cashflowEl) {
        const cashflow = totals.totalIncome - totals.totalExpense;
        cashflowEl.textContent = Math.round(cashflow);
        // Ежемесячный поток всегда голубой
        cashflowEl.style.color = '#0d6efd';
      }
    } catch (e) {
      console.warn('Ошибка при обновлении финансовой панели:', e);
    }
  }

  // Функция для перетаскивания панели
  function initFinancialPanelDrag() {
    const panel = document.getElementById('financialPanel');
    if (!panel) return;
    
    // Функция начала перетаскивания
    function startDrag(clientX, clientY) {
      isDragging = true;
      dragStartX = clientX;
      dragStartY = clientY;
      panelStartX = parseInt(panel.style.left) || 10;
      panelStartY = parseInt(panel.style.top) || 60;
      
      panel.style.cursor = 'grabbing';
    }
    
    // Функция перемещения
    function moveDrag(clientX, clientY) {
      if (isDragging) {
        const deltaX = clientX - dragStartX;
        const deltaY = clientY - dragStartY;
        
        const newX = Math.max(0, Math.min(window.innerWidth - panel.offsetWidth, panelStartX + deltaX));
        const newY = Math.max(0, Math.min(window.innerHeight - panel.offsetHeight, panelStartY + deltaY));
        
        panel.style.left = newX + 'px';
        panel.style.top = newY + 'px';
      }
    }
    
    // Функция окончания перетаскивания
    function endDrag() {
      if (isDragging) {
        isDragging = false;
        panel.style.cursor = 'move';
        
        // Сохраняем позицию в localStorage
        const x = parseInt(panel.style.left) || 10;
        const y = parseInt(panel.style.top) || 60;
        localStorage.setItem('cf_financialPanelX', x.toString());
        localStorage.setItem('cf_financialPanelY', y.toString());
      }
    }
    
    // Обработчики для мыши
    panel.addEventListener('mousedown', function(e) {
      // Проверяем, что клик был по панели или по цифрам
      if (e.target === panel || e.target.id && (e.target.id === 'panelPassive' || e.target.id === 'panelIncome' || e.target.id === 'panelExpense' || e.target.id === 'panelCashflow')) {
        startDrag(e.clientX, e.clientY);
        e.preventDefault();
      }
    });
    
    document.addEventListener('mousemove', function(e) {
      moveDrag(e.clientX, e.clientY);
    });
    
    document.addEventListener('mouseup', function() {
      endDrag();
    });
    
    // Обработчики для сенсорных устройств
    panel.addEventListener('touchstart', function(e) {
      if (e.touches.length === 1) {
        const touch = e.touches[0];
        if (e.target === panel || e.target.id && (e.target.id === 'panelPassive' || e.target.id === 'panelIncome' || e.target.id === 'panelExpense' || e.target.id === 'panelCashflow')) {
          startDrag(touch.clientX, touch.clientY);
          e.preventDefault();
        }
      }
    }, { passive: false });
    
    document.addEventListener('touchmove', function(e) {
      if (e.touches.length === 1 && isDragging) {
        const touch = e.touches[0];
        moveDrag(touch.clientX, touch.clientY);
        e.preventDefault();
      }
    }, { passive: false });
    
    document.addEventListener('touchend', function(e) {
      endDrag();
    });
  }

  // Функция восстановления состояния панели при загрузке
  function restoreFinancialPanelState() {
    const panel = document.getElementById('financialPanel');
    if (!panel) return;
    
    // Восстанавливаем видимость
    const visible = localStorage.getItem('cf_financialPanelVisible') === 'true';
    financialPanelVisible = visible;
    panel.style.display = visible ? 'block' : 'none';
    
    // Восстанавливаем позицию
    const x = localStorage.getItem('cf_financialPanelX');
    const y = localStorage.getItem('cf_financialPanelY');
    if (x && y) {
      panel.style.left = x + 'px';
      panel.style.top = y + 'px';
    }
    
    // Если панель видима, обновляем данные
    if (visible) {
      updateFinancialPanel();
    }
  }

  // Инициализация панели при загрузке страницы
  document.addEventListener('DOMContentLoaded', function() {
    initFinancialPanelDrag();
    restoreFinancialPanelState();
  });

  // Защита от удаления защищенных элементов
  (function protectElements() {
    const originalRemoveChild = Node.prototype.removeChild;
    const originalRemove = Element.prototype.remove;
    const originalInnerHTML = Object.getOwnPropertyDescriptor(Element.prototype, 'innerHTML');
    const originalReplaceWith = Element.prototype.replaceWith;
    const originalTextContent = Object.getOwnPropertyDescriptor(Node.prototype, 'textContent');
    
    Node.prototype.removeChild = function(child) {
      if (child && (child.hasAttribute && child.hasAttribute('data-protected')) || 
          (child.querySelector && child.querySelector('[data-protected]'))) {
        console.log('Защищенный элемент не может быть удален:', child);
        return child;
      }
      return originalRemoveChild.call(this, child);
    };
    
    Element.prototype.remove = function() {
      if (this.hasAttribute && this.hasAttribute('data-protected') ||
          (this.querySelector && this.querySelector('[data-protected]'))) {
        console.log('Защищенный элемент не может быть удален:', this);
        return;
      }
      return originalRemove.call(this);
    };
    
    Element.prototype.replaceWith = function(...nodes) {
      if (this.hasAttribute && this.hasAttribute('data-protected') ||
          (this.querySelector && this.querySelector('[data-protected]'))) {
        console.log('Защищенный элемент не может быть заменен:', this);
        return;
      }
      return originalReplaceWith.apply(this, nodes);
    };
    
    // Защита от очистки innerHTML защищенных контейнеров
    Object.defineProperty(Element.prototype, 'innerHTML', {
      set: function(value) {
        if (this.hasAttribute && this.hasAttribute('data-protected') ||
            (this.querySelector && this.querySelector('[data-protected]'))) {
          console.log('Защищенный контейнер не может быть очищен:', this);
          return;
        }
        originalInnerHTML.set.call(this, value);
      },
      get: originalInnerHTML.get
    });
    
    // Дополнительная защита от изменения textContent
    Object.defineProperty(Node.prototype, 'textContent', {
      set: function(value) {
        if (this.hasAttribute && this.hasAttribute('data-protected') ||
            (this.querySelector && this.querySelector('[data-protected]'))) {
          console.log('Защищенный элемент не может быть изменен через textContent:', this);
          return;
        }
        originalTextContent.set.call(this, value);
      },
      get: originalTextContent.get
    });
    
    // Защита от удаления через querySelector и затем remove
    const originalQuerySelector = Document.querySelector;
    const originalQuerySelectorAll = Document.querySelectorAll;
    
    // Мониторим попытки удаления защищенных элементов
    setInterval(() => {
      const protectedElements = document.querySelectorAll('[data-protected]');
      protectedElements.forEach(el => {
        if (!document.contains(el)) {
          console.error('Защищенный элемент был удален! Восстанавливаем...', el);
          // Попытаемся восстановить элемент
          const holder = document.getElementById('timerSoundsHolder');
          if (holder && !document.contains(holder)) {
            const alarmButtons = document.getElementById('alarmButtonsRow');
            if (alarmButtons) {
              alarmButtons.parentNode.insertBefore(holder, alarmButtons.nextSibling);
            }
          }
        }
      });
    }, 1000);
  })();

  // Функция для создания кнопок управления звуком (всегда)
  function ensureTimerSoundControlsAlways(){
    try{
      // Кнопки звука теперь статические в HTML, просто инициализируем их обработчики
      initTimerSoundControls();
      return;
    }catch{}
  }

  // Глобальная панель настроек звуков таймера (всегда доступна при загрузке)
  (function ensureTimerSoundControls(){
    try{
      ensureTimerSoundControlsAlways();
    }catch{}
  })();

  // Дополнительно вызываем создание кнопок при загрузке DOM
  document.addEventListener('DOMContentLoaded', function() {
    try{
      ensureTimerSoundControlsAlways();
    }catch{}
  });

  // Инициализация кнопок управления звуком (для HTML-элементов)
  function initTimerSoundControls() {
    try {
      // Вспомогательные функции
      function byId(id){ return document.getElementById(id); }
      
      if (typeof window.getTimerSoundFunction !== 'function') {
        window.getTimerSoundFunction = function(name){ try { return (typeof window[name] === 'function') ? window[name] : null; } catch { return null; } };
      }
      if (typeof window.loadTimerSounds !== 'function') {
        window.loadTimerSounds = function(){
          try{
            const sStart = localStorage.getItem('cf_timerStartSound') || 'playBong';
            const s15 = localStorage.getItem('cf_timer15Sound') || 'playSound3';
            const s7 = localStorage.getItem('cf_timer7Sound') || 'playSound6';
            const s3 = localStorage.getItem('cf_timer3Sound') || 'playBeep';
            const map = { timerStartSound: sStart, timer15Sound: s15, timer7Sound: s7, timer3Sound: s3 };
            Object.entries(map).forEach(([id,val])=>{ const el = byId(id); if (el) el.value = val; });
          }catch{}
        };
      }
      if (typeof window.saveTimerSounds !== 'function') {
        window.saveTimerSounds = function(){
          try{
            const sStart = byId('timerStartSound')?.value || 'playBong';
            const s15 = byId('timer15Sound')?.value || 'playSound3';
            const s7 = byId('timer7Sound')?.value || 'playSound6';
            const s3 = byId('timer3Sound')?.value || 'playBeep';
            localStorage.setItem('cf_timerStartSound', sStart);
            localStorage.setItem('cf_timer15Sound', s15);
            localStorage.setItem('cf_timer7Sound', s7);
            localStorage.setItem('cf_timer3Sound', s3);
          }catch{}
        };
      }
      if (typeof window.playSelected !== 'function') {
        window.playSelected = function(selectId){
          try{
            const sel = byId(selectId);
            const val = sel ? sel.value : '';
            const f = window.getTimerSoundFunction(val);
            if (typeof f === 'function') f();
          }catch{}
        };
      }

      // Загружаем сохраненные настройки
      try { window.loadTimerSounds(); } catch {}
      
      // Настраиваем обработчики событий
      const saveBtn = byId('timerSoundsSaveBtn_global'); 
      if (saveBtn) saveBtn.onclick = ()=>{ try{ window.saveTimerSounds(); if (typeof showToast==='function') showToast('Сохранено'); }catch{} };
      
      const tStart = byId('testStartBtn_global'); 
      if (tStart) tStart.onclick = ()=> window.playSelected('timerStartSound');
      
      const t15 = byId('test15Btn_global'); 
      if (t15) t15.onclick = ()=> window.playSelected('timer15Sound');
      
      const t7 = byId('test7Btn_global'); 
      if (t7) t7.onclick = ()=> window.playSelected('timer7Sound');
      
      const t3 = byId('test3Btn_global'); 
      if (t3) t3.onclick = ()=> window.playSelected('timer3Sound');
      
    } catch {}
  }

  // Вызываем инициализацию при загрузке DOM
  document.addEventListener('DOMContentLoaded', function() {
    try{
      initTimerSoundControls();
    }catch{}
  });

  // Обновляем панель при изменении данных
  const originalRecalcLedgerTotals = window.recalcLedgerTotals;
  window.recalcLedgerTotals = function() {
    if (originalRecalcLedgerTotals) {
      originalRecalcLedgerTotals();
    }
    updateFinancialPanel();
  };

  // Функции для работы с модальным окном завершения хода
  function showFinishTurnModal(message) {
    const modal = document.getElementById('finishTurnModal');
    const messageEl = document.getElementById('finishTurnMessage');
    if (modal && messageEl) {
      messageEl.textContent = message;
      modal.style.display = 'flex';
    }
  }

  function hideFinishTurnModal() {
    const modal = document.getElementById('finishTurnModal');
    if (modal) {
      modal.style.display = 'none';
    }
  }

  // Обработчики для кнопок модального окна
  document.addEventListener('DOMContentLoaded', function() {
    const backBtn = document.getElementById('finishTurnBackBtn');
    const forceBtn = document.getElementById('finishTurnForceBtn');
    
    if (backBtn) {
      backBtn.onclick = function() {
        hideFinishTurnModal();
      };
    }
    
    if (forceBtn) {
      forceBtn.onclick = function() {
        hideFinishTurnModal();
        // Принудительно завершаем ход
        forceFinishTurn();
      };
    }
  });

  // Функция принудительного завершения хода
  function forceFinishTurn() {
    const ns = getMoveState();
    const turn = parseInt(localStorage.getItem('cf_turn_number')||'1',10) || 1;
    
    // Завершить глобальный таймер сразу, без подтверждения
    try{
      // Используем глобальную функцию сброса таймера
      if (window.resetGlobalTimer) {
        window.resetGlobalTimer();
      } else {
        // Fallback: сбрасываем визуально
        const textSmall = document.getElementById('cfTimerText');
        const ringSmall = document.getElementById('cfTimerRing');
        if (textSmall && ringSmall){
          textSmall.textContent = '59';
          ringSmall.setAttribute('stroke-dashoffset','0');
        }
        // Принудительно ставим паузу/показываем Play
        const playBtn = document.getElementById('cfTimerPlay');
        const timerEl = document.getElementById('cfTimer');
        if (timerEl) timerEl.classList.add('paused');
        if (playBtn){ playBtn.style.display='inline-flex'; playBtn.style.opacity='.45'; }
      }
    }catch{}
    
    // Принудительно заполняем недостающие поля
    if (ns.dice == null) ns.dice = 1; // По умолчанию 1
    if (ns.cardChoice === null || ns.cardChoice === undefined) {
      ns.cardChoice = false; // По умолчанию "Не взял"
    }
    if (ns.cashflowDone === null || ns.cashflowDone === undefined) {
      ns.cashflowDone = false; // По умолчанию "Пропуск"
    }
    
    setMoveState(ns);
    
    // Создаем блок хода
    const turnBlock = document.createElement('div');
    turnBlock.style.border = '1px solid #eee';
    turnBlock.style.background = '#fff';
    turnBlock.style.borderRadius = '8px';
    turnBlock.style.padding = '10px';
    turnBlock.style.margin = '10px 0';
    
    // Определяем, какая именно карточка была + действие (Взял/Не взял)
    let cardLabel = 'Не выбрано';
    try {
      const tNow = getTurnState();
      const abbr = BOARD_CELLS[tNow.pos];
      const titleMap = { 'СД':'Сделка','ВС':'Всячина','БЛ':'Благотворительность','ЧК':'Расчётный чек','РЫ':'Рынок','РБ':'Ребёнок','УВ':'Увольнение' };
      const typeLabel = (abbr === 'СД')
        ? (ns.dealType === 'small' ? 'Сделка (мелкая)' : (ns.dealType === 'large' ? 'Сделка (крупная)' : 'Сделка'))
        : (titleMap[abbr] || abbr);
      if (ns.cardChoice === true) {
        cardLabel = `Взял: ${typeLabel}`;
      } else if (ns.cardChoice === false) {
        cardLabel = `Не взял: ${typeLabel}`;
      }
    } catch {}
    
    // Статус кредита в записи
    let creditText = '';
    try {
      const creditHidden = (localStorage.getItem('cf_credit_hidden') === '1');
      if (ns.creditChoice === true) creditText = 'оформлен';
      else if (!creditHidden && ns.creditChoice === false) creditText = 'не получил';
    } catch {}
    
    // Рассчитываем капитал для этого хода
    const capital = Math.round(ns.balance||0) + computeCapitalFromCurrentState().invested + computeCapitalFromCurrentState().payoff;
    // Рассчитываем изменение баланса за этот ход
    const balanceChange = Array.isArray(ns.events) ? ns.events.reduce((sum, ev) => sum + (ev.delta || 0), 0) : 0;
    const rec = { num: turn, dice: ns.dice, card: cardLabel, cardChoice: ns.cardChoice, cashflowDone: !!ns.cashflowDone, monthly: Math.round(ensureMonthlyFromLedger()), creditTaken: !!ns.creditTaken, credit: creditText, balance: Math.round(ns.balance||0), capital: capital, balanceChange: balanceChange, time: Date.now(), timeFormatted: new Date().toLocaleString(), events: Array.isArray(ns.events)?ns.events.slice(0,50):[], comment: (ns.comment||'') };
    const turns = getTurns(); turns.unshift(rec); setTurns(turns);
    
    // Записываем в историю ходов завершение хода
    try{ addTurnEventForCurrentTurn(0, `Завершение хода ${turn} (принудительно)`); }catch{}
    try{ renderTurnsHistory(); }catch{}
    
    // Next turn: reset move choices but keep balance and monthly; clear per-turn events
    const next = { dice:null, card:null, cardChoice:null, dealType:null, cashflowDone:null, creditTaken:false, creditChoice:null, balance: ns.balance||0, monthly: ns.monthly||0, events: [], checksPassed: 0, doubleCashflowChoice: null };
    setMoveState(next);
    localStorage.setItem('cf_turn_number', String(turn+1));
    renderTurnsHistory();
    
    // Сбрасываем стартовую точку для нового хода
    const t = getTurnState(); t.startIndex = t.pos; setTurnState(t);
    // Включаем режим "После хода"
    setPostTurn({ num: turn, events: [] });
    renderMoves();
    
    // Снять визуальные галочки с кнопок хода
    try{
      document.getElementById('cashflowYes')?.classList.remove('active','btn-checkmark');
      document.getElementById('cashflowYes2')?.classList.remove('active','btn-checkmark');
      document.getElementById('cashflowYes3')?.classList.remove('active','btn-checkmark');
      document.getElementById('cashflowNo')?.classList.remove('active','btn-checkmark');
      document.getElementById('cashflowYes')?.classList.remove('recommend');
      document.getElementById('cashflowYes2')?.classList.remove('recommend');
      document.getElementById('cashflowYes3')?.classList.remove('recommend');
      document.getElementById('cashflowNo')?.classList.remove('recommend');
      document.getElementById('cashflowApplied') && (document.getElementById('cashflowApplied').textContent='');
      document.getElementById('cardYes')?.classList.remove('active','btn-checkmark');
      document.getElementById('cardNo')?.classList.remove('active','btn-checkmark');
      document.getElementById('cardYes')?.classList.remove('recommend');
      document.getElementById('cardNo')?.classList.remove('recommend');
      document.getElementById('cardStatus') && (document.getElementById('cardStatus').textContent='');
    }catch{}
    
    // Тост: ход завершен (быстро)
    try{ showToast(`Ход ${turn} завершен (принудительно)`, 500); }catch{}
  }

  // Функциональность для раздела Союз
  let unionCounter = 0;
  let unions = []; // Массив для хранения данных союзов
  
  // Функции для сохранения и загрузки союзов
  function saveUnions() {
    try {
      console.log('Saving unions to localStorage:', unions);
      localStorage.setItem('cf_unions', JSON.stringify(unions));
      localStorage.setItem('cf_unionCounter', unionCounter.toString());
      console.log('Unions saved successfully');
    } catch (e) {
      console.error('Ошибка сохранения союзов:', e);
    }
  }
  
  function loadUnions() {
    try {
      const savedUnions = localStorage.getItem('cf_unions');
      const savedCounter = localStorage.getItem('cf_unionCounter');
      
      console.log('Loading unions from localStorage:', savedUnions);
      
      if (savedUnions) {
        unions = JSON.parse(savedUnions);
        console.log('Loaded unions:', unions);
      }
      
      if (savedCounter) {
        unionCounter = parseInt(savedCounter);
      }
      
      // Восстанавливаем союзы
      renderUnions();
    } catch (e) {
      console.error('Ошибка загрузки союзов:', e);
      unions = [];
      unionCounter = 0;
    }
  }
  
  function renderUnions() {
    const unionsContainer = document.getElementById('unionsContainer');
    if (!unionsContainer) return;
    
    // Очищаем контейнер
    unionsContainer.innerHTML = '';
    
    // Восстанавливаем каждый союз
    unions.forEach(union => {
      const template = document.getElementById('unionDialogTemplate');
      const newUnion = template.cloneNode(true);
      newUnion.id = `union-${union.id}`;
      newUnion.style.display = 'block';
      
      // Создаем содержимое диалога
      const content = newUnion.querySelector('.union-content');
      content.innerHTML = createUnionDialogContent(union.id);
      
      // Добавляем в контейнер
      unionsContainer.appendChild(newUnion);
      
      // Восстанавливаем состояние союза после добавления в DOM
      setTimeout(() => {
        restoreUnionState(union);
      }, 100);
    });
  }
  
  function saveUnionState(unionId, step, value) {
    const union = unions.find(u => u.id === unionId);
    if (union) {
      if (!union.state) union.state = {};
      union.state[step] = value;
      union.state.timestamp = new Date().toISOString();
      saveUnions();
    }
  }
  
  function savePlayerName(unionId) {
    const nameInput = document.getElementById(`playerName-${unionId}`);
    const union = unions.find(u => u.id === unionId);
    if (union && nameInput) {
      union.playerName = nameInput.value;
      try {
        // Записываем только если значение имени изменилось относительно последней записи name_input
        const seq = Array.isArray(union.sequence) ? union.sequence : [];
        const lastName = [...seq].reverse().find(s => s.action === 'name_input');
        if (!lastName || (lastName && lastName.value !== nameInput.value)) {
          addToSequence(unionId, 'name_input', nameInput.value);
        }
      } catch {}
      saveUnions();
    }
  }
  
  function addToSequence(unionId, action, value) {
    const union = unions.find(u => u.id === unionId);
    if (union) {
      if (!union.sequence) union.sequence = [];
      union.sequence.push({
        action: action,
        value: value,
        timestamp: new Date().toISOString()
      });
      // Persist immediately so actions survive reloads
      try { saveUnions(); } catch {}
    }
  }
  
  function restoreUnionState(union) {
    console.log('Restoring union state for union:', union.id, union);
    
    // Восстанавливаем состояние полей
    if (union.playerName) {
      const nameInput = document.getElementById(`playerName-${union.id}`);
      if (nameInput) {
        nameInput.value = union.playerName;
        nameInput.style.display = 'block'; // Убеждаемся, что поле видно
        console.log('Restored player name:', union.playerName);
      } else {
        console.log('Name input not found for union:', union.id);
        // Попробуем найти через другой селектор
        const nameInput2 = document.querySelector(`#union-${union.id} input[placeholder*="имя"]`);
        if (nameInput2) {
          nameInput2.value = union.playerName;
          nameInput2.style.display = 'block';
          console.log('Found name input via alternative selector');
        }
      }
    }
    
    // Восстанавливаем подпись
    if (union.signature || union.signatureHTML) {
      console.log('Attempting to restore signature for union:', union.id, 'signature:', union.signature, 'signatureHTML:', union.signatureHTML);
      
      // Попробуем найти область подписи несколько раз с задержкой
      let attempts = 0;
      const maxAttempts = 5;
      
      const tryRestoreSignature = () => {
        const signatureArea = document.getElementById(`signatureArea-${union.id}`);
        console.log('Looking for signature area:', `signatureArea-${union.id}`, 'found:', !!signatureArea);
        
        if (signatureArea) {
          // Проверяем, есть ли HTML версия подписи
          if (union.signatureHTML) {
            console.log('Restoring signatureHTML for union:', union.id);
            // Используем HTML версию для восстановления (ожидаем <img ...>)
            signatureArea.innerHTML = union.signatureHTML;
            const img = signatureArea.querySelector('img');
            if (img) {
              img.style.pointerEvents = 'none';
              img.style.opacity = '0.7';
              img.style.background = '#f8f9fa';
            }
          } else if (union.signature && union.signature.includes('<canvas')) {
            console.log('Restoring old format signature for union:', union.id);
            // Если это старый формат с canvas в HTML
            signatureArea.innerHTML = union.signature;
            const img = signatureArea.querySelector('img');
            if (img) {
              img.style.pointerEvents = 'none';
              img.style.opacity = '0.7';
              img.style.background = '#f8f9fa';
            }
          } else if (union.signature && union.signature.startsWith('data:image/')) {
            console.log('Restoring data URL signature for union:', union.id);
            // Если это data URL, отображаем как <img>
            const img = document.createElement('img');
            img.src = union.signature;
            img.alt = 'signature';
            img.style.maxWidth = '100%';
            img.style.height = '60px';
            img.style.objectFit = 'contain';
            img.style.border = '1px solid #ccc';
            img.style.borderRadius = '4px';
            img.style.pointerEvents = 'none';
            img.style.opacity = '0.7';
            img.style.background = '#f8f9fa';
            signatureArea.innerHTML = '';
            signatureArea.appendChild(img);
          } else if (union.signature) {
            console.log('Restoring text signature for union:', union.id);
            // Если это обычный текст, показываем его
            signatureArea.innerHTML = union.signature;
          }
          console.log('Successfully restored signature for union:', union.id);
        } else if (attempts < maxAttempts) {
          console.log('Signature area not found, retrying...', attempts + 1, 'of', maxAttempts);
          attempts++;
          setTimeout(tryRestoreSignature, 50);
        } else {
          console.log('Signature area not found after', maxAttempts, 'attempts for union:', union.id);
        }
      };
      
      tryRestoreSignature();
    }
    
    // Восстанавливаем состояние на основе последовательности действий
    if (union.sequence && union.sequence.length > 0) {
      console.log('Restoring sequence for union:', union.id, union.sequence);
      
      // Сначала блокируем все кнопки выбора
      const choice1Buttons = document.querySelectorAll(`#union-${union.id} [data-group="choice1"]`);
      console.log('Found choice1 buttons:', choice1Buttons.length);
      choice1Buttons.forEach(btn => {
        btn.classList.add('disabled');
        btn.disabled = true;
      });
      
      // Восстанавливаем каждый шаг последовательности
      union.sequence.forEach((step, index) => {
        console.log(`Processing step ${index + 1}:`, step.action, step.value);
        switch(step.action) {
          case 'choice':
            if (step.value === 'trust') {
              const trustBtn = document.querySelector(`#union-${union.id} [onclick*="handleUnionChoice(${union.id}, 'trust')"]`);
              console.log('Looking for trust button:', trustBtn);
              if (trustBtn) {
                trustBtn.classList.add('selected');
                trustBtn.classList.remove('disabled');
                trustBtn.disabled = false;
                console.log('Selected trust button');
              }
            } else if (step.value === 'self') {
              const selfBtn = document.querySelector(`#union-${union.id} [onclick*="handleUnionChoice(${union.id}, 'self')"]`);
              console.log('Looking for self button:', selfBtn);
              if (selfBtn) {
                selfBtn.classList.add('selected');
                selfBtn.classList.remove('disabled');
                selfBtn.disabled = false;
                console.log('Selected self button');
              }
            }
            break;
            
          case 'trust_percent':
            const trustPercentDiv = document.getElementById(`union-${union.id}-trust-percent`);
            if (trustPercentDiv) {
              trustPercentDiv.classList.remove('union-hidden');
              // Блокируем кнопки процентов
              const trustButtons = document.querySelectorAll(`#union-${union.id} [data-group="trust"]`);
              trustButtons.forEach(btn => {
                btn.classList.add('disabled');
                btn.disabled = true;
              });
              // Выделяем выбранный процент
              const selectedPercentBtn = document.querySelector(`#union-${union.id} [onclick*="setTrustPercent(${union.id}, ${step.value})"]`);
              if (selectedPercentBtn) {
                selectedPercentBtn.classList.add('selected');
                selectedPercentBtn.classList.remove('disabled');
                selectedPercentBtn.disabled = false;
              }
            }
            break;
            
          case 'hundred_percent':
            const hundredPercentDiv = document.getElementById(`union-${union.id}-hundred-percent`);
            if (hundredPercentDiv) {
              hundredPercentDiv.classList.remove('union-hidden');
              // Блокируем кнопки
              const choice2Buttons = document.querySelectorAll(`#union-${union.id} [data-group="choice2"]`);
              choice2Buttons.forEach(btn => {
                btn.classList.add('disabled');
                btn.disabled = true;
              });
              // Выделяем выбранную кнопку
              const selectedBtn = document.querySelector(`#union-${union.id} [onclick*="handleHundredPercent(${union.id}, ${step.value})"]`);
              if (selectedBtn) {
                selectedBtn.classList.add('selected');
                selectedBtn.classList.remove('disabled');
                selectedBtn.disabled = false;
              }
            }
            break;
            
          case 'password':
            // Пароль уже введен, определяем следующий этап
            if (step.value === 'correct') {
              // Ищем следующий шаг в последовательности
              const nextStep = union.sequence[index + 1];
              if (nextStep) {
                // Показываем соответствующий этап
                if (nextStep.action === 'agreement') {
                  const agreementDiv = document.getElementById(`union-${union.id}-agreement`);
                  if (agreementDiv) agreementDiv.classList.remove('union-hidden');
                } else if (nextStep.action === 'final_agreement') {
                  const conditionsDiv = document.getElementById(`union-${union.id}-conditions`);
                  if (conditionsDiv) conditionsDiv.classList.remove('union-hidden');
                } else if (nextStep.action === 'signature') {
                  const signatureDiv = document.getElementById(`union-${union.id}-signature`);
                  if (signatureDiv) signatureDiv.classList.remove('union-hidden');
                }
              }
            }
            break;
            
          case 'agreement':
            const agreementDiv = document.getElementById(`union-${union.id}-agreement`);
            if (agreementDiv) {
              agreementDiv.classList.remove('union-hidden');
              // Блокируем кнопки
              const choice3Buttons = document.querySelectorAll(`#union-${union.id} [data-group="choice3"]`);
              choice3Buttons.forEach(btn => {
                btn.classList.add('disabled');
                btn.disabled = true;
              });
              // Выделяем выбранную кнопку
              const selectedBtn = document.querySelector(`#union-${union.id} [onclick*="handleAgreement(${union.id}, ${step.value})"]`);
              if (selectedBtn) {
                selectedBtn.classList.add('selected');
                selectedBtn.classList.remove('disabled');
                selectedBtn.disabled = false;
              }
            }
            break;
            
          case 'final_agreement':
            const conditionsDiv = document.getElementById(`union-${union.id}-conditions`);
            if (conditionsDiv) {
              conditionsDiv.classList.remove('union-hidden');
              // Блокируем кнопки
              const choice4Buttons = document.querySelectorAll(`#union-${union.id} [data-group="choice4"]`);
              choice4Buttons.forEach(btn => {
                btn.classList.add('disabled');
                btn.disabled = true;
              });
              // Выделяем выбранную кнопку
              const selectedBtn = document.querySelector(`#union-${union.id} [onclick*="handleFinalAgreement(${union.id}, ${step.value})"]`);
              if (selectedBtn) {
                selectedBtn.classList.add('selected');
                selectedBtn.classList.remove('disabled');
                selectedBtn.disabled = false;
              }
            }
            break;
            
          case 'signature':
            const signatureDiv = document.getElementById(`union-${union.id}-signature`);
            if (signatureDiv) {
              signatureDiv.classList.remove('union-hidden');
            }
            break;
            
          case 'concluded':
            const concludedDiv = document.getElementById(`union-${union.id}-concluded`);
            if (concludedDiv) {
              concludedDiv.classList.remove('union-hidden');
              // Скрываем поля ввода
              const nameInput = document.getElementById(`playerName-${union.id}`);
              if (nameInput) {
                nameInput.style.display = 'none';
              }
              // Показываем имя в readonly поле
              const nameReadonlyInput = document.getElementById(`playerNameReadonly-${union.id}`);
              if (nameReadonlyInput && union.playerName) {
                nameReadonlyInput.value = union.playerName;
                nameReadonlyInput.style.display = 'block';
              }
              // Делаем подпись нередактируемой
              const signatureArea = document.getElementById(`signatureArea-${union.id}`);
              if (signatureArea) {
                signatureArea.style.pointerEvents = 'none';
                signatureArea.style.opacity = '0.7';
                signatureArea.style.background = '#f8f9fa';
              }
            }
            break;
        }
      });
    }
  }
  
  function addUnion() {
    unionCounter++;
    const unionsContainer = document.getElementById('unionsContainer');
    const template = document.getElementById('unionDialogTemplate');
    
    // Создаем объект союза
    const newUnion = {
      id: unionCounter,
      playerName: '',
      signature: '',
      state: {},
      sequence: [], // Массив для хранения последовательности действий
      createdAt: new Date().toISOString()
    };
    
    // Добавляем в массив союзов
    unions.push(newUnion);
    
    // Клонируем шаблон
    const newUnionElement = template.cloneNode(true);
    newUnionElement.id = `union-${unionCounter}`;
    newUnionElement.style.display = 'block';
    
    // Создаем содержимое диалога
    const content = newUnionElement.querySelector('.union-content');
    content.innerHTML = createUnionDialogContent(unionCounter);
    
    // Добавляем визуальный отступ в 25 строк перед каждым новым союзом,
    // чтобы предыдущий контент не был виден выше
    try {
      const spacer = document.createElement('div');
      spacer.className = 'union-spacer';
      spacer.setAttribute('aria-hidden', 'true');
      // Пытаемся вычислить реальную высоту строки
      const bodyStyle = getComputedStyle(document.body);
      let lineHeightPx = 0;
      const lh = bodyStyle.lineHeight;
      if (lh && lh !== 'normal') {
        lineHeightPx = parseFloat(lh);
      } else {
        // fallback: ~1.2 × font-size
        lineHeightPx = (parseFloat(bodyStyle.fontSize) || 16) * 1.2;
      }
      const h = Math.max(1, Math.round(lineHeightPx)) * 25; // 25 строк
      spacer.style.height = h + 'px';
      spacer.style.pointerEvents = 'none';
      spacer.style.userSelect = 'none';
      spacer.style.opacity = '0';
      unionsContainer.appendChild(spacer);
    } catch {}

    // Добавляем в контейнер
    unionsContainer.appendChild(newUnionElement);
    
    // Сохраняем союзы
    saveUnions();

    // Фиксируем показ первого текста в последовательности
    try { addToSequence(unionCounter, 'text', 'text1'); } catch {}
    
    // Прокручиваем к новому союзу
    newUnionElement.scrollIntoView({ behavior: 'smooth' });
  }
  
  function createUnionDialogContent(unionId) {
    return `
      <div style="display:flex;justify-content:flex-end;margin-bottom:8px;gap:6px;">
        <button class="union-edit-btn" onclick="deleteUnion(${unionId})" title="Удалить союз" style="background:#dc3545;width:36px;height:36px;font-size:18px;display:flex;align-items:center;justify-content:center;">✖</button>
      </div>
      
      <div class="union-text" id="union-${unionId}-text1" data-text="Если бы я сказал вам, что я профессиональный игрок и могу очень сильно усилить вас\n\nТо смогли бы вы полностью доверится моим советам\nИли вы предпочли бы действовать по-своему">
        Если бы я сказал вам, что я профессиональный игрок и могу очень сильно усилить вас<br><br>
        То смогли бы вы полностью доверится моим советам<br>
        Или вы предпочли бы действовать по-своему
      </div>
      
      <div class="union-buttons" style="display:grid;grid-template-columns:repeat(2,1fr);gap:8px;margin:12px 0;">
        <button class="union-btn primary" onclick="handleUnionChoice(${unionId}, 'trust')" data-group="choice1">Могу довериться</button>
        <button class="union-btn secondary" onclick="handleUnionChoice(${unionId}, 'self')" data-group="choice1">Предпочту сам</button>
      </div>
      
      <div id="union-${unionId}-trust-percent" class="union-hidden">
        <div class="union-text" id="union-${unionId}-text2" data-text="Насколько процентов смогли бы довериться мне">Насколько процентов смогли бы довериться мне</div>
        <div class="union-buttons" style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin:12px 0;">
          <button class="union-btn secondary" onclick="setTrustPercent(${unionId}, 0)" data-group="trust">0%</button>
          <button class="union-btn secondary" onclick="setTrustPercent(${unionId}, 20)" data-group="trust">20%</button>
          <button class="union-btn secondary" onclick="setTrustPercent(${unionId}, 40)" data-group="trust">40%</button>
          <button class="union-btn secondary" onclick="setTrustPercent(${unionId}, 60)" data-group="trust">60%</button>
          <button class="union-btn secondary" onclick="setTrustPercent(${unionId}, 80)" data-group="trust">80%</button>
          <button class="union-btn secondary" onclick="setTrustPercent(${unionId}, 100)" data-group="trust">100%</button>
        </div>
      </div>
      
      <div id="union-${unionId}-hundred-percent" class="union-hidden">
        <div class="union-text" id="union-${unionId}-text3" data-text="А на 100% смогли бы?">А на 100% смогли бы?</div>
        <div class="union-buttons" style="display:grid;grid-template-columns:repeat(2,1fr);gap:8px;margin:12px 0;">
          <button class="union-btn success" onclick="handleHundredPercent(${unionId}, true)" data-group="choice2">Да</button>
          <button class="union-btn danger" onclick="handleHundredPercent(${unionId}, false)" data-group="choice2">Нет</button>
        </div>
        <div style="height: 16px;"></div>
      </div>
      
      <div id="union-${unionId}-password" class="union-hidden">
        <div class="union-text" id="union-${unionId}-text4" data-text="Верните телефон владельцу">Верните телефон владельцу</div>
        <div class="union-input-group">
          <input type="password" class="union-input" id="password-${unionId}" placeholder="Пароль" onkeypress="if(event.key==='Enter') handlePassword(${unionId})">
          <button class="union-btn" onclick="handlePassword(${unionId})" style="margin-top:8px;width:100%;">Проверить пароль</button>
        </div>
      </div>
      
      <div id="union-${unionId}-agreement" class="union-hidden">
        <div class="union-text" id="union-${unionId}-text5" data-text="Хорошо, тогда я предлагаю доверится полностью и придти к совместной победе в союзе\n\nЕсли мы победим, то поделим приз на двоих, вам сладкий приз, мне сертификат\nПлюс я лично буду обучать вас всю игру\n\nНо вам нужно будет делать то что я вам скажу\nВы согласны на такие условия?">
          Хорошо, тогда я предлагаю доверится полностью и придти к совместной победе в союзе<br><br>
          Если мы победим, то поделим приз на двоих, вам <strong>сладкий приз</strong>, мне сертификат<br>
          Плюс я лично буду обучать вас всю игру<br><br>
          Но вам нужно будет делать то что я вам скажу<br>
          Вы согласны на такие условия?
        </div>
        <div class="union-buttons" style="display:grid;grid-template-columns:repeat(2,1fr);gap:8px;margin:12px 0;">
          <button class="union-btn success" onclick="handleAgreement(${unionId}, true)" data-group="choice3">Да</button>
          <button class="union-btn danger" onclick="handleAgreement(${unionId}, false)" data-group="choice3">Нет</button>
        </div>
        <div style="height: 16px;"></div>
      </div>
      
      <div id="union-${unionId}-password-agreement" class="union-hidden">
        <div class="union-text" style="color:#dc3545;font-weight:bold;text-align:center;padding:20px;border:2px solid #dc3545;border-radius:8px;background:#f8d7da;">
          Передайте телефон владельцу
        </div>
        <div class="union-input-group" style="margin-top:12px;">
          <input type="password" class="union-input" id="password-agreement-${unionId}" placeholder="Введите пароль" onkeypress="if(event.key==='Enter') handlePasswordAgreement(${unionId})">
          <button class="union-btn" onclick="handlePasswordAgreement(${unionId})" style="margin-top:8px;width:100%;">Проверить пароль</button>
        </div>
      </div>
      
      <div id="union-${unionId}-conditions" class="union-hidden">
        <div class="union-text bold" id="union-${unionId}-text6" data-text="Что вам надо будет сделать:">Что вам надо будет сделать:</div>
        <div class="union-text blue-border" id="union-${unionId}-text7" data-text="Взять игровой кредит и передать его Дмитрию">Взять игровой кредит и передать его Дмитрию</div>
        
        <div class="union-text bold" id="union-${unionId}-text8" data-text="Что вы получите взамен:">Что вы получите взамен:</div>
        <div class="union-text green-border" id="union-${unionId}-text9" data-text="Сладкий приз (если победим)\n\nПрофессионального игрока в наставники, который будет следить за вашей ведомостью и давать советы по игре">
          <strong>Сладкий приз</strong> (если победим)<br><br>
          <strong>Профессионального игрока в наставники</strong>, который будет следить за вашей ведомостью и давать советы по игре
        </div>
        
        <div class="union-text" id="union-${unionId}-text10" data-text="На всякий случай вот сценарий выхода из союза, если вы вдруг захотите разойтись. Но этого крайне не рекомендуется делать\n\nТогда обучение заканчивается, вы не получите сладкого приза\nи Дмитрий вернет вам полную сумму кредита во второй половине 3-его раунда игры (он будет после двух перерывов)">
          На всякий случай вот сценарий выхода из союза, если вы вдруг захотите разойтись. Но этого крайне не рекомендуется делать<br><br>
          Тогда обучение заканчивается, вы не получите <strong>сладкого приза</strong><br>
          и Дмитрий вернет вам полную сумму кредита во второй половине 3-его раунда игры (он будет после двух перерывов)
        </div>
        
        <div class="union-text large-bold" id="union-${unionId}-text11" data-text="Согласны?">Согласны?</div>
        <div class="union-buttons" style="display:grid;grid-template-columns:repeat(2,1fr);gap:8px;margin:12px 0;">
          <button class="union-btn success" onclick="handleFinalAgreement(${unionId}, true)" data-group="choice4">Согласен</button>
          <button class="union-btn danger" onclick="handleFinalAgreement(${unionId}, false)" data-group="choice4">Не согласен</button>
        </div>
        <div style="height: 16px;"></div>
      </div>
      
      <div id="union-${unionId}-password" class="union-hidden">
        <div class="union-text" style="color:#dc3545;font-weight:bold;text-align:center;padding:20px;border:2px solid #dc3545;border-radius:8px;background:#f8d7da;">
          Передайте телефон владельцу
        </div>
        <div class="union-input-group" style="margin-top:12px;">
          <input type="password" class="union-input" id="password-${unionId}" placeholder="Введите пароль" onkeypress="if(event.key==='Enter') handlePassword(${unionId})">
          <button class="union-btn" onclick="handlePassword(${unionId})" style="margin-top:8px;width:100%;">Проверить пароль</button>
        </div>
      </div>
      
      <div id="union-${unionId}-signature" class="union-hidden">
        <div class="union-input-group">
          <input type="text" class="union-input" id="playerName-${unionId}" placeholder="Введите ваше имя" oninput="savePlayerName(${unionId})">
        </div>
        <div class="union-text" id="union-${unionId}-text12" data-text="Распишитесь">Распишитесь</div>
        <div class="union-signature-area" id="signatureArea-${unionId}" onclick="if(!this.querySelector('canvas')) startSignature(${unionId})">
          <div id="signature-${unionId}">Нажмите здесь для подписи</div>
        </div>
        <div id="union-${unionId}-signature-complete" class="union-hidden">
          <div class="union-text">Передайте телефон владельцу</div>
          <div style="margin:12px 0;display:flex;gap:8px;align-items:center;">
            <button class="union-btn" onclick="eraseSignature(${unionId})" style="background:#6c757d;color:#fff;padding:4px 8px;font-size:12px;opacity:0.7;">Стереть</button>
            <button class="union-btn" onclick="concludeUnion(${unionId})" style="background:#ffd700;color:#000;padding:8px 16px;font-weight:bold;">Заключить союз</button>
          </div>
        </div>
        <div id="union-${unionId}-concluded" class="union-hidden">
          <div class="union-input-group">
            <input type="text" class="union-input" id="playerNameReadonly-${unionId}" readonly style="background:#f8f9fa;color:#6c757d;">
          </div>
          <div class="union-text" style="color:#6c757d;">Подпись зафиксирована</div>
          <div class="union-text" style="color:#28a745;font-weight:bold;">✅ Союз заключен!</div>
          <div style="margin-top: 12px; text-align: right; display:block;">
            <button class="btn" onclick="exportUnion(${unionId})" title="Скачать" aria-label="Скачать союз" style="background:#e9ecef;color:#495057;border:1px solid #adb5bd;padding:8px 10px;border-radius:6px;font-size:18px;display:inline-flex;align-items:center;">📥</button>
          </div>
        </div>
      </div>
    `;
  }
  
  function handleUnionChoice(unionId, choice) {
    // Блокируем только кнопки группы choice1
    const choice1Buttons = document.querySelectorAll(`#union-${unionId} [data-group="choice1"]`);
    choice1Buttons.forEach(btn => {
      btn.classList.remove('selected');
      btn.classList.add('disabled');
      btn.disabled = true;
    });
    
    // Выделяем выбранную кнопку
    event.target.classList.add('selected');
    event.target.classList.remove('disabled');
    event.target.disabled = false;
    
    if (choice === 'trust') {
      const trustPercentDiv = document.getElementById(`union-${unionId}-trust-percent`);
      trustPercentDiv.classList.remove('union-hidden');
      // Сначала фиксируем нажатую кнопку, затем показываем и фиксируем текст 2
      addToSequence(unionId, 'choice', 'trust');
      try { addToSequence(unionId, 'text', 'text2'); } catch {}
      saveUnionState(unionId, 'trust-choice', true);
    } else {
      const passwordDiv = document.getElementById(`union-${unionId}-password`);
      passwordDiv.classList.remove('union-hidden');
      // Для ветки "сам" логика текста и фиксации кнопки может отличаться, но сохраняем порядок: текст -> кнопка
      // Здесь отдельного текста нет, поэтому фиксируем кнопку сразу
      addToSequence(unionId, 'choice', 'self');
      saveUnionState(unionId, 'self-choice', true);
    }
  }
  
  function setTrustPercent(unionId, percent) {
    // Блокируем только кнопки процентов доверия
    const trustButtons = document.querySelectorAll(`#union-${unionId} [data-group="trust"]`);
    trustButtons.forEach(btn => {
      btn.classList.remove('selected');
      btn.classList.add('disabled');
      btn.disabled = true;
    });
    
    // Выделяем выбранную кнопку
    const selectedButton = document.querySelector(`#union-${unionId} [data-group="trust"][onclick*="${percent}"]`);
    if (selectedButton) {
      selectedButton.classList.add('selected');
      selectedButton.classList.remove('disabled');
      selectedButton.disabled = false;
    }
    
    // Сначала фиксируем сам выбор процента (кнопка)
    try { addToSequence(unionId, 'trust_percent', percent); } catch {}

    // Затем показываем следующий текст сразу без задержки
    if (percent === 100) {
      // Если выбран 100%, сразу переходим к соглашению
      const agreementDiv = document.getElementById(`union-${unionId}-agreement`);
      agreementDiv.classList.remove('union-hidden');
      // Фиксируем текст 5 после показа
      try { addToSequence(unionId, 'text', 'text5'); } catch {}
    } else {
      // Для других процентов показываем вопрос "А на 100% смогли бы?" для уточнения
      const hundredPercentDiv = document.getElementById(`union-${unionId}-hundred-percent`);
      hundredPercentDiv.classList.remove('union-hidden');
      // Фиксируем текст 3 после показа
      try { addToSequence(unionId, 'text', 'text3'); } catch {}
      // Затем фиксируем сводку процента доверия, чтобы шла после вопроса
      try { addToSequence(unionId, 'trust_percent_summary', percent); } catch {}
    }
  }
  
  function handleTrustPercent(unionId) {
    const input = document.getElementById(`trustPercent-${unionId}`);
    const hundredPercentDiv = document.getElementById(`union-${unionId}-hundred-percent`);
    
    if (input.value && parseInt(input.value) >= 0) {
      hundredPercentDiv.classList.remove('union-hidden');
    }
  }
  
  function handleHundredPercent(unionId, isHundred) {
    // Блокируем только кнопки группы choice2
    const choice2Buttons = document.querySelectorAll(`#union-${unionId} [data-group="choice2"]`);
    choice2Buttons.forEach(btn => {
      btn.classList.remove('selected');
      btn.classList.add('disabled');
      btn.disabled = true;
    });
    
    // Выделяем выбранную кнопку
    event.target.classList.add('selected');
    event.target.classList.remove('disabled');
    event.target.disabled = false;
    
    if (isHundred) {
      // Показать соглашение
      const agreementDiv = document.getElementById(`union-${unionId}-agreement`);
      agreementDiv.classList.remove('union-hidden');
      // Сначала фиксируем нажатую кнопку, затем текст 5
      addToSequence(unionId, 'hundred_percent', isHundred);
      try { addToSequence(unionId, 'text', 'text5'); } catch {}
    } else {
      // Показать поле пароля сразу без задержки
      const passwordDiv = document.getElementById(`union-${unionId}-password`);
      passwordDiv.classList.remove('union-hidden');
      // Фиксируем нажатую кнопку
      addToSequence(unionId, 'hundred_percent', isHundred);
    }
  }
  
  function handlePassword(unionId) {
    const input = document.getElementById(`password-${unionId}`);
    if (input.value === '1111') {
      // Скрываем поле пароля
      const passwordDiv = document.getElementById(`union-${unionId}-password`);
      if (passwordDiv) {
        passwordDiv.classList.add('union-hidden');
      }
      
      // Добавляем в последовательность
      addToSequence(unionId, 'password', 'correct');
      
      // Проверяем, какой раздел нужно показать в зависимости от контекста
      const conditionsDiv = document.getElementById(`union-${unionId}-conditions`);
      const agreementDiv = document.getElementById(`union-${unionId}-agreement`);
      const signatureDiv = document.getElementById(`union-${unionId}-signature`);
      
      // Приоритет: сначала соглашение (для "Предпочту сам"), потом условия, потом подпись
      if (agreementDiv) {
        // Показать соглашение (для "Предпочту сам" и других вопросов)
        agreementDiv.classList.remove('union-hidden');
        try { addToSequence(unionId, 'text', 'text5'); } catch {}
      } else if (conditionsDiv) {
        // Показать условия (для вопроса "А на 100% смогли бы?")
        conditionsDiv.classList.remove('union-hidden');
        try {
          addToSequence(unionId, 'text', 'text6');
          addToSequence(unionId, 'text', 'text7');
          addToSequence(unionId, 'text', 'text8');
          addToSequence(unionId, 'text', 'text9');
          addToSequence(unionId, 'text', 'text10');
          addToSequence(unionId, 'text', 'text11');
        } catch {}
      } else if (signatureDiv) {
        // Показать форму подписи (для вопроса "Согласны?")
        signatureDiv.classList.remove('union-hidden');
        try { addToSequence(unionId, 'text', 'text12'); } catch {}
      }
    } else if (input.value.length > 0) {
      // Показать сообщение "Передайте телефон владельцу"
      const passwordDiv = document.getElementById(`union-${unionId}-password`);
      passwordDiv.classList.add('union-hidden');
      
      // Добавляем в последовательность
      addToSequence(unionId, 'password', 'incorrect');
      
      // Создаем сообщение о передаче телефона
      const messageDiv = document.createElement('div');
      messageDiv.className = 'union-text';
      messageDiv.style.color = '#dc3545';
      messageDiv.style.fontWeight = 'bold';
      messageDiv.style.textAlign = 'center';
      messageDiv.style.padding = '20px';
      messageDiv.style.border = '2px solid #dc3545';
      messageDiv.style.borderRadius = '8px';
      messageDiv.style.background = '#f8d7da';
      messageDiv.innerHTML = 'Передайте телефон владельцу';
      messageDiv.id = `password-message-${unionId}`;
      
      // Вставляем сообщение после секции пароля
      passwordDiv.parentNode.insertBefore(messageDiv, passwordDiv.nextSibling);
      
      // Через 3 секунды показываем поле пароля снова
      setTimeout(() => {
        // Удаляем сообщение
        const message = document.getElementById(`password-message-${unionId}`);
        if (message) {
          message.remove();
        }
        
        // Показываем поле пароля снова
        passwordDiv.classList.remove('union-hidden');
        
        // Очищаем поле пароля
        input.value = '';
      }, 3000);
    }
  }
  
  function handlePasswordAgreement(unionId) {
    const input = document.getElementById(`password-agreement-${unionId}`);
    if (input.value === '1111') {
      addToSequence(unionId, 'password_agreement', 'correct');
      // Скрываем поле пароля
      const passwordDiv = document.getElementById(`union-${unionId}-password-agreement`);
      if (passwordDiv) {
        passwordDiv.classList.add('union-hidden');
      }
      
      // Показать условия
      const conditionsDiv = document.getElementById(`union-${unionId}-conditions`);
      conditionsDiv.classList.remove('union-hidden');
      // Фиксируем тексты условий в последовательности (6..11), чтобы экспорт шёл в правильном порядке
      try {
        addToSequence(unionId, 'text', 'text6');
        addToSequence(unionId, 'text', 'text7');
        addToSequence(unionId, 'text', 'text8');
        addToSequence(unionId, 'text', 'text9');
        addToSequence(unionId, 'text', 'text10');
        addToSequence(unionId, 'text', 'text11');
      } catch {}
    } else if (input.value.length > 0) {
      addToSequence(unionId, 'password_agreement', 'incorrect');
      // Показать сообщение "Передайте телефон владельцу"
      const passwordDiv = document.getElementById(`union-${unionId}-password-agreement`);
      passwordDiv.classList.add('union-hidden');
      
      // Создаем сообщение о передаче телефона
      const messageDiv = document.createElement('div');
      messageDiv.className = 'union-text';
      messageDiv.style.color = '#dc3545';
      messageDiv.style.fontWeight = 'bold';
      messageDiv.style.textAlign = 'center';
      messageDiv.style.padding = '20px';
      messageDiv.style.border = '2px solid #dc3545';
      messageDiv.style.borderRadius = '8px';
      messageDiv.style.background = '#f8d7da';
      messageDiv.innerHTML = 'Передайте телефон владельцу';
      messageDiv.id = `password-agreement-message-${unionId}`;
      
      // Вставляем сообщение после секции пароля
      passwordDiv.parentNode.insertBefore(messageDiv, passwordDiv.nextSibling);
      
      // Через 3 секунды показываем поле пароля снова
      setTimeout(() => {
        // Удаляем сообщение
        const message = document.getElementById(`password-agreement-message-${unionId}`);
        if (message) {
          message.remove();
        }
        
        // Показываем поле пароля снова
        passwordDiv.classList.remove('union-hidden');
        
        // Очищаем поле пароля
        input.value = '';
      }, 3000);
    }
  }
  
  function handleAgreement(unionId, agreed) {
    // Блокируем только кнопки группы choice3
    const choice3Buttons = document.querySelectorAll(`#union-${unionId} [data-group="choice3"]`);
    choice3Buttons.forEach(btn => {
      btn.classList.remove('selected');
      btn.classList.add('disabled');
      btn.disabled = true;
    });
    
    // Выделяем выбранную кнопку
    event.target.classList.add('selected');
    event.target.classList.remove('disabled');
    event.target.disabled = false;
    
    if (agreed) {
      // Показать условия
      const conditionsDiv = document.getElementById(`union-${unionId}-conditions`);
      conditionsDiv.classList.remove('union-hidden');
      // Сначала фиксируем нажатую кнопку, затем последовательно тексты 6..11
      addToSequence(unionId, 'agreement', agreed); // Кнопка: Да/Нет
      try {
        addToSequence(unionId, 'text', 'text6');
        addToSequence(unionId, 'text', 'text7');
        addToSequence(unionId, 'text', 'text8');
        addToSequence(unionId, 'text', 'text9');
        addToSequence(unionId, 'text', 'text10');
        addToSequence(unionId, 'text', 'text11');
      } catch {}
    } else {
      // Показать сообщение "Передайте телефон владельцу" и поле пароля
      const passwordDiv = document.getElementById(`union-${unionId}-password-agreement`);
      passwordDiv.classList.remove('union-hidden');
      addToSequence(unionId, 'agreement', agreed); // Кнопка: Нет
    }
  }
  
  function createFinalPasswordField(unionId) {
    // Создаем поле пароля для вопроса "Согласны?"
    const passwordDiv = document.createElement('div');
    passwordDiv.id = `union-${unionId}-password-final`;
    passwordDiv.className = 'union-hidden';
    passwordDiv.innerHTML = `
      <div class="union-text" style="color:#dc3545;font-weight:bold;text-align:center;padding:20px;border:2px solid #dc3545;border-radius:8px;background:#f8d7da;">
        Передайте телефон владельцу
      </div>
      <div class="union-input-group" style="margin-top:12px;">
        <input type="password" class="union-input" id="password-final-${unionId}" placeholder="Введите пароль" onkeypress="if(event.key==='Enter') handlePasswordFinal(${unionId})">
        <button class="union-btn" onclick="handlePasswordFinal(${unionId})" style="margin-top:8px;width:100%;">Проверить пароль</button>
      </div>
    `;
    
    // Вставляем поле пароля после кнопок "Согласны?"
    const unionElement = document.getElementById(`union-${unionId}`);
    if (unionElement) {
      unionElement.appendChild(passwordDiv);
    }
    
    // Показываем поле пароля
    passwordDiv.classList.remove('union-hidden');
  }
  
  function handlePasswordFinal(unionId) {
    const input = document.getElementById(`password-final-${unionId}`);
    if (input.value === '1111') {
      addToSequence(unionId, 'password_final', 'correct');
      // Скрываем поле пароля
      const passwordDiv = document.getElementById(`union-${unionId}-password-final`);
      if (passwordDiv) {
        passwordDiv.classList.add('union-hidden');
      }
      
      // Показать форму подписи
      const signatureDiv = document.getElementById(`union-${unionId}-signature`);
      signatureDiv.classList.remove('union-hidden');
    } else if (input.value.length > 0) {
      addToSequence(unionId, 'password_final', 'incorrect');
      // Показать сообщение "Передайте телефон владельцу"
      const passwordDiv = document.getElementById(`union-${unionId}-password-final`);
      passwordDiv.classList.add('union-hidden');
      
      // Создаем сообщение о передаче телефона
      const messageDiv = document.createElement('div');
      messageDiv.className = 'union-text';
      messageDiv.style.color = '#dc3545';
      messageDiv.style.fontWeight = 'bold';
      messageDiv.style.textAlign = 'center';
      messageDiv.style.padding = '20px';
      messageDiv.style.border = '2px solid #dc3545';
      messageDiv.style.borderRadius = '8px';
      messageDiv.style.background = '#f8d7da';
      messageDiv.innerHTML = 'Передайте телефон владельцу';
      messageDiv.id = `password-final-message-${unionId}`;
      
      // Вставляем сообщение после секции пароля
      passwordDiv.parentNode.insertBefore(messageDiv, passwordDiv.nextSibling);
      
      // Через 3 секунды показываем поле пароля снова
      setTimeout(() => {
        // Удаляем сообщение
        const message = document.getElementById(`password-final-message-${unionId}`);
        if (message) {
          message.remove();
        }
        
        // Показываем поле пароля снова
        passwordDiv.classList.remove('union-hidden');
        
        // Очищаем поле пароля
        input.value = '';
      }, 3000);
    }
  }
  
  function handleFinalAgreement(unionId, agreed) {
    // Блокируем только кнопки группы choice4
    const choice4Buttons = document.querySelectorAll(`#union-${unionId} [data-group="choice4"]`);
    choice4Buttons.forEach(btn => {
      btn.classList.remove('selected');
      btn.classList.add('disabled');
      btn.disabled = true;
    });
    
    // Выделяем выбранную кнопку
    event.target.classList.add('selected');
    event.target.classList.remove('disabled');
    event.target.disabled = false;
    
    if (agreed) {
      addToSequence(unionId, 'final_agreement', agreed); // Кнопка: Согласен
      // Показать форму подписи
      const signatureDiv = document.getElementById(`union-${unionId}-signature`);
      signatureDiv.classList.remove('union-hidden');
      // Текст 12 стал виден
      try { addToSequence(unionId, 'text', 'text12'); } catch {}
    } else {
      // Показать сообщение "Передайте телефон владельцу" и поле пароля
      const passwordDiv = document.getElementById(`union-${unionId}-password-final`);
      if (passwordDiv) {
        passwordDiv.classList.remove('union-hidden');
      } else {
        // Если поле не существует, создаем его
        createFinalPasswordField(unionId);
      }
      // Фиксируем нажатую кнопку
      addToSequence(unionId, 'final_agreement', agreed); // Кнопка: Не согласен
    }
  }
  
  function startSignature(unionId) {
    console.log('Starting signature for union:', unionId);
    const signatureArea = document.getElementById(`signatureArea-${unionId}`);
    const signatureDiv = document.getElementById(`signature-${unionId}`);
    
    if (!signatureArea || !signatureDiv) {
      console.error('Signature area or div not found for union:', unionId);
      return;
    }
    
    // Проверяем, есть ли уже canvas в области подписи
    const existingCanvas = signatureArea.querySelector('canvas');
    if (existingCanvas) {
      console.log('Canvas already exists, not creating new one');
      return;
    }
    
    // Простая реализация подписи с поддержкой мобильных устройств
    const canvas = document.createElement('canvas');
    canvas.width = signatureArea.offsetWidth - 40;
    canvas.height = 60;
    canvas.style.border = '1px solid #ccc';
    canvas.style.borderRadius = '4px';
    canvas.style.cursor = 'crosshair';
    canvas.style.touchAction = 'none'; // Важно для мобильных устройств
    
    console.log('Canvas created with size:', canvas.width, 'x', canvas.height);
    
    const ctx = canvas.getContext('2d');
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 2;
    let isDrawing = false;
    
    function startDraw(e) {
      console.log('Starting to draw signature');
      isDrawing = true;
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX || e.touches[0].clientX) - rect.left;
      const y = (e.clientY || e.touches[0].clientY) - rect.top;
      console.log('Start position:', x, y);
      ctx.beginPath();
      ctx.moveTo(x, y);
    }
    
    function draw(e) {
      if (isDrawing) {
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX || e.touches[0].clientX) - rect.left;
        const y = (e.clientY || e.touches[0].clientY) - rect.top;
        ctx.lineTo(x, y);
        ctx.stroke();
      }
    }
    
    function stopDraw() {
      isDrawing = false;
      
      // Проверяем, есть ли что-то нарисованное на canvas
      const ctx = canvas.getContext('2d');
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const hasContent = imageData.data.some((value, index) => {
        // Проверяем альфа-канал (каждый 4-й элемент)
        return index % 4 === 3 && value > 0;
      });
      
      if (hasContent) {
        console.log('Signature drawn, saving...');
        
        // Сохраняем подпись
        const union = unions.find(u => u.id === unionId);
        if (union) {
          // Сохраняем canvas как data URL для восстановления
          const dataURL = canvas.toDataURL();
          // Сохраняем и HTML (<img>) и data URL для надежности
          union.signature = dataURL;
          union.signatureHTML = `<img src="${dataURL}" alt="signature" style="max-width:100%;height:60px;object-fit:contain;border:1px solid #ccc;border-radius:4px;pointer-events:none;opacity:0.7;background:#f8f9fa;">`;
          addToSequence(unionId, 'signature', 'drawn');
          saveUnions();
          console.log('Signature saved for union:', unionId);
        }
        
        // Отображаем сохраненную подпись как <img> вместо холста для一致ного восстановления
        const signatureArea = document.getElementById(`signatureArea-${unionId}`);
        if (signatureArea) {
          signatureArea.innerHTML = union.signatureHTML || '';
        }
        
        // Показываем сообщение о завершении подписи
        const completeDiv = document.getElementById(`union-${unionId}-signature-complete`);
        if (completeDiv) {
          completeDiv.classList.remove('union-hidden');
        }
        
        // Убираем обработчик клика с области подписи, чтобы не создавать новый canvas
        if (signatureArea) {
          signatureArea.onclick = null;
        }
      } else {
        console.log('No signature content detected');
      }
    }
    
    // События для мыши
    canvas.addEventListener('mousedown', startDraw);
    canvas.addEventListener('mousemove', draw);
    canvas.addEventListener('mouseup', stopDraw);
    canvas.addEventListener('mouseleave', stopDraw); // Сохраняем при уходе мыши
    
    // События для сенсорных устройств
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      startDraw(e);
    });
    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      draw(e);
    });
    canvas.addEventListener('touchend', (e) => {
      e.preventDefault();
      stopDraw();
    });
    
    signatureDiv.innerHTML = '';
    signatureDiv.appendChild(canvas);
  }
  
  function eraseSignature(unionId) {
    const signatureArea = document.getElementById(`signatureArea-${unionId}`);
    const signatureDiv = document.getElementById(`signature-${unionId}`);
    const completeDiv = document.getElementById(`union-${unionId}-signature-complete`);
    
    // Очищаем область подписи
    signatureArea.innerHTML = '<div id="signature-' + unionId + '">Нажмите здесь для подписи</div>';
    
    // Восстанавливаем обработчик клика
    signatureArea.onclick = function() {
      if (!this.querySelector('canvas')) {
        startSignature(unionId);
      }
    };
    
    // Сохраняем изменения
    const union = unions.find(u => u.id === unionId);
    if (union) {
      union.signature = '';
      union.signatureHTML = '';
      addToSequence(unionId, 'signature', 'erased');
      saveUnions();
    }
    
    // Скрываем кнопки
    completeDiv.classList.add('union-hidden');
    
    // Имя не сбрасываем - оставляем как есть
  }
  
  function concludeUnion(unionId) {
    const completeDiv = document.getElementById(`union-${unionId}-signature-complete`);
    const concludedDiv = document.getElementById(`union-${unionId}-concluded`);
    const nameInput = document.getElementById(`playerName-${unionId}`);
    const nameReadonlyInput = document.getElementById(`playerNameReadonly-${unionId}`);
    const signatureArea = document.getElementById(`signatureArea-${unionId}`);
    
    // Проверяем обязательность имени и подписи
    if (!nameInput || !nameInput.value.trim()) {
      alert('Введите имя перед заключением союза!');
      return;
    }
    
    if (!signatureArea || !signatureArea.hasChildNodes()) {
      alert('Необходимо поставить подпись перед заключением союза!');
      return;
    }
    
    // Копируем имя в readonly поле
    if (nameInput && nameReadonlyInput) {
      nameReadonlyInput.value = nameInput.value;
      nameReadonlyInput.style.display = 'block';
    }
    
    // Скрываем кнопки и показываем заключенное состояние
    completeDiv.classList.add('union-hidden');
    concludedDiv.classList.remove('union-hidden');
    
    // Делаем поля нередактируемыми
    if (nameInput) {
      nameInput.style.display = 'none';
    }
    
    // Делаем область подписи нередактируемой, но оставляем видимой
    if (signatureArea) {
      signatureArea.style.pointerEvents = 'none';
      signatureArea.style.opacity = '0.7';
      signatureArea.style.background = '#f8f9fa';
    }
    
    // Сохраняем данные союза
    const union = unions.find(u => u.id === unionId);
    if (union) {
      union.playerName = nameInput.value;
      // Сохраняем HTML подписи, если она есть
      if (signatureArea.innerHTML) {
        union.signatureHTML = signatureArea.innerHTML;
      }
      union.concluded = true;
      union.concludedAt = new Date().toISOString();
      addToSequence(unionId, 'concluded', true);
      saveUnions();
    }
  }
  
  function viewUnionHistory() {
    if (unions.length === 0) {
      alert('Нет союзов для просмотра истории');
      return;
    }
    
    let historyText = 'ИСТОРИЯ СОЮЗОВ:\n\n';
    
    unions.forEach((union, index) => {
      historyText += `Союз #${union.id} (${union.playerName || 'Без имени'}):\n`;
      
      if (union.sequence && union.sequence.length > 0) {
        union.sequence.forEach((step, stepIndex) => {
          const time = new Date(step.timestamp).toLocaleString();
          const actionText = getActionText(step.action, step.value);
          historyText += `  ${stepIndex + 1}. ${actionText} (${time})\n`;
        });
      } else {
        historyText += '  История пуста\n';
      }
      
      if (union.concluded) {
        historyText += `  ✅ ЗАКЛЮЧЕН: ${union.concludedAt ? new Date(union.concludedAt).toLocaleString() : 'Неизвестно'}\n`;
      }
      
      historyText += '\n';
    });
    
    // Создаем модальное окно для отображения истории
    const modal = document.createElement('div');
    modal.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
    `;
    
    const modalContent = document.createElement('div');
    modalContent.style.cssText = `
      background: white;
      padding: 20px;
      border-radius: 8px;
      max-width: 90%;
      max-height: 80%;
      overflow-y: auto;
      font-family: monospace;
      font-size: 12px;
      white-space: pre-wrap;
    `;
    
    modalContent.textContent = historyText;
    
    const closeBtn = document.createElement('button');
    closeBtn.textContent = 'Закрыть';
    closeBtn.style.cssText = `
      margin-top: 10px;
      padding: 8px 16px;
      background: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    `;
    closeBtn.onclick = () => modal.remove();
    
    modalContent.appendChild(closeBtn);
    modal.appendChild(modalContent);
    document.body.appendChild(modal);
    
    // Закрытие по клику вне модального окна
    modal.onclick = (e) => {
      if (e.target === modal) modal.remove();
    };
  }

  // Выгрузка данных одного союза в один HTML-файл (сохранение порядка показа текстов и действий)
  function exportUnion(unionId) {
    try {
      const union = (Array.isArray(unions) ? unions.find(u => u.id === unionId) : null) || {};
      const playerName = union.playerName || (document.getElementById(`playerNameReadonly-${unionId}`)?.value || document.getElementById(`playerName-${unionId}`)?.value || '').trim();
      // Подпись: предпочитаем сохранённый data URL, иначе пытаемся взять из DOM
      let signatureDataUrl = union.signature || '';
      if (!signatureDataUrl) {
        const img = document.querySelector(`#signatureArea-${unionId} img`);
        if (img && img.src && img.src.startsWith('data:image/')) signatureDataUrl = img.src;
      }
      // Формируем последовательность вывода по union.sequence: показываем тексты по мере появления и действия в нужных местах
      const seq = Array.isArray(union.sequence) ? union.sequence.slice() : [];
      const safeGetText = (id) => {
        const el = document.getElementById(`union-${unionId}-${id}`);
        const t = el ? (el.getAttribute('data-text') || el.textContent || '') : '';
        return /верните телефон владельцу/i.test(t) ? '' : t;
      };
      // Берём HTML для сохранения жирного как в приложении (strong/b/br), остальное удаляем
      const getRichHTML = (id) => {
        const el = document.getElementById(`union-${unionId}-${id}`);
        return el ? (el.innerHTML || '') : '';
      };
      const sanitizeRich = (html) => {
        if (!html) return '';
        // Удаляем все теги, кроме <strong>, <b>, <br>
        return html
          .replace(/<(?!\/?(?:strong|b|br)\b)[^>]*>/gi, '')
          .replace(/on\w+\s*=\s*"[^"]*"/gi, '')
          .replace(/on\w+\s*=\s*'[^']*'/gi, '')
          .replace(/on\w+\s*=\s*[^\s>]+/gi, '');
      };
      const ordered = [];
      // Если раньше записали text2 до клика по "Могу довериться", откладываем его до первого choice:trust
      let pendingText2 = null;
      let trustChoiceSeen = false;
      seq.forEach(step => {
        if (!step || !step.action) return;
        if (/^password/.test(step.action)) return; // пропускаем пароли
        if (step.action === 'text' && typeof step.value === 'string') {
          // Исключаем из выгрузки подсказку про подпись (text12 = "Распишитесь")
          if (step.value === 'text12') return;
          // Откладываем text2 ("Насколько процентов...") пока не выведем клик доверия
          if (step.value === 'text2' && !trustChoiceSeen) {
            pendingText2 = { kind: 'text', id: 'text2', text: safeGetText('text2') };
            return;
          }
          const txt = safeGetText(step.value);
          if (txt) ordered.push({ kind: 'text', id: step.value, text: txt });
          return;
        }
        switch (step.action) {
          case 'choice':
            if (step.value === 'trust') {
              ordered.push({ kind: 'action', text: 'Кнопка: Могу довериться' });
              trustChoiceSeen = true;
              // Если есть отложенный text2 — выводим сразу после клика
              if (pendingText2) {
                if (pendingText2.text) ordered.push(pendingText2);
                pendingText2 = null;
              }
            } else {
              ordered.push({ kind: 'action', text: 'Кнопка: Предпочту сам' });
            }
            break;
          case 'trust_percent':
            ordered.push({ kind: 'action', text: `Кнопка: ${step.value}%` });
            break;
          // trust_percent_summary больше не выводим в экспорт, т.к. дублирует кнопку процента
          case 'hundred_percent':
            ordered.push({ kind: 'action', text: step.value ? 'Кнопка: Да' : 'Кнопка: Нет' });
            break;
          case 'agreement':
            ordered.push({ kind: 'action', text: step.value ? 'Кнопка: Да' : 'Кнопка: Нет' });
            break;
          case 'final_agreement':
            ordered.push({ kind: 'action', text: step.value ? 'Кнопка: Согласен' : 'Кнопка: Не согласен' });
            break;
          case 'name_input':
            // Имя выводим отдельно внизу; не дублируем в событиях
            break;
          case 'signature':
            // Подпись фиксируем картинкой внизу; не дублируем в событиях
            break;
          case 'concluded':
            // Статус вверху уже есть; не дублируем в событиях
            break;
        }
      });
      // Если клик доверия так и не встретился, но text2 был — добавим его как есть (fallback)
      if (pendingText2) {
        ordered.push(pendingText2);
        pendingText2 = null;
      }
      const concluded = !!union.concluded;
      const exportedAt = new Date().toLocaleString();
      const concludedAtIso = union.concludedAt || '';
      const concludedDate = concludedAtIso ? new Date(concludedAtIso) : null;
      const formatLocalDateTime = (date)=>{
        try{
          const d = date || new Date();
          const dd = String(d.getDate()).padStart(2,'0');
          const mm = String(d.getMonth()+1).padStart(2,'0');
          const yyyy = d.getFullYear();
          const HH = String(d.getHours()).padStart(2,'0');
          const MM = String(d.getMinutes()).padStart(2,'0');
          const SS = String(d.getSeconds()).padStart(2,'0');
          // Формируем смещение UTC корректно
          const offsetMin = -d.getTimezoneOffset(); // мин относительно UTC
          const sign = offsetMin >= 0 ? '+' : '-';
          const abs = Math.abs(offsetMin);
          const oh = Math.floor(abs/60);
          const om = abs % 60;
          const offsetStr = `UTC ${sign}${oh}${om ? ':'+String(om).padStart(2,'0') : ''}`;
          return `${dd}.${mm}.${yyyy} ${HH}:${MM}:${SS} (${offsetStr})`;
        }catch{ return (date||new Date()).toLocaleString(); }
      };
      // Формируем простой самодостаточный HTML
      const safe = (s)=> (s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
      const titleText = `Союз с участником ${playerName ? safe(playerName) : ''}`.trim();
      const html = `<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8"><title>${titleText}</title>
<style>
  html,body{font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',sans-serif; margin:0; padding:0; color:#222; font-size:16px; line-height:1.5}
  body{margin:20px}
  h1{margin:0 0 4px 0; font-weight:600}
  .meta{color:#666; font-size:12px; margin-bottom:16px}
  .block{background:#fff; border:1px solid #e5e7eb; border-radius:8px; padding:12px; margin:12px 0}
  .label{color:#6c757d; font-size:12px; margin-bottom:6px}
  img.signature{max-width:100%; height:90px; object-fit:contain; border:1px solid #ccc; border-radius:4px; background:#f8f9fa; opacity:.85}
  @media (max-width: 640px){
    img.signature{height:140px}
  }
  pre{white-space:pre-wrap; word-break:break-word; font-family:inherit; font-size:16px; line-height:1.5; margin:0}
  pre b, pre strong{font-weight:700}
  .ok{color:#198754}
  .warn{color:#dc3545}
  .grid{display:grid; grid-template-columns:1fr; gap:8px}
  .textItem{border-top:1px dashed #e5e7eb; padding-top:8px; margin-top:8px}
  .actionLine{color:#198754; font-weight:600}
  .blueBorder{border:2px solid #4a90e2; border-radius:8px; padding:10px; background:#f0f8ff}
  .greenBorder{border:2px solid #28a745; border-radius:8px; padding:10px; background:#f6fff6}
 </style></head><body>
<h1>${titleText}</h1>
${concluded ? `<div class=\"block\"><div class=\"ok\" style=\"font-weight:600\">Заключен</div><div>Дата заключения ${formatLocalDateTime(concludedDate)}</div></div>` : ''}
<div class="meta">Экспортировано: ${exportedAt}${concluded ? ' · <span class="ok">Заключен</span>' : ''}</div>
<div class="block"><div class="label">Условия договора</div><div class="grid">${ordered.map(it=> {
  if (it.kind==='text') {
    const extraClass = it.id==='text7' ? ' blueBorder' : (it.id==='text9' ? ' greenBorder' : '');
    const rich = sanitizeRich(getRichHTML(it.id)) || safe(it.text);
    return `<div class="textItem${extraClass}"><pre>${rich}</pre></div>`;
  }
  return `<div class="textItem actionLine"><pre>${safe(it.text)}</pre></div>`;
}).join('')}</div></div>
<div class="block"><div class="label">Имя участника</div><div>${playerName ? safe(playerName) : '<span class="warn">— не указано —</span>'}</div></div>
<div class="block"><div class="label">Подпись</div>${signatureDataUrl ? `<img class="signature" src="${signatureDataUrl}" alt="signature">` : '<div class="warn">— нет подписи —</div>'}</div>
 </body></html>`;
      const blob = new Blob([html], { type: 'text/html;charset=utf-8' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      // Формируем имя файла: "Союз с [Имя] [dd.mm.yy].html". Дата — дата заключения, иначе сегодня
      const fileDate = concludedDate || new Date();
      const ddFN = String(fileDate.getDate()).padStart(2,'0');
      const mmFN = String(fileDate.getMonth()+1).padStart(2,'0');
      const yyFN = String(fileDate.getFullYear()).slice(-2);
      const fileSafeName = (playerName || 'Без имени').trim();
      a.download = `Союз с ${fileSafeName} ${ddFN}.${mmFN}.${yyFN}.html`;
      document.body.appendChild(a);
      a.click();
      setTimeout(() => { URL.revokeObjectURL(a.href); a.remove(); }, 1000);
    } catch (e) {
      console.error('exportUnion error', e);
      alert('Не удалось выгрузить союз: ' + (e?.message || e));
    }
  }
  
  function getActionText(action, value) {
    const actionMap = {
      'choice': value === 'trust' ? 'Выбрал "Могу довериться"' : 'Выбрал "Предпочту сам"',
      'trust_percent': `Выбрал процент доверия: ${value}%`,
      'hundred_percent': value ? 'Ответил "Да" на 100%' : 'Ответил "Нет" на 100%',
      'password': value === 'correct' ? 'Ввел правильный пароль' : 'Ввел неправильный пароль',
      'password_agreement': value === 'correct' ? 'Пароль (условия) верный' : 'Пароль (условия) неверный',
      'password_final': value === 'correct' ? 'Пароль (финал) верный' : 'Пароль (финал) неверный',
      'agreement': value ? 'Согласился на условия' : 'Не согласился на условия',
      'final_agreement': value ? 'Согласился заключить союз' : 'Не согласился заключить союз',
      'name_input': `Ввел имя: "${value}"`,
      'signature': 'Поставил подпись',
      'concluded': 'Заключил союз'
    };
    
    return actionMap[action] || `${action}: ${value}`;
  }
  
  function editAllUnions() {
    const password = prompt('Введите пароль для редактирования всех союзов:');
    if (password !== '1111') {
      alert('Неверный пароль!');
      return;
    }
    
    // Создаем модальное окно для редактирования всех союзов
    const modal = document.createElement('div');
    modal.className = 'union-edit-modal';
    modal.innerHTML = `
      <div class="union-edit-content" style="max-width: 90%; max-height: 90%; overflow-y: auto;">
        <h3>Редактирование всех союзов</h3>
        <div id="editAllTexts"></div>
        <div style="margin-top: 20px; text-align: right;">
          <button class="btn" onclick="saveAllUnionsEdit()" style="background: #28a745; margin-right: 10px;">Сохранить все</button>
          <button class="btn" onclick="closeUnionEdit()" style="background: #6c757d;">Отмена</button>
        </div>
      </div>
    `;
    
    // Заполняем тексты для редактирования (только последующие тексты)
    const editTextsDiv = modal.querySelector('#editAllTexts');
    for (let i = 2; i <= 12; i++) { // Начинаем с текста 2, так как текст 1 не редактируется
      const textElement = document.querySelector(`[id*="-text${i}"]`);
      if (textElement) {
        const unionId = textElement.id.match(/union-(\d+)-/)[1];
        editTextsDiv.innerHTML += `
          <div style="margin-bottom: 15px;">
            <label style="display: block; margin-bottom: 5px; font-weight: bold;">Текст ${i} (Союз ${unionId}):</label>
            <textarea id="editAllText-${unionId}-${i}" style="width: 100%; height: 80px; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">${textElement.textContent}</textarea>
          </div>
        `;
      }
    }
    
    document.body.appendChild(modal);
  }
  
  function saveAllUnionsEdit() {
    // Сохраняем все отредактированные тексты
    for (let i = 2; i <= 12; i++) {
      const textElement = document.querySelector(`[id*="-text${i}"]`);
      if (textElement) {
        const unionId = textElement.id.match(/union-(\d+)-/)[1];
        const editTextarea = document.getElementById(`editAllText-${unionId}-${i}`);
        if (editTextarea) {
          textElement.textContent = editTextarea.value;
          textElement.setAttribute('data-text', editTextarea.value);
        }
      }
    }
    
    // Сохраняем союзы
    saveUnions();
    
    // Закрываем модальное окно
    closeUnionEdit();
    
    alert('Все тексты союзов сохранены!');
  }
  
  function editUnion(unionId) {
    const password = prompt('Введите пароль для редактирования:');
    if (password !== '1111') {
      alert('Неверный пароль!');
      return;
    }
    
    // Создаем модальное окно для редактирования
    const modal = document.createElement('div');
    modal.className = 'union-edit-modal';
    modal.innerHTML = `
      <div class="union-edit-content">
        <h3>Редактирование текстов союза</h3>
        <div id="editTexts-${unionId}"></div>
        <div style="margin-top: 20px; text-align: right;">
          <button class="btn" onclick="saveUnionEdit(${unionId})" style="background: #28a745; margin-right: 10px;">Сохранить</button>
          <button class="btn" onclick="closeUnionEdit()" style="background: #6c757d;">Отмена</button>
        </div>
      </div>
    `;
    
    // Заполняем тексты для редактирования
    const editTextsDiv = modal.querySelector(`#editTexts-${unionId}`);
    for (let i = 1; i <= 12; i++) {
      const textElement = document.getElementById(`union-${unionId}-text${i}`);
      if (textElement) {
        const originalText = textElement.getAttribute('data-text');
        editTextsDiv.innerHTML += `
          <div style="margin-bottom: 15px;">
            <label style="display: block; margin-bottom: 5px; font-weight: bold;">Текст ${i}:</label>
            <textarea class="union-edit-textarea" id="editText${i}-${unionId}" data-original="${originalText}">${originalText}</textarea>
          </div>
        `;
      }
    }
    
    document.body.appendChild(modal);
  }
  
  function saveUnionEdit(unionId) {
    // Сохраняем изменения
    for (let i = 1; i <= 12; i++) {
      const textElement = document.getElementById(`union-${unionId}-text${i}`);
      const editElement = document.getElementById(`editText${i}-${unionId}`);
      
      if (textElement && editElement) {
        const newText = editElement.value;
        textElement.innerHTML = newText.replace(/\n/g, '<br>');
        textElement.setAttribute('data-text', newText);
      }
    }
    
    closeUnionEdit();
  }
  
  function closeUnionEdit() {
    const modal = document.querySelector('.union-edit-modal');
    if (modal) {
      modal.remove();
    }
  }
  
  
  function deleteUnion(unionId) {
    const password = prompt('Введите пароль для удаления союза:');
    if (password !== '1111') {
      alert('Неверный пароль!');
      return;
    }
    
    if (confirm('Вы уверены, что хотите удалить этот союз?')) {
      const unionElement = document.getElementById(`union-${unionId}`);
      if (unionElement) {
        unionElement.remove();
      }
    }
  }
  
      

  // Тестовая функция для проверки сохранения подписей
  function testSignaturePersistence() {
    console.log('=== TESTING SIGNATURE PERSISTENCE ===');
    console.log('Current unions:', unions);
    
    // Проверяем, есть ли союзы с подписями
    unions.forEach((union, index) => {
      console.log(`Union ${index + 1} (ID: ${union.id}):`);
      console.log('  - Player name:', union.playerName);
      console.log('  - Signature:', union.signature ? 'EXISTS' : 'NONE');
      console.log('  - Signature HTML:', union.signatureHTML ? 'EXISTS' : 'NONE');
      console.log('  - Concluded:', union.concluded);
      
      if (union.signature) {
        console.log('  - Signature type:', union.signature.startsWith('data:image/') ? 'DATA_URL' : 'OTHER');
        console.log('  - Signature length:', union.signature.length);
      }
      
      if (union.signatureHTML) {
        console.log('  - SignatureHTML length:', union.signatureHTML.length);
        console.log('  - Contains canvas:', union.signatureHTML.includes('<canvas'));
      }
    });
    
    console.log('=== END TEST ===');
  }
  
  // Инициализация союзов при загрузке страницы
  document.addEventListener('DOMContentLoaded', function() {
    loadUnions();
    
    // Добавляем тестовую функцию в глобальную область видимости
    window.testSignaturePersistence = testSignaturePersistence;
  });
  
</script>
<script>
  (function(){
    function cfGetCurrentTurnNumber(){
      try { return parseInt(localStorage.getItem('cf_turn_number')||'1',10)||1; } catch { return 1; }
    }
    function cfRestoreTurnComment(){
      try {
        const el = document.getElementById('turnComment');
        if (!el) return;
        const t = cfGetCurrentTurnNumber();
        const saved = localStorage.getItem('cf_turn_comment_'+t) || '';
        if (el.value !== saved) el.value = saved;
        if (!el._cfWired){
          el._cfWired = true;
          el.addEventListener('input', ()=>{
            try { localStorage.setItem('cf_turn_comment_'+cfGetCurrentTurnNumber(), el.value || ''); } catch {}
          });
        }
      } catch {}
    }
    function cfPatchRenderMoves(){
      try {
        const orig = window.renderMoves;
        if (typeof orig === 'function' && !orig._cfPatched){
          const wrapped = function(){
            const res = orig.apply(this, arguments);
            try { cfRestoreTurnComment(); } catch {}
            return res;
          };
          wrapped._cfPatched = true;
          window.renderMoves = wrapped;
        }
      } catch {}
    }
    document.addEventListener('DOMContentLoaded', function(){
      cfPatchRenderMoves();
      setTimeout(cfRestoreTurnComment, 0);
    });
    setTimeout(cfPatchRenderMoves, 1000);
  })();
</script>
</script>
<script>
  (function(){
    const STORAGE_KEY = 'errorHistoryLogV1';
    const MAX_ITEMS = 200;
    function readLog(){ try { return JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]') || []; } catch { return []; } }
    function writeLog(arr){ try { localStorage.setItem(STORAGE_KEY, JSON.stringify(arr.slice(-MAX_ITEMS))); } catch {}
    }
    function normalize(err){
      if (!err) return {};
      if (err instanceof Error) return { message: err.message, stack: String(err.stack||'') };
      if (typeof err === 'string') return { message: err };
      try { return { message: JSON.stringify(err) }; } catch { return { message: String(err) }; }
    }
    function pushEntry(entry){
      const log = readLog();
      const last = log[log.length-1];
      const signature = `${entry.message}|${entry.source||''}|${entry.line||''}|${entry.col||''}`;
      const lastSig = last ? `${last.message}|${last.source||''}|${last.line||''}|${last.col||''}` : '';
      if (signature === lastSig) {
        last.repeat = (last.repeat||1) + 1;
        last.lastAt = entry.time;
        writeLog(log);
        return;
      }
      log.push(entry);
      writeLog(log);
    }
    function formatLocation(source, line, col){
      if (!source && !line) return '';
      let s = source ? source.split('?')[0] : '';
      if (s.startsWith(location.origin)) s = s.slice(location.origin.length);
      return `${s}:${line || 0}:${col || 0}`;
    }
    function toEntry(o){
      return {
        time: new Date().toLocaleString(),
        type: o.type || 'error',
        message: o.message || 'Unknown error',
        source: o.source || '',
        line: o.lineno || o.line || 0,
        col: o.colno || o.col || 0,
        stack: o.stack || (o.error && o.error.stack) || (o.reason && o.reason.stack) || '',
        userAgent: navigator.userAgent
      };
    }
    window.viewErrorHistory = function(){
      const data = readLog();
      const overlay = document.createElement('div');
      overlay.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,.5);z-index:100000;display:flex;align-items:center;justify-content:center;';
      const panel = document.createElement('div');
      panel.style.cssText = 'background:#111;color:#eee;max-width:95%;max-height:85%;width:1000px;border-radius:8px;box-shadow:0 6px 24px rgba(0,0,0,.4);display:flex;flex-direction:column;overflow:hidden;font-family:Consolas,Menlo,monospace;font-size:12px;';
      const header = document.createElement('div');
      header.style.cssText = 'display:flex;align-items:center;justify-content:space-between;padding:10px 12px;background:#1f2937;border-bottom:1px solid #374151;';
      header.innerHTML = '<div style="font-weight:700">История ошибок</div>';
      const buttons = document.createElement('div');
      const clearBtn = document.createElement('button');
      clearBtn.textContent = 'Очистить';
      clearBtn.style.cssText = 'background:#dc2626;margin-right:8px;font-size:12px;padding:6px 10px;border:none;border-radius:4px;cursor:pointer;color:#fff;';
      clearBtn.onclick = function(){ localStorage.removeItem(STORAGE_KEY); overlay.remove(); };
      const closeBtn = document.createElement('button');
      closeBtn.textContent = 'Закрыть';
      closeBtn.style.cssText = 'background:#4a90e2;font-size:12px;padding:6px 10px;border:none;border-radius:4px;cursor:pointer;color:#fff;';
      closeBtn.onclick = function(){ overlay.remove(); };
      buttons.appendChild(clearBtn); buttons.appendChild(closeBtn); header.appendChild(buttons);
      const list = document.createElement('div');
      list.style.cssText = 'overflow:auto;flex:1;padding:10px 12px;white-space:pre-wrap;word-break:break-word;';
      if (!data.length) {
        list.textContent = 'Пока нет записей об ошибках.';
      } else {
        list.innerHTML = data.map((e, idx) => {
          const loc = formatLocation(e.source, e.line, e.col);
          const rep = e.repeat && e.repeat>1 ? ` (повторено ${e.repeat}×, последнее: ${e.lastAt})` : '';
          const stack = e.stack ? `\n${e.stack}` : '';
          return `[${idx+1}] ${e.time} ${e.type || 'error'}${rep}\nСообщение: ${e.message}\nИсточник: ${loc}${stack}`;
        }).join('\n\n');
      }
      panel.appendChild(header); panel.appendChild(list); overlay.appendChild(panel); document.body.appendChild(overlay);
      overlay.onclick = (ev)=>{ if (ev.target===overlay) overlay.remove(); };
    };
    window.showErrors = window.viewErrorHistory;
    window.throwTestError = function(){ throw new Error('Test error for history'); };
    window.addEventListener('error', function(e){
      try {
        const base = normalize(e.error);
        const entry = toEntry({
          type: 'error',
          message: base.message || e.message,
          source: e.filename || (e.error && e.error.fileName) || '',
          lineno: e.lineno,
          colno: e.colno,
          stack: base.stack
        });
        pushEntry(entry);
      } catch {}
    }, true);
    window.addEventListener('unhandledrejection', function(e){
      try {
        const base = normalize(e.reason);
        const entry = toEntry({
          type: 'unhandledrejection',
          message: base.message || 'Unhandled promise rejection',
          source: '',
          stack: base.stack
        });
        pushEntry(entry);
      } catch {}
    });
    const prevOnError = window.onerror;
    window.onerror = function(message, source, lineno, colno, error){
      try {
        const base = normalize(error||message);
        const entry = toEntry({ type:'onerror', message: base.message||String(message), source, line: lineno, col: colno, stack: base.stack });
        pushEntry(entry);
      } catch {}
      if (typeof prevOnError === 'function') try { return prevOnError.apply(this, arguments); } catch {}
      return false;
    };
  })();
</script>
</body>
</html>